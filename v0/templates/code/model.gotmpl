package {{.Package}}

import (
	"time"
	{{- if .Validation}}
	"fmt"
	"strings"
	{{- end}}
	{{- if .Database}}
	"database/sql/driver"
	"encoding/json"
	{{- end}}
)

// {{.Name}} represents the {{.Name | toLower}} model
{{- if .Description}}
// {{.Description}}
{{- end}}
type {{.Name}} struct {
	{{- if .Fields}}
	{{- range .Fields}}
	{{.Name | title}} {{.Type}} `{{.Tag | default (printf "db:\"%s\" json:\"%s\"" (.Name | snakeCase) (.Name | snakeCase))}}`{{if .Description}} // {{.Description}}{{end}}
	{{- end}}
	{{- else}}
	ID     string `db:"id" json:"id"`
	{{- end}}

	{{- if .Timestamps}}
	CreatedAt time.Time  `db:"created_at" json:"created_at"`
	UpdatedAt time.Time  `db:"updated_at" json:"updated_at"`
	{{- end}}

	{{- if .SoftDelete}}
	DeletedAt *time.Time `db:"deleted_at" json:"deleted_at,omitempty"`
	{{- end}}
}

{{- if .Database}}

// TableName returns the database table name for {{.Name}}
func ({{.Name | substr 0 1 | toLower}}) TableName() string {
	return "{{.Table | default (.Name | toLower | pluralize)}}"
}

{{- if .Timestamps}}
// BeforeCreate is called before creating a {{.Name}}
func (m *{{.Name}}) BeforeCreate() error {
	now := time.Now()
	m.CreatedAt = now
	m.UpdatedAt = now
	return nil
}

// BeforeUpdate is called before updating a {{.Name}}
func (m *{{.Name}}) BeforeUpdate() error {
	m.UpdatedAt = time.Now()
	return nil
}
{{- end}}

{{- if .SoftDelete}}
// BeforeDelete performs soft delete by setting DeletedAt timestamp
func (m *{{.Name}}) BeforeDelete() error {
	now := time.Now()
	m.DeletedAt = &now
	return nil
}

// IsDeleted returns true if the model has been soft deleted
func (m *{{.Name}}) IsDeleted() bool {
	return m.DeletedAt != nil
}
{{- end}}

{{- end}}

{{- if .Validation}}

// Validate performs validation on the {{.Name}} model
func (m *{{.Name}}) Validate() error {
	var errors []string

	{{- if .Fields}}
	{{- range .Fields}}
	{{- if .Validation}}
	{{- if contains .Validation "required"}}
	if m.{{.Name | title}} == {{if eq .Type "string"}}""{{else if eq .Type "int"}}0{{else}}nil{{end}} {
		errors = append(errors, "{{.Name | snakeCase}} is required")
	}
	{{- end}}
	{{- if and (eq .Type "string") (contains .Validation "min:")}}
	{{- $minLen := substr .Validation (index (split .Validation "min:") 1) | split "," | index 0}}
	if len(m.{{.Name | title}}) < {{$minLen}} {
		errors = append(errors, "{{.Name | snakeCase}} must be at least {{$minLen}} characters")
	}
	{{- end}}
	{{- if and (eq .Type "string") (contains .Validation "max:")}}
	{{- $maxLen := substr .Validation (index (split .Validation "max:") 1) | split "," | index 0}}
	if len(m.{{.Name | title}}) > {{$maxLen}} {
		errors = append(errors, "{{.Name | snakeCase}} must be at most {{$maxLen}} characters")
	}
	{{- end}}
	{{- end}}
	{{- end}}
	{{- else}}
	// TODO: Add your validation logic here
	{{- end}}

	if len(errors) > 0 {
		return fmt.Errorf("validation failed: %s", strings.Join(errors, ", "))
	}

	return nil
}

{{- end}}

{{- if .Indexes}}

// GetIndexes returns the database indexes for {{.Name}}
func ({{.Name | substr 0 1 | toLower}}) GetIndexes() []string {
	return []string{
		{{- range .Indexes}}
		"{{.}}",
		{{- end}}
	}
}

{{- end}}

{{- if .Relationships}}

{{- range $relation, $target := .Relationships}}
{{- if eq $relation "belongs_to"}}
// Get{{$target}} retrieves the associated {{$target}} record
func (m *{{$.Name}}) Get{{$target}}() *{{$target}} {
	// TODO: Implement belongs_to relationship for {{$target}}
	return nil
}
{{- else if eq $relation "has_one"}}
// Get{{$target}} retrieves the associated {{$target}} record
func (m *{{$.Name}}) Get{{$target}}() *{{$target}} {
	// TODO: Implement has_one relationship for {{$target}}
	return nil
}
{{- else if eq $relation "has_many"}}
// Get{{$target | pluralize}} retrieves the associated {{$target | pluralize}} records
func (m *{{$.Name}}) Get{{$target | pluralize}}() []*{{$target}} {
	// TODO: Implement has_many relationship for {{$target | pluralize}}
	return nil
}
{{- else if eq $relation "many_to_many"}}
// Get{{$target | pluralize}} retrieves the associated {{$target | pluralize}} records via junction table
func (m *{{$.Name}}) Get{{$target | pluralize}}() []*{{$target}} {
	// TODO: Implement many_to_many relationship for {{$target | pluralize}}
	return nil
}
{{- end}}
{{- end}}

{{- end}}

// =============================================================================
// Serialization methods
// =============================================================================

{{- if .Database}}
// Value implements the driver.Valuer interface for database storage
func (m {{.Name}}) Value() (driver.Value, error) {
	return json.Marshal(m)
}

// Scan implements the sql.Scanner interface for database retrieval
func (m *{{.Name}}) Scan(value interface{}) error {
	if value == nil {
		return nil
	}

	bytes, ok := value.([]byte)
	if !ok {
		return fmt.Errorf("cannot scan %T into {{.Name}}", value)
	}

	return json.Unmarshal(bytes, m)
}
{{- end}}

// ToMap converts the {{.Name}} to a map representation
func (m *{{.Name}}) ToMap() map[string]interface{} {
	result := make(map[string]interface{})

	{{- if .Fields}}
	{{- range .Fields}}
	result["{{.Name | snakeCase}}"] = m.{{.Name | title}}
	{{- end}}
	{{- else}}
	result["id"] = m.ID
	{{- end}}

	{{- if .Timestamps}}
	result["created_at"] = m.CreatedAt
	result["updated_at"] = m.UpdatedAt
	{{- end}}

	{{- if .SoftDelete}}
	if m.DeletedAt != nil {
		result["deleted_at"] = m.DeletedAt
	}
	{{- end}}

	return result
}

// FromMap populates the {{.Name}} from a map representation
func (m *{{.Name}}) FromMap(data map[string]interface{}) error {
	{{- if .Fields}}
	{{- range .Fields}}
	if val, exists := data["{{.Name | snakeCase}}"]; exists {
		{{- if eq .Type "string"}}
		if str, ok := val.(string); ok {
			m.{{.Name | title}} = str
		}
		{{- else if eq .Type "int"}}
		if num, ok := val.(float64); ok {
			m.{{.Name | title}} = int(num)
		}
		{{- else if eq .Type "int64"}}
		if num, ok := val.(float64); ok {
			m.{{.Name | title}} = int64(num)
		}
		{{- else if eq .Type "float64"}}
		if num, ok := val.(float64); ok {
			m.{{.Name | title}} = num
		}
		{{- else if eq .Type "bool"}}
		if b, ok := val.(bool); ok {
			m.{{.Name | title}} = b
		}
		{{- else if eq .Type "time.Time"}}
		if str, ok := val.(string); ok {
			if t, err := time.Parse(time.RFC3339, str); err == nil {
				m.{{.Name | title}} = t
			}
		}
		{{- else}}
		// TODO: Handle type conversion for {{.Type}}
		{{- end}}
	}
	{{- end}}
	{{- else}}
	if val, exists := data["id"]; exists {
		if str, ok := val.(string); ok {
			m.ID = str
		}
	}
	{{- end}}

	{{- if .Timestamps}}
	if val, exists := data["created_at"]; exists {
		if str, ok := val.(string); ok {
			if t, err := time.Parse(time.RFC3339, str); err == nil {
				m.CreatedAt = t
			}
		}
	}

	if val, exists := data["updated_at"]; exists {
		if str, ok := val.(string); ok {
			if t, err := time.Parse(time.RFC3339, str); err == nil {
				m.UpdatedAt = t
			}
		}
	}
	{{- end}}

	{{- if .SoftDelete}}
	if val, exists := data["deleted_at"]; exists {
		if str, ok := val.(string); ok && str != "" {
			if t, err := time.Parse(time.RFC3339, str); err == nil {
				m.DeletedAt = &t
			}
		}
	}
	{{- end}}

	return nil
}

// Clone creates a deep copy of the {{.Name}}
func (m *{{.Name}}) Clone() *{{.Name}} {
	clone := &{{.Name}}{
		{{- if .Fields}}
		{{- range .Fields}}
		{{.Name | title}}: m.{{.Name | title}},
		{{- end}}
		{{- else}}
		ID: m.ID,
		{{- end}}

		{{- if .Timestamps}}
		CreatedAt: m.CreatedAt,
		UpdatedAt: m.UpdatedAt,
		{{- end}}
	}

	{{- if .SoftDelete}}
	if m.DeletedAt != nil {
		deletedAt := *m.DeletedAt
		clone.DeletedAt = &deletedAt
	}
	{{- end}}

	return clone
}

// =============================================================================
// Helper methods
// =============================================================================

// String returns a string representation of the {{.Name}}
func (m *{{.Name}}) String() string {
	{{- if .Fields}}
	{{- $firstField := index .Fields 0}}
	return fmt.Sprintf("{{.Name}}{ID: %s, {{$firstField.Name | title}}: %v}", m.ID, m.{{$firstField.Name | title}})
	{{- else}}
	return fmt.Sprintf("{{.Name}}{ID: %s}", m.ID)
	{{- end}}
}

// IsZero returns true if the model is in its zero state
func (m *{{.Name}}) IsZero() bool {
	{{- if .Fields}}
	{{- $firstField := index .Fields 0}}
	{{- if eq $firstField.Type "string"}}
	return m.{{$firstField.Name | title}} == ""
	{{- else if eq $firstField.Type "int"}}
	return m.{{$firstField.Name | title}} == 0
	{{- else}}
	return m.{{$firstField.Name | title}} == nil
	{{- end}}
	{{- else}}
	return m.ID == ""
	{{- end}}
}

// =============================================================================
// Query helpers (for use with repository pattern)
// =============================================================================

// {{.Name}}Filter represents filters for querying {{.Name | toLower | pluralize}}
type {{.Name}}Filter struct {
	{{- if .Fields}}
	{{- range .Fields}}
	{{- if eq .Type "string"}}
	{{.Name | title}}Like string `json:"{{.Name | snakeCase}}_like,omitempty" query:"{{.Name | snakeCase}}_like"`
	{{.Name | title}}In   []string `json:"{{.Name | snakeCase}}_in,omitempty" query:"{{.Name | snakeCase}}_in"`
	{{- else if or (eq .Type "int") (eq .Type "int64")}}
	{{.Name | title}}Min *{{.Type}} `json:"{{.Name | snakeCase}}_min,omitempty" query:"{{.Name | snakeCase}}_min"`
	{{.Name | title}}Max *{{.Type}} `json:"{{.Name | snakeCase}}_max,omitempty" query:"{{.Name | snakeCase}}_max"`
	{{- else if eq .Type "time.Time"}}
	{{.Name | title}}After  *time.Time `json:"{{.Name | snakeCase}}_after,omitempty" query:"{{.Name | snakeCase}}_after"`
	{{.Name | title}}Before *time.Time `json:"{{.Name | snakeCase}}_before,omitempty" query:"{{.Name | snakeCase}}_before"`
	{{- end}}
	{{- end}}
	{{- end}}

	{{- if .Timestamps}}
	CreatedAfter  *time.Time `json:"created_after,omitempty" query:"created_after"`
	CreatedBefore *time.Time `json:"created_before,omitempty" query:"created_before"`
	UpdatedAfter  *time.Time `json:"updated_after,omitempty" query:"updated_after"`
	UpdatedBefore *time.Time `json:"updated_before,omitempty" query:"updated_before"`
	{{- end}}

	{{- if .SoftDelete}}
	IncludeDeleted bool `json:"include_deleted,omitempty" query:"include_deleted"`
	OnlyDeleted    bool `json:"only_deleted,omitempty" query:"only_deleted"`
	{{- end}}

	// Pagination and sorting
	Page   int    `json:"page,omitempty" query:"page"`
	Limit  int    `json:"limit,omitempty" query:"limit"`
	Sort   string `json:"sort,omitempty" query:"sort"`
	Order  string `json:"order,omitempty" query:"order"`
	Search string `json:"search,omitempty" query:"search"`
}

// ApplyDefaults applies default values to the filter
func (f *{{.Name}}Filter) ApplyDefaults() {
	if f.Page <= 0 {
		f.Page = 1
	}
	if f.Limit <= 0 || f.Limit > 100 {
		f.Limit = 10
	}
	if f.Order == "" {
		f.Order = "asc"
	}
	if f.Sort == "" {
		{{- if .Timestamps}}
		f.Sort = "created_at"
		{{- else}}
		f.Sort = "id"
		{{- end}}
	}
}

// Validate validates the filter parameters
func (f *{{.Name}}Filter) Validate() error {
	if f.Page < 1 {
		return fmt.Errorf("page must be greater than 0")
	}
	if f.Limit < 1 || f.Limit > 100 {
		return fmt.Errorf("limit must be between 1 and 100")
	}
	if f.Order != "" && f.Order != "asc" && f.Order != "desc" {
		return fmt.Errorf("order must be 'asc' or 'desc'")
	}
	return nil
}