// {{.Description | default (printf "%s command for %s" .Name (.ProjectName | default "Forge application"))}}
package {{.Package | default "main"}}

import (
	"context"
	"fmt"
	"log"
	"os"
	"os/signal"
	"syscall"
	
	"github.com/xraph/forge"
	{{- if .Config}}
	"github.com/xraph/forge/pkg/config"
	{{- end}}
	{{- if .Database}}
	"github.com/xraph/forge/pkg/database"
	{{- end}}
	{{- if .Cache}}
	"github.com/xraph/forge/pkg/cache"
	{{- end}}
	{{- if .Events}}
	"github.com/xraph/forge/pkg/events"
	{{- end}}
	{{- if .Streaming}}
	"github.com/xraph/forge/pkg/streaming"
	{{- end}}
	{{- if .Metrics}}
	"github.com/xraph/forge/pkg/metrics"
	{{- end}}
	{{- if .Health}}
	"github.com/xraph/forge/pkg/health"
	{{- end}}
	{{- if .Services}}
	{{- range .Services}}
	"{{$.ProjectName}}/internal/services/{{. | toLower}}"
	{{- end}}
	{{- end}}
	{{- if .Controllers}}
	{{- range .Controllers}}
	"{{$.ProjectName}}/internal/controllers/{{. | toLower}}"
	{{- end}}
	{{- end}}
	{{- if .Middleware}}
	{{- range .Middleware}}
	"{{$.ProjectName}}/internal/middleware/{{. | toLower}}"
	{{- end}}
	{{- end}}
)

func main() {
	// Handle graceful shutdown
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Set up signal handling for graceful shutdown
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

	go func() {
		<-sigChan
		log.Println("Received termination signal, shutting down...")
		cancel()
	}()

	// Run the application
	if err := runApplication(ctx); err != nil {
		log.Fatalf("Application failed: %v", err)
	}
}

func runApplication(ctx context.Context) error {
	// Create application with options
	app, err := forge.NewApplication("{{.Name}}", "1.0.0",
		forge.WithDescription("{{.Description | default (printf "%s command application" .Name)}}"),
		{{- if .Config}}
		forge.WithConfigSources(
			config.NewFileSource(".forge.yaml"),
			config.NewEnvSource("{{.Name | toUpper}}"),
		),
		{{- end}}
		{{- if .Database}}
		forge.WithDatabase(&database.DatabaseConfig{
			Driver: "postgres", // TODO: Configure your database driver
			DSN:    os.Getenv("DATABASE_URL"),
		}),
		{{- end}}
		{{- if .Cache}}
		forge.WithCache(&cache.CacheConfig{
			Enabled:      true,
			DefaultCache: "default",
			Backends: map[string]cache.BackendConfig{
				"default": {
					Type: "memory",
					TTL:  "5m",
				},
			},
		}),
		{{- end}}
		{{- if .Events}}
		forge.WithEventBus(&events.EventServiceConfig{
			BufferSize: 1000,
			WorkerCount: 10,
		}),
		{{- end}}
		{{- if .Streaming}}
		forge.WithStreaming(&streaming.StreamingConfig{
			EnableWebSocket: true,
			EnableSSE:       true,
		}),
		{{- end}}
		{{- if .Metrics}}
		forge.WithMetrics(&metrics.ServiceConfig{
			EndpointConfig: &metrics.EndpointConfig{
				Enabled: true,
				Path:    "/metrics",
			},
		}),
		{{- end}}
		{{- if .Health}}
		forge.WithHealthChecker(&health.HealthCheckerConfig{
			CheckInterval: 30 * time.Second,
		}),
		{{- end}}
		{{- if .OpenAPI}}
		forge.WithOpenAPI(forge.OpenAPIConfig{
			Title:       "{{.Name}} API",
			Version:     "1.0.0",
			Description: "{{.Description | default (printf "API for %s" .Name)}}",
			Contact: &forge.OpenAPIContact{
				Name:  "{{.Author | default "API Team"}}",
				Email: "api@{{.ProjectName | default "example"}}.com",
			},
		}),
		{{- end}}
	)
	if err != nil {
		return fmt.Errorf("failed to create application: %w", err)
	}

	{{- if .Services}}
	// Register services
	{{- range .Services}}
	if err := app.AddService({{. | toLower}}.New{{.}}Service(app.Logger())); err != nil {
		return fmt.Errorf("failed to add {{. | toLower}} service: %w", err)
	}
	{{- end}}
	{{- end}}

	{{- if .Controllers}}
	// Register controllers
	{{- range .Controllers}}
	if err := app.AddController({{. | toLower}}.New{{.}}Controller(app.Logger())); err != nil {
		return fmt.Errorf("failed to add {{. | toLower}} controller: %w", err)
	}
	{{- end}}
	{{- end}}

	{{- if .Middleware}}
	// Register middleware
	{{- range .Middleware}}
	app.UseMiddleware({{. | toLower}}.New{{.}}Middleware(app.Logger()).Handler())
	{{- end}}
	{{- end}}

	// Register custom routes
	if err := registerRoutes(app); err != nil {
		return fmt.Errorf("failed to register routes: %w", err)
	}

	{{- if .Metrics}}
	// Enable metrics endpoints
	if err := app.EnableMetricsEndpoints(); err != nil {
		return fmt.Errorf("failed to enable metrics endpoints: %w", err)
	}
	{{- end}}

	{{- if .Health}}
	// Enable health endpoints
	if err := app.EnableHealthEndpoints(); err != nil {
		return fmt.Errorf("failed to enable health endpoints: %w", err)
	}
	{{- end}}

	// Start the application
	if err := app.Start(ctx); err != nil {
		return fmt.Errorf("failed to start application: %w", err)
	}

	// Start HTTP server
	addr := fmt.Sprintf("{{.Host | default "localhost"}}:%d", {{.Port | default 8080}})
	if err := app.StartServer(addr); err != nil {
		return fmt.Errorf("failed to start server: %w", err)
	}

	app.Logger().Info("{{.Name}} started successfully", 
		common.LogField{Key: "addr", Value: addr},
		common.LogField{Key: "environment", Value: "{{.Environment | default "development"}}"})

	// Wait for shutdown signal
	<-ctx.Done()

	// Graceful shutdown
	shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer shutdownCancel()

	if err := app.Stop(shutdownCtx); err != nil {
		return fmt.Errorf("failed to stop application gracefully: %w", err)
	}

	app.Logger().Info("{{.Name}} stopped successfully")
	return nil
}

// registerRoutes registers custom application routes
func registerRoutes(app forge.Forge) error {
	// Health check endpoint
	app.GET("/health", func(ctx common.Context) error {
		if err := app.HealthChecker().Check(ctx); err != nil {
			return ctx.JSON(503, map[string]string{
				"status": "unhealthy",
				"error":  err.Error(),
			})
		}

		return ctx.JSON(200, map[string]string{
			"status":  "healthy",
			"service": "{{.Name}}",
			"version": "1.0.0",
		})
	})

	// Info endpoint
	app.GET("/info", func(ctx common.Context) error {
		info := app.GetInfo()
		return ctx.JSON(200, info)
	})

	{{- if .WebSocket}}
	// WebSocket endpoint
	app.WebSocket("/ws", func(ctx common.Context, conn streaming.Connection) error {
		app.Logger().Info("WebSocket connection established",
			common.LogField{Key: "connection_id", Value: conn.ID()})

		// Send welcome message
		welcomeMsg := streaming.Message{
			Type: "welcome",
			Data: map[string]interface{}{
				"service":       "{{.Name}}",
				"connection_id": conn.ID(),
				"timestamp":     time.Now(),
			},
		}

		if err := conn.SendMessage(welcomeMsg); err != nil {
			return err
		}

		// Keep connection alive
		for conn.IsAlive() {
			select {
			case <-ctx.Done():
				return ctx.Err()
			case <-time.After(30 * time.Second):
				// Send ping to keep connection alive
				pingMsg := streaming.Message{
					Type: "ping",
					Data: map[string]interface{}{
						"timestamp": time.Now(),
					},
				}
				if err := conn.SendMessage(pingMsg); err != nil {
					return err
				}
			}
		}

		return nil
	})
	{{- end}}

	{{- if .SSE}}
	// Server-Sent Events endpoint
	app.EventStream("/events", func(ctx common.Context, conn streaming.Connection) error {
		app.Logger().Info("SSE connection established",
			common.LogField{Key: "connection_id", Value: conn.ID()})

		// Send initial event
		initialEvent := streaming.StreamingEvent{
			Type: "connected",
			Data: map[string]interface{}{
				"service":       "{{.Name}}",
				"connection_id": conn.ID(),
				"timestamp":     time.Now(),
			},
		}

		if err := conn.SendEvent(initialEvent); err != nil {
			return err
		}

		// Send periodic updates
		ticker := time.NewTicker(10 * time.Second)
		defer ticker.Stop()

		for conn.IsAlive() {
			select {
			case <-ctx.Done():
				return ctx.Err()
			case <-ticker.C:
				statusEvent := streaming.StreamingEvent{
					Type: "status",
					Data: map[string]interface{}{
						"service":   "{{.Name}}",
						"status":    "running",
						"timestamp": time.Now(),
					},
				}
				if err := conn.SendEvent(statusEvent); err != nil {
					return err
				}
			}
		}

		return nil
	})
	{{- end}}

	// TODO: Add your custom routes here

	return nil
}