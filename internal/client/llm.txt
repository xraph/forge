# Forge Client SDK Generator - Internal Implementation

## Purpose

Automatic client SDK generation from OpenAPI specifications for multiple programming languages. Generates type-safe HTTP clients with authentication, retries, error handling, and streaming support. Enables rapid API integration by eliminating manual client code writing.

## Key Components

- **OpenAPI Parser**: Parse and validate OpenAPI 3.x specifications
- **IR (Intermediate Representation)**: Language-agnostic API model
- **Code Generators**: Language-specific code generation (Go, TypeScript, Python, etc.)
- **Type System**: Map OpenAPI types to target language types
- **Client Templates**: Reusable templates for HTTP clients
- **Authentication**: Support for API keys, OAuth, Bearer tokens
- **Streaming**: WebSocket and SSE client generation

## Architecture

```
Client SDK Generator
├── OpenAPI Parser
│   ├── Spec Validation
│   ├── Schema Resolution
│   └── Reference Resolution
├── IR Builder
│   ├── Endpoint Extraction
│   ├── Type Extraction
│   ├── Operation Grouping
│   └── Authentication Detection
├── Code Generators
│   ├── Go Generator
│   ├── TypeScript Generator
│   ├── Python Generator
│   ├── Java Generator
│   └── Custom Generators
├── Type Mapper
│   ├── Primitive Types
│   ├── Object Types
│   ├── Array Types
│   └── Union Types
└── Templates
    ├── Client Class/Struct
    ├── Request Methods
    ├── Type Definitions
    └── Error Handling
```

## Public API

### Core Types

```go
type Generator interface {
    // Generate SDK from OpenAPI spec
    Generate(spec *OpenAPISpec, opts GenerateOptions) (*GeneratedSDK, error)
    
    // Supported languages
    SupportedLanguages() []string
    
    // Configuration
    Configure(config GeneratorConfig) error
}

type OpenAPISpec struct {
    OpenAPI    string
    Info       Info
    Servers    []Server
    Paths      map[string]PathItem
    Components Components
    Security   []SecurityRequirement
}

type GeneratedSDK struct {
    Language string
    Version  string
    Files    map[string]string  // filename -> content
    Metadata SDKMetadata
}

type GenerateOptions struct {
    Language       string
    OutputDir      string
    PackageName    string
    ClientName     string
    IncludeAuth    bool
    IncludeRetry   bool
    IncludeStreaming bool
}
```

### Main Functions/Methods

```go
// Create generator
func NewGenerator(opts ...GeneratorOption) Generator
func NewGoGenerator() *GoGenerator
func NewTypeScriptGenerator() *TypeScriptGenerator

// Generate SDK
sdk, err := generator.Generate(spec, GenerateOptions{
    Language:    "go",
    OutputDir:   "./client",
    PackageName: "apiclient",
})

// Write to disk
err = sdk.WriteToDisk()

// Parse OpenAPI spec
spec, err := ParseOpenAPISpec(specData)

// Build IR
ir, err := BuildIR(spec)
```

## Usage Examples

### Generate Go Client

```go
import "github.com/xraph/forge/internal/client"

func generateGoClient(specPath string) error {
    // Read OpenAPI spec
    specData, err := os.ReadFile(specPath)
    if err != nil {
        return err
    }
    
    // Parse spec
    spec, err := client.ParseOpenAPISpec(specData)
    if err != nil {
        return err
    }
    
    // Create Go generator
    generator := client.NewGoGenerator(
        client.WithModulePath("github.com/mycompany/api-client"),
        client.WithHTTPClient("net/http"),
    )
    
    // Generate SDK
    sdk, err := generator.Generate(spec, client.GenerateOptions{
        Language:    "go",
        OutputDir:   "./gen/client",
        PackageName: "apiclient",
        ClientName:  "APIClient",
    })
    if err != nil {
        return err
    }
    
    // Write to disk
    return sdk.WriteToDisk()
}
```

### Generated Go Client Usage

```go
// Generated client code
package apiclient

import (
    "context"
    "net/http"
)

type APIClient struct {
    baseURL    string
    httpClient *http.Client
    apiKey     string
}

func NewAPIClient(baseURL, apiKey string) *APIClient {
    return &APIClient{
        baseURL:    baseURL,
        httpClient: &http.Client{},
        apiKey:     apiKey,
    }
}

// Generated method
func (c *APIClient) GetUser(ctx context.Context, userID string) (*User, error) {
    req, err := http.NewRequestWithContext(ctx, "GET", 
        c.baseURL+"/users/"+userID, nil)
    if err != nil {
        return nil, err
    }
    
    req.Header.Set("Authorization", "Bearer "+c.apiKey)
    req.Header.Set("Content-Type", "application/json")
    
    resp, err := c.httpClient.Do(req)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return nil, handleError(resp)
    }
    
    var user User
    if err := json.NewDecoder(resp.Body).Decode(&user); err != nil {
        return nil, err
    }
    
    return &user, nil
}

// Using generated client
client := apiclient.NewAPIClient("https://api.example.com", "api-key")
user, err := client.GetUser(context.Background(), "123")
```

### Generate TypeScript Client

```go
func generateTypeScriptClient(specPath string) error {
    specData, _ := os.ReadFile(specPath)
    spec, _ := client.ParseOpenAPISpec(specData)
    
    generator := client.NewTypeScriptGenerator(
        client.WithNPMPackage("@mycompany/api-client"),
        client.WithAxios(),  // Use axios for HTTP
    )
    
    sdk, err := generator.Generate(spec, client.GenerateOptions{
        Language:    "typescript",
        OutputDir:   "./gen/ts-client",
        PackageName: "api-client",
    })
    if err != nil {
        return err
    }
    
    return sdk.WriteToDisk()
}
```

### Generated TypeScript Client Usage

```typescript
// Generated TypeScript client
import axios, { AxiosInstance } from 'axios';

export class APIClient {
  private axiosInstance: AxiosInstance;

  constructor(baseURL: string, apiKey: string) {
    this.axiosInstance = axios.create({
      baseURL,
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
      },
    });
  }

  async getUser(userID: string): Promise<User> {
    const response = await this.axiosInstance.get<User>(`/users/${userID}`);
    return response.data;
  }

  async createUser(user: CreateUserRequest): Promise<User> {
    const response = await this.axiosInstance.post<User>('/users', user);
    return response.data;
  }
}

// Type definitions
export interface User {
  id: string;
  name: string;
  email: string;
  createdAt: string;
}

export interface CreateUserRequest {
  name: string;
  email: string;
}

// Using generated client
const client = new APIClient('https://api.example.com', 'api-key');
const user = await client.getUser('123');
```

### Custom Generator

```go
// Implement custom language generator
type RustGenerator struct {
    config RustGeneratorConfig
}

func (g *RustGenerator) Generate(spec *OpenAPISpec, opts GenerateOptions) (*GeneratedSDK, error) {
    // Build IR
    ir, err := BuildIR(spec)
    if err != nil {
        return nil, err
    }
    
    sdk := &GeneratedSDK{
        Language: "rust",
        Files:    make(map[string]string),
    }
    
    // Generate Cargo.toml
    sdk.Files["Cargo.toml"] = g.generateCargoToml(opts)
    
    // Generate lib.rs
    sdk.Files["src/lib.rs"] = g.generateLib(ir)
    
    // Generate client module
    sdk.Files["src/client.rs"] = g.generateClient(ir)
    
    // Generate types module
    sdk.Files["src/types.rs"] = g.generateTypes(ir)
    
    return sdk, nil
}

// Register custom generator
client.RegisterGenerator("rust", &RustGenerator{})
```

### Authentication Handling

```go
// Generate client with auth support
generator := client.NewGoGenerator()
sdk, _ := generator.Generate(spec, client.GenerateOptions{
    IncludeAuth: true,
})

// Generated client supports multiple auth methods
client := apiclient.NewAPIClient("https://api.example.com")

// API Key auth
client.WithAPIKey("api-key")

// Bearer token auth
client.WithBearerToken("token")

// OAuth2
client.WithOAuth2(oauth2Config)

// Basic auth
client.WithBasicAuth("username", "password")
```

### Error Handling

```go
// Generated error types
type APIError struct {
    StatusCode int
    Message    string
    Details    map[string]interface{}
}

func (e *APIError) Error() string {
    return fmt.Sprintf("API error %d: %s", e.StatusCode, e.Message)
}

// Error handling in generated client
user, err := client.GetUser(ctx, "123")
if err != nil {
    if apiErr, ok := err.(*apiclient.APIError); ok {
        switch apiErr.StatusCode {
        case 404:
            // Handle not found
        case 429:
            // Handle rate limit
        case 500:
            // Handle server error
        }
    }
    return err
}
```

### Retry Logic

```go
// Generate client with retry support
generator := client.NewGoGenerator()
sdk, _ := generator.Generate(spec, client.GenerateOptions{
    IncludeRetry: true,
})

// Generated client with automatic retries
client := apiclient.NewAPIClient("https://api.example.com",
    apiclient.WithRetry(apiclient.RetryConfig{
        MaxRetries:     3,
        InitialBackoff: 1 * time.Second,
        MaxBackoff:     30 * time.Second,
        RetryOn:        []int{429, 500, 502, 503, 504},
    }),
)

// Automatically retries on transient failures
user, err := client.GetUser(ctx, "123")
```

### Streaming Support

```go
// Generate client with WebSocket support
sdk, _ := generator.Generate(spec, client.GenerateOptions{
    IncludeStreaming: true,
})

// Generated WebSocket client
ws, err := client.ConnectWebSocket(ctx, "/ws/events")
if err != nil {
    return err
}
defer ws.Close()

// Receive messages
for {
    var event Event
    if err := ws.ReadJSON(&event); err != nil {
        break
    }
    handleEvent(event)
}

// Generated SSE client
stream, err := client.StreamEvents(ctx, "/events")
if err != nil {
    return err
}
defer stream.Close()

for event := range stream.Events() {
    handleEvent(event)
}
```

### CLI Integration

```go
// Generate client via CLI
// $ forge client generate --spec openapi.yaml --lang go --out ./client

func generateClientCommand() *cli.Command {
    return &cli.Command{
        Name:  "generate",
        Usage: "Generate client SDK from OpenAPI spec",
        Flags: []cli.Flag{
            &cli.StringFlag{
                Name:     "spec",
                Usage:    "Path to OpenAPI specification",
                Required: true,
            },
            &cli.StringFlag{
                Name:  "lang",
                Usage: "Target language (go, typescript, python, java)",
                Value: "go",
            },
            &cli.StringFlag{
                Name:  "out",
                Usage: "Output directory",
                Value: "./client",
            },
        },
        Action: func(c *cli.Context) error {
            return generateClient(
                c.String("spec"),
                c.String("lang"),
                c.String("out"),
            )
        },
    }
}
```

## Configuration

```yaml
# Client generator configuration
client_generator:
  # Output settings
  output_dir: ./gen/client
  package_name: apiclient
  
  # Features
  include_auth: true
  include_retry: true
  include_streaming: true
  
  # Go-specific
  go:
    module_path: github.com/mycompany/api-client
    http_client: net/http
    
  # TypeScript-specific
  typescript:
    npm_package: "@mycompany/api-client"
    http_client: axios
    
  # Python-specific
  python:
    package_name: mycompany_api_client
    http_client: requests
```

## Dependencies

### External
- encoding/json - JSON parsing
- net/http - HTTP client generation

### Internal
- github.com/xraph/forge/internal/router - OpenAPI spec access

## Common Patterns

### Multi-Language Generation
```go
languages := []string{"go", "typescript", "python", "java"}
for _, lang := range languages {
    generator := client.GetGenerator(lang)
    sdk, _ := generator.Generate(spec, client.GenerateOptions{
        Language:  lang,
        OutputDir: "./gen/" + lang,
    })
    sdk.WriteToDisk()
}
```

### Versioned Clients
```go
// Generate clients for different API versions
for _, version := range []string{"v1", "v2", "v3"} {
    spec, _ := loadSpec("openapi-" + version + ".yaml")
    sdk, _ := generator.Generate(spec, client.GenerateOptions{
        PackageName: "apiclient" + version,
        OutputDir:   "./client/" + version,
    })
    sdk.WriteToDisk()
}
```

## Related Packages

- `/internal/router` - OpenAPI spec source
- `/` - Core Forge framework

## Notes

### Production Readiness
- ✅ Production-ready code generation
- ✅ Type-safe clients
- ✅ Error handling built-in
- ✅ Authentication support
- ✅ Retry logic

### Performance Characteristics
- Generation time: ~1s for typical API
- Generated code: Minimal overhead (<1μs per call)
- Memory efficient

### Security Considerations
- Never embed API keys in generated code
- Use environment variables for secrets
- Validate all inputs
- Sanitize error messages

### Best Practices
1. Generate from validated OpenAPI specs
2. Version generated clients
3. Include authentication
4. Add retry logic for production
5. Generate comprehensive type definitions
6. Include usage documentation
7. Test generated clients
8. Keep generators up to date

### License
MIT License - Part of Forge Framework (internal package)

