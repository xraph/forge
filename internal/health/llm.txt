# Forge Health Check System - Internal Implementation

## Purpose

Comprehensive health monitoring system for Forge applications providing automatic health check discovery, smart aggregation, alerting, persistence, and integration with all Forge components. Monitors application health, dependencies, and external services with intelligent status determination.

## Key Components

- **Health Manager**: Orchestrates health checks with scheduling and reporting
- **Health Checks**: Pluggable health check implementations (database, cache, HTTP, custom)
- **Smart Aggregator**: Intelligent health status aggregation with weights and dependencies
- **Alerting System**: Alert on health status changes with multiple channels
- **Persistence**: Store health history for trend analysis
- **Auto-Discovery**: Automatic discovery of health checkable services
- **HTTP Endpoints**: REST API for health status and detailed reports

## Architecture

```
Health Manager
├── Check Registry
│   ├── Database Checks
│   ├── Cache Checks
│   ├── HTTP Checks
│   ├── Custom Checks
│   └── Auto-Discovered Checks
├── Scheduler
│   ├── Check Execution
│   ├── Interval Management
│   └── Concurrent Execution
├── Smart Aggregator
│   ├── Status Calculation
│   ├── Weight-Based Aggregation
│   ├── Dependency Analysis
│   └── History Tracking
├── Alerting
│   ├── Alert Rules
│   ├── Alert Channels
│   └── Notification Dispatch
├── Persistence
│   ├── History Storage
│   ├── Trend Analysis
│   └── Report Caching
└── HTTP Endpoints
    ├── /_/health (summary)
    ├── /_/health/ready (readiness)
    └── /_/health/live (liveness)
```

## Public API

### Core Types

```go
type HealthManager interface {
    // Check registration
    RegisterCheck(name string, check HealthCheck) error
    UnregisterCheck(name string) error
    
    // Execution
    Check(ctx context.Context, name string) (*HealthResult, error)
    CheckAll(ctx context.Context) (*HealthReport, error)
    
    // Status
    Status() HealthStatus
    Report() *HealthReport
    
    // Subscription
    Subscribe(callback HealthCallback) error
    Unsubscribe(callback HealthCallback) error
    
    // Lifecycle
    Start(ctx context.Context) error
    Stop(ctx context.Context) error
}

type HealthCheck interface {
    Name() string
    Check(ctx context.Context) error
    Metadata() map[string]interface{}
}

type HealthResult struct {
    Name      string
    Status    HealthStatus
    Message   string
    Error     error
    Duration  time.Duration
    Timestamp time.Time
    Metadata  map[string]interface{}
}

type HealthReport struct {
    Status     HealthStatus
    Checks     map[string]*HealthResult
    Timestamp  time.Time
    Uptime     time.Duration
    Version    string
}

type HealthStatus string

const (
    StatusHealthy  HealthStatus = "healthy"
    StatusDegraded HealthStatus = "degraded"
    StatusUnhealthy HealthStatus = "unhealthy"
)
```

### Main Functions/Methods

```go
// Create health manager
func New(config *HealthConfig, logger logger.Logger, metrics Metrics, container Container) HealthManager

// Built-in checks
func NewDatabaseCheck(db *sql.DB, opts ...CheckOption) HealthCheck
func NewCacheCheck(cache Cache, opts ...CheckOption) HealthCheck
func NewHTTPCheck(url string, opts ...CheckOption) HealthCheck
func NewTCPCheck(address string, opts ...CheckOption) HealthCheck

// Custom check
func NewCustomCheck(name string, checkFunc func(context.Context) error) HealthCheck

// Alerting
func NewAlertManager(config AlertConfig) AlertManager
func NewEmailAlerter(config EmailConfig) Alerter
func NewSlackAlerter(config SlackConfig) Alerter
```

## Usage Examples

### Basic Health Checks

```go
import "github.com/xraph/forge/internal/health"

func setupHealthChecks(app *forge.App) {
    healthMgr := app.HealthManager()
    
    // Database health check
    db := di.Must[*sql.DB](app.Container(), "database")
    dbCheck := health.NewDatabaseCheck(db,
        health.WithCheckInterval(30*time.Second),
        health.WithTimeout(5*time.Second),
    )
    healthMgr.RegisterCheck("database", dbCheck)
    
    // Redis health check
    cache := di.Must[*redis.Client](app.Container(), "cache")
    cacheCheck := health.NewCacheCheck(cache,
        health.WithCheckInterval(30*time.Second),
    )
    healthMgr.RegisterCheck("cache", cacheCheck)
    
    // HTTP dependency check
    httpCheck := health.NewHTTPCheck("https://api.example.com/health",
        health.WithCheckInterval(60*time.Second),
        health.WithTimeout(10*time.Second),
    )
    healthMgr.RegisterCheck("external-api", httpCheck)
}
```

### Custom Health Checks

```go
// Custom business logic health check
type OrderQueueCheck struct {
    queue *OrderQueue
}

func (c *OrderQueueCheck) Name() string {
    return "order-queue"
}

func (c *OrderQueueCheck) Check(ctx context.Context) error {
    queueSize := c.queue.Size()
    if queueSize > 10000 {
        return fmt.Errorf("queue size too large: %d", queueSize)
    }
    return nil
}

func (c *OrderQueueCheck) Metadata() map[string]interface{} {
    return map[string]interface{}{
        "queue_size": c.queue.Size(),
        "consumers":  c.queue.ConsumerCount(),
    }
}

// Register custom check
queueCheck := &OrderQueueCheck{queue: orderQueue}
healthMgr.RegisterCheck("order-queue", queueCheck)
```

### Smart Aggregation

```go
// Configure smart aggregation
config := &health.HealthConfig{
    EnableSmartAggregation: true,
    CriticalServices:       []string{"database", "cache"},
    DegradedThreshold:      0.7,  // 70% healthy = degraded
    UnhealthyThreshold:     0.5,  // 50% healthy = unhealthy
    HistorySize:            100,  // Track last 100 checks
}

healthMgr := health.New(config, logger, metrics, container)

// Set service weights (more important = higher weight)
healthMgr.SetWeight("database", 2.0)      // Critical
healthMgr.SetWeight("cache", 1.5)         // Important
healthMgr.SetWeight("external-api", 1.0)  // Normal

// Overall status is weighted average
// If database fails (weight 2.0), overall likely unhealthy
// If external-api fails (weight 1.0), overall may only be degraded
```

### Health Check Endpoints

```go
// Health check endpoints automatically registered
// GET /_/health - Overall health status
// GET /_/health/ready - Readiness probe (Kubernetes)
// GET /_/health/live - Liveness probe (Kubernetes)

// Example response from /_/health
{
  "status": "healthy",
  "timestamp": "2025-01-01T12:00:00Z",
  "uptime": "3h45m",
  "version": "1.0.0",
  "checks": {
    "database": {
      "status": "healthy",
      "message": "Connection successful",
      "duration": "2ms",
      "timestamp": "2025-01-01T12:00:00Z"
    },
    "cache": {
      "status": "healthy",
      "message": "Redis PING successful",
      "duration": "1ms",
      "timestamp": "2025-01-01T12:00:00Z"
    },
    "external-api": {
      "status": "degraded",
      "message": "High latency detected",
      "duration": "250ms",
      "timestamp": "2025-01-01T12:00:00Z"
    }
  }
}
```

### Auto-Discovery

```go
// Health checks are automatically discovered from:
// 1. Services implementing HealthCheckable interface
// 2. Database connections in DI container
// 3. Cache clients in DI container
// 4. Extensions implementing health checks

config := &health.HealthConfig{
    EnableAutoDiscovery: true,
    CheckInterval:       30 * time.Second,
    DefaultTimeout:      5 * time.Second,
}

healthMgr := health.New(config, logger, metrics, container)

// Automatically discovers and registers:
// - database (from "database" in container)
// - cache (from "cache" in container)
// - any service with HealthCheck() method
```

### Alerting

```go
// Configure alerting
alertMgr := health.NewAlertManager(health.AlertConfig{
    Enabled: true,
    Rules: []health.AlertRule{
        {
            Name:      "database-down",
            Condition: health.StatusUnhealthy,
            Services:  []string{"database"},
            Cooldown:  5 * time.Minute,
        },
        {
            Name:      "system-degraded",
            Condition: health.StatusDegraded,
            Threshold: 2, // Alert after 2 consecutive degraded checks
        },
    },
})

// Add alert channels
emailAlerter := health.NewEmailAlerter(health.EmailConfig{
    SMTPHost: "smtp.example.com",
    From:     "alerts@example.com",
    To:       []string{"ops@example.com"},
})
alertMgr.AddAlerter(emailAlerter)

slackAlerter := health.NewSlackAlerter(health.SlackConfig{
    WebhookURL: "https://hooks.slack.com/services/...",
    Channel:    "#alerts",
})
alertMgr.AddAlerter(slackAlerter)

// Attach to health manager
healthMgr.Subscribe(func(report *health.HealthReport) {
    alertMgr.Process(report)
})
```

### Persistence and History

```go
// Configure persistence
persistMgr := health.NewPersistenceManager(health.PersistenceConfig{
    Backend:         "database",
    RetentionPeriod: 30 * 24 * time.Hour, // 30 days
})

healthMgr.Subscribe(func(report *health.HealthReport) {
    if err := persistMgr.Store(report); err != nil {
        log.Printf("Failed to persist health report: %v", err)
    }
})

// Query historical data
history, err := persistMgr.GetHistory("database", 24*time.Hour)
if err != nil {
    return err
}

// Calculate uptime percentage
uptime := calculateUptime(history)
fmt.Printf("Database uptime (24h): %.2f%%\n", uptime*100)
```

### Health Subscriptions

```go
// Subscribe to health status changes
healthMgr.Subscribe(func(report *health.HealthReport) {
    if report.Status == health.StatusUnhealthy {
        log.Printf("CRITICAL: System unhealthy!")
        // Send alerts, trigger failover, etc.
    }
    
    // Log degraded services
    for name, result := range report.Checks {
        if result.Status != health.StatusHealthy {
            log.Printf("Service %s is %s: %s", name, result.Status, result.Message)
        }
    }
})
```

### Readiness vs Liveness

```go
// Readiness: Can the app serve traffic?
// Liveness: Is the app alive (not deadlocked)?

// Readiness check includes:
// - Database connectivity
// - Cache connectivity
// - External dependencies
router.GET("/_/health/ready", func(ctx Context) error {
    report := healthMgr.Report()
    if report.Status == health.StatusUnhealthy {
        return ctx.JSON(503, report)
    }
    return ctx.JSON(200, report)
})

// Liveness check is simpler:
// - Just basic app health (not dependencies)
router.GET("/_/health/live", func(ctx Context) error {
    // Simple check - is process alive?
    return ctx.JSON(200, map[string]string{"status": "alive"})
})
```

## Configuration

```yaml
# health configuration
health:
  check_interval: 30s
  report_interval: 60s
  enable_auto_discovery: true
  max_concurrent_checks: 10
  default_timeout: 5s
  enable_smart_aggregation: true
  history_size: 100
  
  critical_services:
    - database
    - cache
  
  degraded_threshold: 0.7
  unhealthy_threshold: 0.5
```

## Dependencies

### External
- database/sql - Database health checks
- context - Context management

### Internal
- github.com/xraph/forge/internal/logger - Logging
- github.com/xraph/forge/internal/shared - Shared interfaces
- github.com/xraph/forge/errors - Error handling

## Common Patterns

### Gradual Health Degradation
```go
// Track consecutive failures
type SmartHealthCheck struct {
    consecutiveFailures int
    threshold           int
}

func (c *SmartHealthCheck) Check(ctx context.Context) error {
    err := c.actualCheck(ctx)
    if err != nil {
        c.consecutiveFailures++
        if c.consecutiveFailures >= c.threshold {
            return fmt.Errorf("failed %d times: %w", c.consecutiveFailures, err)
        }
        return nil // Grace period
    }
    c.consecutiveFailures = 0
    return nil
}
```

### Circuit Breaker Integration
```go
// Integrate with circuit breaker
healthCheck := health.NewCustomCheck("external-api", func(ctx context.Context) error {
    if circuitBreaker.IsOpen() {
        return fmt.Errorf("circuit breaker open")
    }
    return pingExternalAPI(ctx)
})
```

## Related Packages

- `/` - Core Forge framework using health system
- `/internal/metrics` - Metrics integration
- `/internal/logger` - Logging integration

## Notes

### Production Readiness
- ✅ Production-ready with comprehensive testing
- ✅ Concurrent health check execution
- ✅ Intelligent status aggregation
- ✅ Kubernetes-compatible endpoints
- ✅ Alerting and persistence

### Performance Characteristics
- Health check execution: <10ms (typical)
- Report generation: <1ms
- History query: <10ms (indexed)
- Concurrent checks: 10 (default, configurable)

### Security Considerations
- Expose health endpoints carefully (may leak info)
- Use authentication for detailed health data
- Don't expose sensitive connection strings
- Rate limit health endpoints
- Monitor health check abuse

### Best Practices
1. Check critical dependencies only
2. Use appropriate intervals (don't over-check)
3. Set realistic timeouts
4. Implement both readiness and liveness
5. Use weighted aggregation for critical services
6. Alert on sustained failures, not transient
7. Store health history for trend analysis
8. Test health checks regularly

### License
MIT License - Part of Forge Framework (internal package)

