package cache

import (
	"context"
	"testing"
	"time"

	"github.com/xraph/forge/pkg/logger"
	"github.com/xraph/forge/pkg/metrics"
)

func TestNewManager(t *testing.T) {
	tests := []struct {
		name    string
		config  ManagerConfig
		wantErr bool
	}{
		{
			name: "valid config",
			config: ManagerConfig{
				EnableRedis:       true,
				EnableMemory:      true,
				EnableDistributed: true,
				EnableReplication: true,
				EnableSharding:    true,
				EnableWarming:     true,
				EnableMonitoring:  true,
				DefaultTTL:        1 * time.Hour,
				MaxSize:           1000000,
				RedisURL:          "redis://localhost:6379",
				RedisPassword:     "password",
				RedisDB:           0,
				MemorySize:        100000,
				ShardCount:        16,
				ReplicaCount:      2,
			},
			wantErr: false,
		},
		{
			name: "config with nil logger",
			config: ManagerConfig{
				EnableMemory: true,
				MaxSize:      50000,
			},
			wantErr: false, // Should create default logger
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			manager, err := NewManager(tt.config)
			if (err != nil) != tt.wantErr {
				t.Errorf("NewManager() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !tt.wantErr && manager == nil {
				t.Error("NewManager() returned nil manager")
			}
		})
	}
}

func TestManager_Start(t *testing.T) {
	config := ManagerConfig{
		EnableMemory: true,
		MaxSize:      100000,
		Logger:       logger.NewLogger(logger.LoggingConfig{Level: "info"}),
		Metrics:      metrics.NewMockMetricsCollector(),
	}

	manager, err := NewManager(config)
	if err != nil {
		t.Fatalf("NewManager() error = %v", err)
	}

	ctx := context.Background()

	// Test first start
	err = manager.Start(ctx)
	if err != nil {
		t.Errorf("Start() error = %v", err)
	}

	// Test double start
	err = manager.Start(ctx)
	if err == nil {
		t.Error("Start() should return error on double start")
	}
}

func TestManager_Stop(t *testing.T) {
	config := ManagerConfig{
		EnableMemory: true,
		MaxSize:      100000,
		Logger:       logger.NewLogger(logger.LoggingConfig{Level: "info"}),
		Metrics:      metrics.NewMockMetricsCollector(),
	}

	manager, err := NewManager(config)
	if err != nil {
		t.Fatalf("NewManager() error = %v", err)
	}

	ctx := context.Background()

	// Test stop without start
	err = manager.Stop(ctx)
	if err != nil {
		t.Errorf("Stop() without start should not error, got = %v", err)
	}

	// Test normal stop
	err = manager.Start(ctx)
	if err != nil {
		t.Fatalf("Start() error = %v", err)
	}

	err = manager.Stop(ctx)
	if err != nil {
		t.Errorf("Stop() error = %v", err)
	}
}

func TestManager_HealthCheck(t *testing.T) {
	config := ManagerConfig{
		EnableMemory: true,
		MaxSize:      100000,
		Logger:       logger.NewLogger(logger.LoggingConfig{Level: "info"}),
		Metrics:      metrics.NewMockMetricsCollector(),
	}

	manager, err := NewManager(config)
	if err != nil {
		t.Fatalf("NewManager() error = %v", err)
	}

	ctx := context.Background()

	// Test health check without start
	err = manager.HealthCheck(ctx)
	if err == nil {
		t.Error("HealthCheck() should return error when not started")
	}

	// Test health check after start
	err = manager.Start(ctx)
	if err != nil {
		t.Fatalf("Start() error = %v", err)
	}

	err = manager.HealthCheck(ctx)
	if err != nil {
		t.Errorf("HealthCheck() error = %v", err)
	}
}

func TestManager_GetStats(t *testing.T) {
	config := ManagerConfig{
		EnableRedis:       true,
		EnableMemory:      true,
		EnableDistributed: true,
		EnableReplication: true,
		EnableSharding:    true,
		EnableWarming:     true,
		EnableMonitoring:  true,
		DefaultTTL:        2 * time.Hour,
		MaxSize:           2000000,
		RedisURL:          "redis://localhost:6380",
		RedisPassword:     "secret",
		RedisDB:           1,
		MemorySize:        200000,
		ShardCount:        32,
		ReplicaCount:      3,
		Logger:            logger.NewLogger(logger.LoggingConfig{Level: "info"}),
		Metrics:           metrics.NewMockMetricsCollector(),
	}

	manager, err := NewManager(config)
	if err != nil {
		t.Fatalf("NewManager() error = %v", err)
	}

	stats := manager.GetStats()

	// Check required fields
	requiredFields := []string{
		"started", "redis_enabled", "memory_enabled", "distributed_enabled",
		"replication_enabled", "sharding_enabled", "warming_enabled",
		"monitoring_enabled", "default_ttl", "max_size", "memory_size",
		"shard_count", "replica_count",
	}

	for _, field := range requiredFields {
		if _, exists := stats[field]; !exists {
			t.Errorf("GetStats() missing field: %s", field)
		}
	}

	// Check specific values
	if stats["redis_enabled"] != true {
		t.Error("GetStats() redis_enabled should be true")
	}
	if stats["max_size"] != int64(2000000) {
		t.Error("GetStats() max_size should be 2000000")
	}
	if stats["shard_count"] != 32 {
		t.Error("GetStats() shard_count should be 32")
	}
}

func TestManager_CapabilityMethods(t *testing.T) {
	config := ManagerConfig{
		EnableRedis:       true,
		EnableMemory:      false,
		EnableDistributed: true,
		EnableReplication: false,
		EnableSharding:    true,
		EnableWarming:     false,
		EnableMonitoring:  true,
	}

	manager, err := NewManager(config)
	if err != nil {
		t.Fatalf("NewManager() error = %v", err)
	}

	// Test capability methods
	if !manager.IsRedisEnabled() {
		t.Error("IsRedisEnabled() should return true")
	}
	if manager.IsMemoryEnabled() {
		t.Error("IsMemoryEnabled() should return false")
	}
	if !manager.IsDistributedEnabled() {
		t.Error("IsDistributedEnabled() should return true")
	}
	if manager.IsReplicationEnabled() {
		t.Error("IsReplicationEnabled() should return false")
	}
	if !manager.IsShardingEnabled() {
		t.Error("IsShardingEnabled() should return true")
	}
	if manager.IsWarmingEnabled() {
		t.Error("IsWarmingEnabled() should return false")
	}
	if !manager.IsMonitoringEnabled() {
		t.Error("IsMonitoringEnabled() should return true")
	}
}

func TestManager_ConfigurationMethods(t *testing.T) {
	config := ManagerConfig{
		DefaultTTL:   3 * time.Hour,
		MaxSize:      5000000,
		RedisURL:     "redis://example.com:6379",
		ShardCount:   64,
		ReplicaCount: 5,
	}

	manager, err := NewManager(config)
	if err != nil {
		t.Fatalf("NewManager() error = %v", err)
	}

	// Test configuration getters
	if manager.GetDefaultTTL() != 3*time.Hour {
		t.Error("GetDefaultTTL() should return 3h")
	}
	if manager.GetMaxSize() != 5000000 {
		t.Error("GetMaxSize() should return 5000000")
	}
	if manager.GetRedisURL() != "redis://example.com:6379" {
		t.Error("GetRedisURL() should return redis://example.com:6379")
	}
	if manager.GetShardCount() != 64 {
		t.Error("GetShardCount() should return 64")
	}
	if manager.GetReplicaCount() != 5 {
		t.Error("GetReplicaCount() should return 5")
	}
}

func TestManager_GetConfig(t *testing.T) {
	config := ManagerConfig{
		EnableRedis:   true,
		EnableMemory:  true,
		MaxSize:       1000000,
		DefaultTTL:    1 * time.Hour,
		RedisURL:      "redis://localhost:6379",
		RedisPassword: "password",
		RedisDB:       2,
		MemorySize:    500000,
		ShardCount:    16,
		ReplicaCount:  2,
	}

	manager, err := NewManager(config)
	if err != nil {
		t.Fatalf("NewManager() error = %v", err)
	}

	retrievedConfig := manager.GetConfig()

	if retrievedConfig.EnableRedis != config.EnableRedis {
		t.Error("GetConfig() EnableRedis mismatch")
	}
	if retrievedConfig.EnableMemory != config.EnableMemory {
		t.Error("GetConfig() EnableMemory mismatch")
	}
	if retrievedConfig.MaxSize != config.MaxSize {
		t.Error("GetConfig() MaxSize mismatch")
	}
	if retrievedConfig.DefaultTTL != config.DefaultTTL {
		t.Error("GetConfig() DefaultTTL mismatch")
	}
	if retrievedConfig.RedisURL != config.RedisURL {
		t.Error("GetConfig() RedisURL mismatch")
	}
	if retrievedConfig.RedisPassword != config.RedisPassword {
		t.Error("GetConfig() RedisPassword mismatch")
	}
	if retrievedConfig.RedisDB != config.RedisDB {
		t.Error("GetConfig() RedisDB mismatch")
	}
	if retrievedConfig.MemorySize != config.MemorySize {
		t.Error("GetConfig() MemorySize mismatch")
	}
	if retrievedConfig.ShardCount != config.ShardCount {
		t.Error("GetConfig() ShardCount mismatch")
	}
	if retrievedConfig.ReplicaCount != config.ReplicaCount {
		t.Error("GetConfig() ReplicaCount mismatch")
	}
}

func TestManager_UpdateConfig(t *testing.T) {
	config := ManagerConfig{
		EnableMemory: true,
		MaxSize:      100000,
	}

	manager, err := NewManager(config)
	if err != nil {
		t.Fatalf("NewManager() error = %v", err)
	}

	ctx := context.Background()

	// Test update when not started
	newConfig := ManagerConfig{
		EnableMemory: false,
		MaxSize:      200000,
	}

	err = manager.UpdateConfig(newConfig)
	if err != nil {
		t.Errorf("UpdateConfig() when not started should not error, got = %v", err)
	}

	// Test update when started
	err = manager.Start(ctx)
	if err != nil {
		t.Fatalf("Start() error = %v", err)
	}

	err = manager.UpdateConfig(newConfig)
	if err == nil {
		t.Error("UpdateConfig() when started should return error")
	}
}

func TestManager_ConcurrentAccess(t *testing.T) {
	config := ManagerConfig{
		EnableMemory: true,
		MaxSize:      100000,
		Logger:       logger.NewLogger(logger.LoggingConfig{Level: "info"}),
		Metrics:      metrics.NewMockMetricsCollector(),
	}

	manager, err := NewManager(config)
	if err != nil {
		t.Fatalf("NewManager() error = %v", err)
	}

	ctx := context.Background()

	// Test concurrent access to stats
	done := make(chan bool, 10)
	for i := 0; i < 10; i++ {
		go func() {
			manager.GetStats()
			done <- true
		}()
	}

	// Wait for all goroutines to complete
	for i := 0; i < 10; i++ {
		<-done
	}

	// Test concurrent start/stop
	go func() {
		manager.Start(ctx)
		manager.Stop(ctx)
		done <- true
	}()

	go func() {
		manager.GetStats()
		done <- true
	}()

	<-done
	<-done
}
