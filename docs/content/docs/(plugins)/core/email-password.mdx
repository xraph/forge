---
title: Email & Password Plugin
description: Traditional email and password authentication with advanced security features
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Tab, Tabs } from 'fumadocs-ui/components/tabs'
import { Card, Cards } from 'fumadocs-ui/components/card'

The Email & Password plugin provides traditional email and password authentication with modern security features including password policies, email verification, account lockout protection, and secure password hashing.

## Features

- **Secure Password Hashing**: bcrypt and Argon2 support
- **Email Verification**: Optional email verification workflow
- **Password Policies**: Configurable complexity requirements
- **Account Security**: Lockout protection and rate limiting
- **Password Reset**: Secure password reset via email
- **Password Change**: Authenticated password updates
- **Audit Logging**: Complete authentication event tracking

## Installation

The Email & Password plugin is included in the core AuthSome package:

```go
import "github.com/xraph/authsome/plugins/emailpassword"
```

## Configuration

<Tabs items={['YAML Configuration', 'Environment Variables', 'Programmatic']}>
  <Tab value="YAML Configuration">
    ```yaml
    auth:
      plugins:
        emailPassword:
          enabled: true
          
          # Email verification settings
          requireEmailVerification: true
          emailVerificationExpiry: "24h"
          resendCooldown: "1m"
          
          # Password policy
          passwordPolicy:
            minLength: 8
            maxLength: 128
            requireUpper: true
            requireLower: true
            requireNumbers: true
            requireSymbols: false
            forbiddenPasswords: ["password", "123456", "qwerty"]
            
          # Password hashing
          passwordHashing:
            algorithm: "bcrypt"  # or "argon2"
            bcryptCost: 12
            argon2:
              memory: 65536
              iterations: 3
              parallelism: 2
              saltLength: 16
              keyLength: 32
              
          # Account security
          accountSecurity:
            maxLoginAttempts: 5
            lockoutDuration: "15m"
            lockoutIncrement: true  # Exponential backoff
            
          # Password reset
          passwordReset:
            enabled: true
            tokenExpiry: "1h"
            maxAttempts: 3
            cooldown: "5m"
            
          # Session settings
          session:
            duration: "7d"
            renewThreshold: "1d"
            singleSession: false
    ```
  </Tab>
  <Tab value="Environment Variables">
    ```bash
    # Basic settings
    AUTH_PLUGINS_EMAIL_PASSWORD_ENABLED=true
    AUTH_PLUGINS_EMAIL_PASSWORD_REQUIRE_EMAIL_VERIFICATION=true
    AUTH_PLUGINS_EMAIL_PASSWORD_EMAIL_VERIFICATION_EXPIRY=24h

    # Password policy
    AUTH_PLUGINS_EMAIL_PASSWORD_PASSWORD_POLICY_MIN_LENGTH=8
    AUTH_PLUGINS_EMAIL_PASSWORD_PASSWORD_POLICY_REQUIRE_UPPER=true
    AUTH_PLUGINS_EMAIL_PASSWORD_PASSWORD_POLICY_REQUIRE_LOWER=true
    AUTH_PLUGINS_EMAIL_PASSWORD_PASSWORD_POLICY_REQUIRE_NUMBERS=true

    # Password hashing
    AUTH_PLUGINS_EMAIL_PASSWORD_PASSWORD_HASHING_ALGORITHM=bcrypt
    AUTH_PLUGINS_EMAIL_PASSWORD_PASSWORD_HASHING_BCRYPT_COST=12

    # Account security
    AUTH_PLUGINS_EMAIL_PASSWORD_ACCOUNT_SECURITY_MAX_LOGIN_ATTEMPTS=5
    AUTH_PLUGINS_EMAIL_PASSWORD_ACCOUNT_SECURITY_LOCKOUT_DURATION=15m

    # Password reset
    AUTH_PLUGINS_EMAIL_PASSWORD_PASSWORD_RESET_ENABLED=true
    AUTH_PLUGINS_EMAIL_PASSWORD_PASSWORD_RESET_TOKEN_EXPIRY=1h
    ```
  </Tab>
  <Tab value="Programmatic">
    ```go
    config := &emailpassword.Config{
        Enabled:                  true,
        RequireEmailVerification: true,
        EmailVerificationExpiry:  24 * time.Hour,
        ResendCooldown:          time.Minute,
        
        PasswordPolicy: emailpassword.PasswordPolicy{
            MinLength:      8,
            MaxLength:      128,
            RequireUpper:   true,
            RequireLower:   true,
            RequireNumbers: true,
            RequireSymbols: false,
            ForbiddenPasswords: []string{
                "password", "123456", "qwerty",
            },
        },
        
        PasswordHashing: emailpassword.PasswordHashing{
            Algorithm:  "bcrypt",
            BcryptCost: 12,
            Argon2: emailpassword.Argon2Config{
                Memory:      65536,
                Iterations:  3,
                Parallelism: 2,
                SaltLength:  16,
                KeyLength:   32,
            },
        },
        
        AccountSecurity: emailpassword.AccountSecurity{
            MaxLoginAttempts: 5,
            LockoutDuration:  15 * time.Minute,
            LockoutIncrement: true,
        },
        
        PasswordReset: emailpassword.PasswordReset{
            Enabled:      true,
            TokenExpiry:  time.Hour,
            MaxAttempts:  3,
            Cooldown:     5 * time.Minute,
        },
        
        Session: emailpassword.SessionConfig{
            Duration:       7 * 24 * time.Hour,
            RenewThreshold: 24 * time.Hour,
            SingleSession:  false,
        },
    }
    ```
  </Tab>
</Tabs>

## Plugin Registration

Register the Email & Password plugin with your AuthSome instance:

```go
package main

import (
    "log"
    
    "github.com/xraph/authsome"
    "github.com/xraph/authsome/plugins/emailpassword"
    "github.com/xraph/forge"
)

func main() {
    // Create AuthSome instance with configuration
    auth, err := authsome.New(config)
    if err != nil {
        log.Fatal(err)
    }

    // Register Email & Password plugin
    emailPasswordPlugin := emailpassword.NewPlugin()
    auth.RegisterPlugin(emailPasswordPlugin)

    // Initialize plugins
    if err := auth.InitializePlugins(); err != nil {
        log.Fatal(err)
    }

    // Create Forge app and mount AuthSome
    app := forge.New()
    auth.Mount(app, "/auth")

    log.Println("Server starting on :8080")
    app.Listen(":8080")
}
```

## API Endpoints

The Email & Password plugin provides the following endpoints:

### User Registration

```http
POST /auth/signup
Content-Type: application/json

{
  "email": "user@example.com",
  "password": "SecurePassword123!",
  "firstName": "John",
  "lastName": "Doe"
}
```

**Response:**
```json
{
  "success": true,
  "user": {
    "id": "user_123",
    "email": "user@example.com",
    "firstName": "John",
    "lastName": "Doe",
    "emailVerified": false,
    "createdAt": "2024-01-15T10:30:00Z"
  },
  "session": {
    "id": "session_456",
    "expiresAt": "2024-01-22T10:30:00Z"
  },
  "message": "Registration successful. Please check your email for verification."
}
```

### User Sign In

```http
POST /auth/signin
Content-Type: application/json

{
  "email": "user@example.com",
  "password": "SecurePassword123!"
}
```

**Response:**
```json
{
  "success": true,
  "user": {
    "id": "user_123",
    "email": "user@example.com",
    "firstName": "John",
    "lastName": "Doe",
    "emailVerified": true,
    "lastSignIn": "2024-01-15T10:30:00Z"
  },
  "session": {
    "id": "session_789",
    "expiresAt": "2024-01-22T10:30:00Z"
  }
}
```

### Email Verification

```http
POST /auth/email/verify
Content-Type: application/json

{
  "token": "verification_token_here"
}
```

### Resend Verification Email

```http
POST /auth/email/resend
Content-Type: application/json

{
  "email": "user@example.com"
}
```

### Password Reset Request

```http
POST /auth/password/reset
Content-Type: application/json

{
  "email": "user@example.com"
}
```

### Password Reset Confirmation

```http
POST /auth/password/confirm
Content-Type: application/json

{
  "token": "reset_token_here",
  "newPassword": "NewSecurePassword123!"
}
```

### Password Change (Authenticated)

```http
POST /auth/password/change
Content-Type: application/json
Authorization: Bearer session_token

{
  "currentPassword": "SecurePassword123!",
  "newPassword": "NewSecurePassword123!"
}
```

### Sign Out

```http
POST /auth/signout
Authorization: Bearer session_token
```

## Frontend Integration

### JavaScript/TypeScript

```typescript
interface AuthResponse {
  success: boolean;
  user?: User;
  session?: Session;
  message?: string;
  error?: string;
}

interface User {
  id: string;
  email: string;
  firstName?: string;
  lastName?: string;
  emailVerified: boolean;
  createdAt: string;
  lastSignIn?: string;
}

interface Session {
  id: string;
  expiresAt: string;
}

class AuthService {
  private baseUrl: string;

  constructor(baseUrl: string = '/auth') {
    this.baseUrl = baseUrl;
  }

  async signUp(email: string, password: string, firstName?: string, lastName?: string): Promise<AuthResponse> {
    const response = await fetch(`${this.baseUrl}/signup`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        email,
        password,
        firstName,
        lastName,
      }),
    });

    return response.json();
  }

  async signIn(email: string, password: string): Promise<AuthResponse> {
    const response = await fetch(`${this.baseUrl}/signin`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ email, password }),
    });

    return response.json();
  }

  async signOut(): Promise<void> {
    await fetch(`${this.baseUrl}/signout`, {
      method: 'POST',
    });
  }

  async verifyEmail(token: string): Promise<AuthResponse> {
    const response = await fetch(`${this.baseUrl}/email/verify`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ token }),
    });

    return response.json();
  }

  async resendVerificationEmail(email: string): Promise<AuthResponse> {
    const response = await fetch(`${this.baseUrl}/email/resend`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ email }),
    });

    return response.json();
  }

  async requestPasswordReset(email: string): Promise<AuthResponse> {
    const response = await fetch(`${this.baseUrl}/password/reset`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ email }),
    });

    return response.json();
  }

  async confirmPasswordReset(token: string, newPassword: string): Promise<AuthResponse> {
    const response = await fetch(`${this.baseUrl}/password/confirm`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ token, newPassword }),
    });

    return response.json();
  }

  async changePassword(currentPassword: string, newPassword: string): Promise<AuthResponse> {
    const response = await fetch(`${this.baseUrl}/password/change`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ currentPassword, newPassword }),
    });

    return response.json();
  }
}

// Usage
const auth = new AuthService();

// Sign up
try {
  const result = await auth.signUp(
    'user@example.com',
    'SecurePassword123!',
    'John',
    'Doe'
  );
  
  if (result.success) {
    console.log('User registered:', result.user);
    if (!result.user?.emailVerified) {
      console.log('Please check your email for verification');
    }
  } else {
    console.error('Registration failed:', result.error);
  }
} catch (error) {
  console.error('Network error:', error);
}

// Sign in
try {
  const result = await auth.signIn('user@example.com', 'SecurePassword123!');
  
  if (result.success) {
    console.log('User signed in:', result.user);
    // Store session or redirect user
  } else {
    console.error('Sign in failed:', result.error);
  }
} catch (error) {
  console.error('Network error:', error);
}
```

### React Hook

```jsx
import { useState, useCallback, useContext, createContext } from 'react';

const AuthContext = createContext();

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const authService = new AuthService();

  const signUp = useCallback(async (email, password, firstName, lastName) => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await authService.signUp(email, password, firstName, lastName);
      
      if (result.success) {
        setUser(result.user);
        return result;
      } else {
        setError(result.error);
        throw new Error(result.error);
      }
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  const signIn = useCallback(async (email, password) => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await authService.signIn(email, password);
      
      if (result.success) {
        setUser(result.user);
        return result;
      } else {
        setError(result.error);
        throw new Error(result.error);
      }
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  const signOut = useCallback(async () => {
    setLoading(true);
    
    try {
      await authService.signOut();
      setUser(null);
    } catch (err) {
      setError(err.message);
    } finally {
      setLoading(false);
    }
  }, []);

  const verifyEmail = useCallback(async (token) => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await authService.verifyEmail(token);
      
      if (result.success) {
        setUser(result.user);
        return result;
      } else {
        setError(result.error);
        throw new Error(result.error);
      }
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  const changePassword = useCallback(async (currentPassword, newPassword) => {
    setLoading(true);
    setError(null);
    
    try {
      const result = await authService.changePassword(currentPassword, newPassword);
      
      if (result.success) {
        return result;
      } else {
        setError(result.error);
        throw new Error(result.error);
      }
    } catch (err) {
      setError(err.message);
      throw err;
    } finally {
      setLoading(false);
    }
  }, []);

  const value = {
    user,
    loading,
    error,
    signUp,
    signIn,
    signOut,
    verifyEmail,
    changePassword,
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
}

// Usage in components
function SignUpForm() {
  const { signUp, loading, error } = useAuth();
  const [formData, setFormData] = useState({
    email: '',
    password: '',
    firstName: '',
    lastName: '',
  });

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      await signUp(
        formData.email,
        formData.password,
        formData.firstName,
        formData.lastName
      );
      // Handle success (redirect, show message, etc.)
    } catch (err) {
      // Error is handled by the hook
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="email"
        value={formData.email}
        onChange={(e) => setFormData({ ...formData, email: e.target.value })}
        placeholder="Email"
        required
      />
      <input
        type="password"
        value={formData.password}
        onChange={(e) => setFormData({ ...formData, password: e.target.value })}
        placeholder="Password"
        required
      />
      <input
        type="text"
        value={formData.firstName}
        onChange={(e) => setFormData({ ...formData, firstName: e.target.value })}
        placeholder="First Name"
      />
      <input
        type="text"
        value={formData.lastName}
        onChange={(e) => setFormData({ ...formData, lastName: e.target.value })}
        placeholder="Last Name"
      />
      <button type="submit" disabled={loading}>
        {loading ? 'Creating Account...' : 'Sign Up'}
      </button>
      {error && <div className="error">{error}</div>}
    </form>
  );
}
```

## Server-Side Integration

### Middleware Protection

```go
package main

import (
    "net/http"
    
    "github.com/xraph/authsome"
    "github.com/xraph/forge"
)

func main() {
    app := forge.New()
    auth, _ := authsome.New(config)
    
    // Mount AuthSome
    auth.Mount(app, "/auth")
    
    // Protected routes
    protected := app.Group("/api")
    protected.Use(auth.RequireAuth()) // Require authentication
    
    protected.GET("/profile", func(c *forge.Context) error {
        // Get current user from context
        user := auth.GetUser(c)
        return c.JSON(http.StatusOK, user)
    })
    
    protected.POST("/posts", func(c *forge.Context) error {
        user := auth.GetUser(c)
        
        // Create post for authenticated user
        post := &Post{
            UserID:  user.ID,
            Title:   c.FormValue("title"),
            Content: c.FormValue("content"),
        }
        
        // Save post...
        
        return c.JSON(http.StatusCreated, post)
    })
    
    app.Listen(":8080")
}
```

### Custom Validation

```go
package main

import (
    "context"
    "fmt"
    
    "github.com/xraph/authsome"
    "github.com/xraph/authsome/plugins/emailpassword"
)

func main() {
    auth, _ := authsome.New(config)
    
    // Register custom password validator
    auth.RegisterHook("emailpassword.before_signup", func(ctx context.Context, data map[string]interface{}) error {
        password := data["password"].(string)
        
        // Custom validation logic
        if containsUserInfo(password, data["email"].(string), data["firstName"].(string)) {
            return fmt.Errorf("password cannot contain personal information")
        }
        
        if isCommonPassword(password) {
            return fmt.Errorf("password is too common, please choose a stronger password")
        }
        
        return nil
    })
    
    // Register email validation hook
    auth.RegisterHook("emailpassword.before_signup", func(ctx context.Context, data map[string]interface{}) error {
        email := data["email"].(string)
        
        // Check if email domain is allowed
        if !isAllowedEmailDomain(email) {
            return fmt.Errorf("email domain not allowed")
        }
        
        return nil
    })
}

func containsUserInfo(password, email, firstName string) bool {
    // Implementation to check if password contains user info
    return false
}

func isCommonPassword(password string) bool {
    // Implementation to check against common passwords
    return false
}

func isAllowedEmailDomain(email string) bool {
    // Implementation to check allowed domains
    return true
}
```

## Security Best Practices

<Callout type="warn">
**Security Recommendations**: Always use HTTPS in production, implement proper rate limiting, validate all inputs, and regularly update password policies based on security requirements.
</Callout>

### Password Security

1. **Strong Hashing**: Use bcrypt with cost 12+ or Argon2
2. **Password Policies**: Enforce minimum complexity requirements
3. **Forbidden Passwords**: Block common/leaked passwords
4. **Regular Updates**: Encourage periodic password changes

### Account Protection

1. **Rate Limiting**: Limit login attempts per IP/user
2. **Account Lockout**: Temporary lockout after failed attempts
3. **Email Verification**: Verify email ownership
4. **Audit Logging**: Log all authentication events

### Session Security

1. **Secure Cookies**: Use HttpOnly, Secure, SameSite flags
2. **Session Rotation**: Rotate session tokens on login
3. **Proper Expiry**: Set reasonable session durations
4. **Cleanup**: Remove expired sessions regularly

## Error Handling

The plugin provides detailed error responses for different scenarios:

```json
{
  "success": false,
  "error": "INVALID_CREDENTIALS",
  "message": "Invalid email or password",
  "details": {
    "field": "password",
    "code": "INVALID_CREDENTIALS"
  }
}
```

Common error codes:
- `INVALID_CREDENTIALS`: Wrong email/password
- `EMAIL_NOT_VERIFIED`: Email verification required
- `ACCOUNT_LOCKED`: Account temporarily locked
- `PASSWORD_TOO_WEAK`: Password doesn't meet policy
- `EMAIL_ALREADY_EXISTS`: Email already registered
- `RATE_LIMITED`: Too many requests

## Troubleshooting

<Tabs items={['Common Issues', 'Configuration Problems', 'Performance Issues']}>
  <Tab value="Common Issues">
    ### Email Verification Not Working
    
    **Problem**: Users not receiving verification emails
    
    **Solutions**:
    1. Check email provider configuration
    2. Verify SMTP settings
    3. Check spam/junk folders
    4. Ensure email templates are configured
    
    ### Password Reset Failing
    
    **Problem**: Password reset tokens not working
    
    **Solutions**:
    1. Check token expiry settings
    2. Verify email delivery
    3. Ensure database is storing tokens correctly
    4. Check for clock synchronization issues
    
    ### Account Lockout Issues
    
    **Problem**: Users getting locked out unexpectedly
    
    **Solutions**:
    1. Review lockout thresholds
    2. Check for automated attacks
    3. Implement IP-based rate limiting
    4. Consider exponential backoff
  </Tab>
  <Tab value="Configuration Problems">
    ### Plugin Not Loading
    
    **Problem**: Email & Password plugin not initializing
    
    **Solutions**:
    ```go
    // Ensure proper plugin registration
    auth.RegisterPlugin(emailpassword.NewPlugin())
    
    // Check for configuration errors
    if err := auth.InitializePlugins(); err != nil {
        log.Printf("Plugin initialization failed: %v", err)
    }
    ```
    
    ### Database Migration Issues
    
    **Problem**: Database tables not created
    
    **Solutions**:
    ```go
    // Run migrations explicitly
    if err := auth.RunMigrations(); err != nil {
        log.Printf("Migration failed: %v", err)
    }
    ```
    
    ### Configuration Binding Errors
    
    **Problem**: Configuration not loading properly
    
    **Solutions**:
    ```go
    // Validate configuration
    config := &emailpassword.Config{}
    if err := forgeConfig.Bind("auth.plugins.emailPassword", config); err != nil {
        log.Printf("Config binding failed: %v", err)
    }
    ```
  </Tab>
  <Tab value="Performance Issues">
    ### Slow Password Hashing
    
    **Problem**: Login/signup taking too long
    
    **Solutions**:
    1. Adjust bcrypt cost (balance security vs performance)
    2. Consider Argon2 for better performance
    3. Use background processing for non-critical operations
    
    ### Database Performance
    
    **Problem**: Slow authentication queries
    
    **Solutions**:
    1. Add database indexes on email fields
    2. Optimize session storage
    3. Use connection pooling
    4. Consider read replicas for session validation
    
    ### Memory Usage
    
    **Problem**: High memory consumption
    
    **Solutions**:
    1. Implement session cleanup
    2. Use Redis for session storage
    3. Optimize password hashing parameters
    4. Monitor goroutine leaks
  </Tab>
</Tabs>

## Next Steps

<Cards>
  <Card
    title="Two-Factor Authentication"
    description="Add TOTP and SMS-based 2FA for enhanced security"
    href="/docs/go/plugins/core/two-factor"
  />
  <Card
    title="Username Authentication"
    description="Enable username-based login alongside email"
    href="/docs/go/plugins/core/username"
  />
  <Card
    title="Session Management"
    description="Learn about session configuration and management"
    href="/docs/go/concepts/sessions"
  />
  <Card
    title="Security Best Practices"
    description="Comprehensive security guidelines"
    href="/docs/go/concepts/security"
  />
</Cards>