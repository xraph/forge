---
title: Extension Migration Guide
description: Step-by-step guide to migrate extensions to constructor injection pattern
---

# Extension Migration Guide

This guide shows how to migrate existing extensions to use the new constructor injection pattern.

## Overview

The migration process typically involves:

1. **Switch to BaseExtension** - Use `forge.BaseExtension` instead of custom fields
2. **Create Service wrapper** - Extract lifecycle logic into a service
3. **Use RegisterConstructor** - Register services via constructors
4. **Simplify Extension lifecycle** - Remove manual Start/Stop logic

## Step-by-Step Migration

### Step 1: Update Extension Structure

**Before:**

```go
type Extension struct {
    config  Config
    service *MyService
    logger  forge.Logger
    metrics forge.Metrics
    app     forge.App
}

func NewExtension() *Extension {
    return &Extension{
        config: DefaultConfig(),
    }
}

func (e *Extension) Name() string    { return "myext" }
func (e *Extension) Version() string { return "1.0.0" }
func (e *Extension) Description() string { return "My extension" }
func (e *Extension) Dependencies() []string { return nil }
```

**After:**

```go
type Extension struct {
    *forge.BaseExtension
    config Config
    // Remove: service, logger, metrics, app fields
}

func NewExtension(opts ...ConfigOption) forge.Extension {
    config := DefaultConfig()
    for _, opt := range opts {
        opt(&config)
    }
    
    base := forge.NewBaseExtension("myext", "1.0.0", "My extension")
    
    return &Extension{
        BaseExtension: base,
        config:        config,
    }
}

// Name(), Version(), Description(), Dependencies() inherited from BaseExtension
```

### Step 2: Create Service Wrapper

Create a new `service.go` file that wraps your service with lifecycle methods:

```go
// service.go
package myext

import (
    "context"
    "github.com/xraph/forge"
)

// MyService implements di.Service for lifecycle management
type MyService struct {
    config  Config
    backend Backend
    logger  forge.Logger
    metrics forge.Metrics
}

// Constructor
func NewMyService(config Config, logger forge.Logger, metrics forge.Metrics) (*MyService, error) {
    backend := NewBackend(config)
    return &MyService{
        config:  config,
        backend: backend,
        logger:  logger,
        metrics: metrics,
    }, nil
}

// di.Service interface
func (s *MyService) Name() string {
    return "my-service"
}

func (s *MyService) Start(ctx context.Context) error {
    s.logger.Info("starting my service")
    return s.backend.Connect(ctx)
}

func (s *MyService) Stop(ctx context.Context) error {
    s.logger.Info("stopping my service")
    return s.backend.Disconnect(ctx)
}

func (s *MyService) Health(ctx context.Context) error {
    return s.backend.Ping(ctx)
}
```

### Step 3: Update Register Method

**Before:**

```go
func (e *Extension) Register(app forge.App) error {
    e.app = app
    
    // Get logger
    if l, err := forge.GetLogger(app.Container()); err == nil {
        e.logger = l
    }
    
    // Get metrics
    if m, err := forge.GetMetrics(app.Container()); err == nil {
        e.metrics = m
    }
    
    // Load config
    e.config = e.loadConfig()
    
    // Create service
    e.service = NewMyService(e.config, e.logger, e.metrics)
    
    // Register with DI
    return forge.RegisterSingleton(app.Container(), "myService", func(c forge.Container) (*MyService, error) {
        return e.service, nil
    })
}
```

**After:**

```go
func (e *Extension) Register(app forge.App) error {
    // Call base registration (sets logger, metrics, app)
    if err := e.BaseExtension.Register(app); err != nil {
        return err
    }
    
    // Load config
    cfg := e.loadConfig()
    e.config = cfg
    
    // Register service constructor - config captured in closure
    if err := e.RegisterConstructor(func(logger forge.Logger, metrics forge.Metrics) (*MyService, error) {
        return NewMyService(cfg, logger, metrics)
    }); err != nil {
        return fmt.Errorf("failed to register service: %w", err)
    }
    
    // Register by name for backward compatibility
    if err := forge.RegisterSingleton(app.Container(), "myService", func(c forge.Container) (*MyService, error) {
        return forge.InjectType[*MyService](c)
    }); err != nil {
        return err
    }
    
    e.Logger().Info("extension registered")
    return nil
}
```

### Step 4: Simplify Start/Stop

**Before:**

```go
func (e *Extension) Start(ctx context.Context) error {
    e.logger.Info("starting extension")
    
    if err := e.service.Connect(ctx); err != nil {
        return fmt.Errorf("failed to start service: %w", err)
    }
    
    e.logger.Info("extension started")
    return nil
}

func (e *Extension) Stop(ctx context.Context) error {
    e.logger.Info("stopping extension")
    
    if e.service != nil {
        if err := e.service.Disconnect(ctx); err != nil {
            e.logger.Error("failed to stop service", forge.F("error", err))
        }
    }
    
    e.logger.Info("extension stopped")
    return nil
}

func (e *Extension) Health(ctx context.Context) error {
    if e.service == nil {
        return fmt.Errorf("service not initialized")
    }
    return e.service.Ping(ctx)
}
```

**After:**

```go
func (e *Extension) Start(ctx context.Context) error {
    e.MarkStarted()
    return nil  // Service started by Vessel
}

func (e *Extension) Stop(ctx context.Context) error {
    e.MarkStopped()
    return nil  // Service stopped by Vessel
}

func (e *Extension) Health(ctx context.Context) error {
    return nil  // Service health managed by Vessel
}
```

## Common Scenarios

### Scenario 1: Extension with Multiple Services

**Before:**

```go
type Extension struct {
    manager *Manager
    worker  *Worker
    monitor *Monitor
}

func (e *Extension) Register(app forge.App) error {
    e.manager = NewManager(e.config)
    e.worker = NewWorker(e.config, e.manager)
    e.monitor = NewMonitor(e.config, e.manager)
    
    // Register all...
}

func (e *Extension) Start(ctx context.Context) error {
    e.manager.Start(ctx)
    e.worker.Start(ctx)
    e.monitor.Start(ctx)
    return nil
}
```

**After:**

```go
func (e *Extension) Register(app forge.App) error {
    e.BaseExtension.Register(app)
    cfg := e.loadConfig()
    
    // Register all constructors - dependencies auto-resolved
    return e.RegisterConstructors(
        func(logger forge.Logger) (*Manager, error) {
            return NewManager(cfg, logger), nil
        },
        func(mgr *Manager, logger forge.Logger) (*Worker, error) {
            return NewWorker(cfg, mgr, logger), nil
        },
        func(mgr *Manager, logger forge.Logger) (*Monitor, error) {
            return NewMonitor(cfg, mgr, logger), nil
        },
    )
}

func (e *Extension) Start(ctx context.Context) error {
    e.MarkStarted()
    return nil  // All services started by Vessel
}
```

### Scenario 2: Extension with Dependencies

**Before:**

```go
func (e *Extension) Register(app forge.App) error {
    // Manually resolve database
    db, err := forge.Resolve[*database.Database](app.Container(), "database")
    if err != nil {
        return err
    }
    
    e.service = NewMyService(e.config, db)
    // ...
}
```

**After:**

```go
func (e *Extension) Register(app forge.App) error {
    e.BaseExtension.Register(app)
    cfg := e.loadConfig()
    
    // Database automatically resolved by type!
    return e.RegisterConstructor(func(db *database.DatabaseManager, logger forge.Logger) (*MyService, error) {
        return NewMyService(cfg, db, logger), nil
    })
}

func (e *Extension) Dependencies() []string {
    return []string{"database"}  // Ensure database starts first
}
```

### Scenario 3: Optional Dependencies

**Before:**

```go
func (e *Extension) Register(app forge.App) error {
    var cache Cache
    if c, err := forge.Resolve[Cache](app.Container(), "cache"); err == nil {
        cache = c
    }
    
    e.service = NewMyService(e.config, cache)
    // ...
}
```

**After:**

```go
func (e *Extension) Register(app forge.App) error {
    e.BaseExtension.Register(app)
    cfg := e.loadConfig()
    
    // Use vessel.In struct for optional dependencies
    return e.RegisterConstructor(func(deps struct {
        vessel.In
        Logger forge.Logger
        Cache  *cache.CacheService `optional:"true"`
    }) (*MyService, error) {
        return NewMyService(cfg, deps.Cache, deps.Logger), nil
    })
}
```

## Migration Checklist

Use this checklist when migrating an extension:

- [ ] Switch to `forge.BaseExtension`
- [ ] Remove `logger`, `metrics`, `app` fields
- [ ] Create service wrapper with `di.Service` interface
- [ ] Update `NewExtension()` to use `BaseExtension`
- [ ] Remove Name/Version/Description methods (inherited)
- [ ] Update `Register()` to:
  - [ ] Call `e.BaseExtension.Register(app)`
  - [ ] Load config once
  - [ ] Use `e.RegisterConstructor()` or `e.RegisterConstructors()`
  - [ ] Register backward-compatible string keys
- [ ] Simplify `Start()` - just call `e.MarkStarted()`
- [ ] Simplify `Stop()` - just call `e.MarkStopped()`
- [ ] Simplify `Health()` - return nil or check service
- [ ] Remove service instance storage
- [ ] Update tests to resolve services by type
- [ ] Update documentation

## Testing After Migration

### Test Service Resolution

```go
func TestServiceResolution(t *testing.T) {
    app := forge.NewApp(forge.DefaultAppConfig())
    app.RegisterExtension(myext.NewExtension())
    
    ctx := context.Background()
    require.NoError(t, app.Start(ctx))
    defer app.Stop(ctx)
    
    // Resolve by type
    service, err := forge.InjectType[*myext.MyService](app.Container())
    require.NoError(t, err)
    require.NotNil(t, service)
}
```

### Test Service Lifecycle

```go
func TestServiceLifecycle(t *testing.T) {
    app := forge.NewApp(forge.DefaultAppConfig())
    app.RegisterExtension(myext.NewExtension())
    
    ctx := context.Background()
    
    // Start should trigger service Start()
    require.NoError(t, app.Start(ctx))
    
    // Service should be healthy
    service, _ := forge.InjectType[*myext.MyService](app.Container())
    require.NoError(t, service.Health(ctx))
    
    // Stop should trigger service Stop()
    require.NoError(t, app.Stop(ctx))
}
```

## Common Issues

### Issue: Service Not Starting

**Problem:** Service Start() not being called.

**Solution:** Ensure service implements `di.Service` interface:

```go
func (s *MyService) Name() string { return "my-service" }
func (s *MyService) Start(ctx context.Context) error { /* ... */ }
func (s *MyService) Stop(ctx context.Context) error { /* ... */ }
```

### Issue: Dependencies Not Resolved

**Problem:** Dependencies showing as nil.

**Solution:** Check dependency order and types:

```go
// Ensure dependencies are registered first
func (e *Extension) Dependencies() []string {
    return []string{"database", "cache"}
}

// Ensure types match exactly
func(db *database.DatabaseManager) (*MyService, error) {
    // db type must match exactly what's registered
}
```

### Issue: Config Not Captured

**Problem:** Config changes not reflected in service.

**Solution:** Ensure config is loaded BEFORE registering constructor:

```go
func (e *Extension) Register(app forge.App) error {
    e.BaseExtension.Register(app)
    
    cfg := e.loadConfig()  // Load first
    e.config = cfg
    
    // Config captured in closure
    return e.RegisterConstructor(func(logger forge.Logger) (*MyService, error) {
        return NewMyService(cfg, logger), nil  // Use cfg, not e.config
    })
}
```

## Benefits After Migration

After migration, your extension will have:

- ✅ Cleaner, more maintainable code
- ✅ Type-safe dependency injection
- ✅ Automatic lifecycle management
- ✅ Better testability
- ✅ Reduced boilerplate
- ✅ Consistent patterns across codebase

## Need Help?

- Check [Constructor Injection Pattern](/docs/extensions/constructor-injection) docs
- Review [example extensions](https://github.com/xraph/forge/tree/main/extensions)
- Open an issue on [GitHub](https://github.com/xraph/forge/issues)
