---
title: "Search Extension"
description: "Full-text search capabilities with multiple backends including Elasticsearch, Meilisearch, Typesense, and in-memory search"
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Tabs, TabsContent, TabsList, TabsTrigger } from 'fumadocs-ui/components/tabs'
import { Card, Cards } from 'fumadocs-ui/components/card'

# Search Extension

The Search extension provides powerful full-text search capabilities with support for multiple search backends including Elasticsearch, Meilisearch, Typesense, and an in-memory search engine for development and testing.

## Key Features

- **Multiple Backends**: Support for Elasticsearch, Meilisearch, Typesense, and in-memory search
- **Unified Interface**: Consistent API across all search backends
- **Advanced Search**: Full-text search, filtering, sorting, faceting, and highlighting
- **Schema Management**: Flexible index schema definition with field types and analyzers
- **Suggestions & Autocomplete**: Built-in support for search suggestions and autocomplete
- **Performance**: Connection pooling, bulk operations, and compression support
- **Security**: TLS encryption, authentication, and API key support
- **Monitoring**: Built-in metrics, tracing, and health checks
- **Testing**: Comprehensive testing utilities and mock implementations

## Installation

<Tabs defaultValue="go-module" className="w-full">
<TabsList>
  <TabsTrigger value="go-module">Go Module</TabsTrigger>
  <TabsTrigger value="docker">Docker</TabsTrigger>
  <TabsTrigger value="binary">Binary</TabsTrigger>
</TabsList>

<TabsContent value="go-module">
```bash
go get github.com/xraph/forge/v2/extensions/search
```
</TabsContent>

<TabsContent value="docker">
```bash
# Elasticsearch
docker run -d --name elasticsearch \
  -p 9200:9200 \
  -e "discovery.type=single-node" \
  elasticsearch:8.11.0

# Meilisearch
docker run -d --name meilisearch \
  -p 7700:7700 \
  getmeili/meilisearch:v1.5

# Typesense
docker run -d --name typesense \
  -p 8108:8108 \
  -e TYPESENSE_API_KEY=xyz \
  typesense/typesense:0.25.2
```
</TabsContent>

<TabsContent value="binary">
```bash
# Download from releases
curl -L https://github.com/xraph/forge/releases/latest/download/forge-search-linux-amd64.tar.gz | tar xz
sudo mv forge-search /usr/local/bin/
```
</TabsContent>
</Tabs>

## Basic Usage

### Simple Search Setup

```go
package main

import (
    "context"
    "log"
    
    "github.com/xraph/forge/v2"
    "github.com/xraph/forge/v2/extensions/search"
)

func main() {
    // Create app
    app := forge.NewApp(forge.DefaultAppConfig())
    
    // Add search extension
    app.AddExtension(search.NewExtension(
        search.WithDriver("inmemory"), // For development
    ))
    
    // Start app
    if err := app.Start(context.Background()); err != nil {
        log.Fatal(err)
    }
    defer app.Stop(context.Background())
    
    // Get search service
    searchService, err := forge.Resolve[search.Search](app.Container(), "search")
    if err != nil {
        log.Fatal(err)
    }
    
    // Create index
    schema := search.IndexSchema{
        Fields: []search.FieldSchema{
            {
                Name:       "title",
                Type:       "text",
                Searchable: true,
                Stored:     true,
            },
            {
                Name:       "content",
                Type:       "text",
                Searchable: true,
                Stored:     true,
            },
            {
                Name:       "category",
                Type:       "keyword",
                Filterable: true,
                Faceted:    true,
                Stored:     true,
            },
        },
    }
    
    ctx := context.Background()
    if err := searchService.CreateIndex(ctx, "articles", schema); err != nil {
        log.Fatal(err)
    }
    
    // Index documents
    doc := search.Document{
        ID: "1",
        Fields: map[string]interface{}{
            "title":    "Getting Started with Forge",
            "content":  "Learn how to build applications with Forge framework",
            "category": "tutorial",
        },
    }
    
    if err := searchService.Index(ctx, "articles", doc); err != nil {
        log.Fatal(err)
    }
    
    // Search
    query := search.SearchQuery{
        Index: "articles",
        Query: "forge framework",
        Limit: 10,
    }
    
    results, err := searchService.Search(ctx, query)
    if err != nil {
        log.Fatal(err)
    }
    
    log.Printf("Found %d results", results.Total)
    for _, hit := range results.Hits {
        log.Printf("Document %s: %v", hit.ID, hit.Document)
    }
}
```

### Elasticsearch Backend

```go
package main

import (
    "context"
    "log"
    
    "github.com/xraph/forge/v2"
    "github.com/xraph/forge/v2/extensions/search"
)

func main() {
    app := forge.NewApp(forge.DefaultAppConfig())
    
    // Configure Elasticsearch
    app.AddExtension(search.NewExtension(
        search.WithDriver("elasticsearch"),
        search.WithURL("http://localhost:9200"),
        search.WithAuth("elastic", "password"),
        search.WithMaxConnections(20),
        search.WithTimeout(30*time.Second),
    ))
    
    if err := app.Start(context.Background()); err != nil {
        log.Fatal(err)
    }
    defer app.Stop(context.Background())
    
    searchService, _ := forge.Resolve[search.Search](app.Container(), "search")
    
    // Advanced schema with analyzers
    schema := search.IndexSchema{
        Fields: []search.FieldSchema{
            {
                Name:       "title",
                Type:       "text",
                Searchable: true,
                Stored:     true,
                Boost:      2.0,
                Analyzer:   "standard",
            },
            {
                Name:       "content",
                Type:       "text",
                Searchable: true,
                Stored:     true,
                Analyzer:   "english",
            },
            {
                Name:       "tags",
                Type:       "keyword",
                Filterable: true,
                Faceted:    true,
                Stored:     true,
            },
            {
                Name:       "published_at",
                Type:       "date",
                Sortable:   true,
                Filterable: true,
                Format:     "2006-01-02T15:04:05Z",
            },
        },
        Analyzers: map[string]search.Analyzer{
            "english": {
                Type:      "standard",
                Tokenizer: "standard",
                Filters:   []string{"lowercase", "stop", "stemmer"},
            },
        },
        StopWords: []string{"the", "a", "an", "and", "or", "but"},
        Synonyms: []search.Synonym{
            {Terms: []string{"quick", "fast", "rapid"}},
            {Terms: []string{"big", "large", "huge"}},
        },
    }
    
    ctx := context.Background()
    if err := searchService.CreateIndex(ctx, "documents", schema); err != nil {
        log.Fatal(err)
    }
    
    // Bulk indexing
    docs := []search.Document{
        {
            ID: "1",
            Fields: map[string]interface{}{
                "title":        "Fast Search with Elasticsearch",
                "content":      "Learn how to implement rapid search functionality",
                "tags":         []string{"search", "elasticsearch", "performance"},
                "published_at": "2024-01-15T10:00:00Z",
            },
        },
        {
            ID: "2",
            Fields: map[string]interface{}{
                "title":        "Big Data Processing",
                "content":      "Handle large datasets efficiently",
                "tags":         []string{"bigdata", "processing", "performance"},
                "published_at": "2024-01-16T14:30:00Z",
            },
        },
    }
    
    if err := searchService.BulkIndex(ctx, "documents", docs); err != nil {
        log.Fatal(err)
    }
    
    log.Println("Documents indexed successfully")
}
```

### Meilisearch Backend

```go
package main

import (
    "context"
    "log"
    
    "github.com/xraph/forge/v2"
    "github.com/xraph/forge/v2/extensions/search"
)

func main() {
    app := forge.NewApp(forge.DefaultAppConfig())
    
    // Configure Meilisearch
    app.AddExtension(search.NewExtension(
        search.WithDriver("meilisearch"),
        search.WithURL("http://localhost:7700"),
        search.WithAPIKey("masterKey"),
    ))
    
    if err := app.Start(context.Background()); err != nil {
        log.Fatal(err)
    }
    defer app.Stop(context.Background())
    
    searchService, _ := forge.Resolve[search.Search](app.Container(), "search")
    
    // Meilisearch-optimized schema
    schema := search.IndexSchema{
        Fields: []search.FieldSchema{
            {
                Name:       "title",
                Type:       "text",
                Searchable: true,
                Stored:     true,
            },
            {
                Name:       "description",
                Type:       "text",
                Searchable: true,
                Stored:     true,
            },
            {
                Name:       "category",
                Type:       "keyword",
                Filterable: true,
                Faceted:    true,
                Stored:     true,
            },
            {
                Name:       "price",
                Type:       "float",
                Sortable:   true,
                Filterable: true,
                Stored:     true,
            },
        },
        Ranking: &search.RankingConfig{
            Rules: []string{"words", "typo", "proximity", "attribute", "sort", "exactness"},
            Weights: map[string]float64{
                "title":       1.0,
                "description": 0.8,
            },
        },
        Faceting: &search.FacetingConfig{
            MaxValues: 100,
            Sort:      "count",
        },
    }
    
    ctx := context.Background()
    if err := searchService.CreateIndex(ctx, "products", schema); err != nil {
        log.Fatal(err)
    }
    
    log.Println("Meilisearch index created successfully")
}
```

### Typesense Backend

```go
package main

import (
    "context"
    "log"
    
    "github.com/xraph/forge/v2"
    "github.com/xraph/forge/v2/extensions/search"
)

func main() {
    app := forge.NewApp(forge.DefaultAppConfig())
    
    // Configure Typesense
    app.AddExtension(search.NewExtension(
        search.WithDriver("typesense"),
        search.WithHosts("localhost:8108"),
        search.WithAPIKey("xyz"),
    ))
    
    if err := app.Start(context.Background()); err != nil {
        log.Fatal(err)
    }
    defer app.Stop(context.Background())
    
    searchService, _ := forge.Resolve[search.Search](app.Container(), "search")
    
    // Typesense schema with geo-search
    schema := search.IndexSchema{
        Fields: []search.FieldSchema{
            {
                Name:       "name",
                Type:       "text",
                Searchable: true,
                Stored:     true,
            },
            {
                Name:       "description",
                Type:       "text",
                Searchable: true,
                Stored:     true,
            },
            {
                Name:       "location",
                Type:       "geo_point",
                Stored:     true,
            },
            {
                Name:       "rating",
                Type:       "float",
                Sortable:   true,
                Filterable: true,
                Stored:     true,
            },
        },
    }
    
    ctx := context.Background()
    if err := searchService.CreateIndex(ctx, "places", schema); err != nil {
        log.Fatal(err)
    }
    
    // Index location data
    doc := search.Document{
        ID: "1",
        Fields: map[string]interface{}{
            "name":        "Central Park",
            "description": "Large public park in Manhattan",
            "location":    []float64{40.785091, -73.968285}, // [lat, lng]
            "rating":      4.5,
        },
    }
    
    if err := searchService.Index(ctx, "places", doc); err != nil {
        log.Fatal(err)
    }
    
    log.Println("Typesense document indexed successfully")
}
```

## Configuration

### YAML Configuration

```yaml
# config.yaml
extensions:
  search:
    # Driver selection
    driver: "elasticsearch" # inmemory, elasticsearch, meilisearch, typesense
    
    # Connection settings
    url: "http://localhost:9200"
    hosts:
      - "localhost:9200"
      - "localhost:9201"
    username: "elastic"
    password: "password"
    api_key: "your-api-key"
    
    # Connection pool
    max_connections: 20
    max_idle_connections: 10
    connect_timeout: "10s"
    request_timeout: "30s"
    keep_alive: "60s"
    
    # Retry policy
    max_retries: 3
    retry_backoff: "100ms"
    retry_on_timeout: true
    
    # Default search settings
    default_limit: 20
    max_limit: 100
    default_min_score: 0.0
    enable_highlight: true
    enable_facets: true
    
    # Performance
    bulk_size: 100
    flush_interval: "5s"
    enable_compression: true
    
    # Security
    enable_tls: true
    tls_cert_file: "/path/to/cert.pem"
    tls_key_file: "/path/to/key.pem"
    tls_ca_file: "/path/to/ca.pem"
    insecure_skip_verify: false
    
    # Monitoring
    enable_metrics: true
    enable_tracing: true
```

### Environment Variables

```bash
# Driver
FORGE_SEARCH_DRIVER=elasticsearch

# Connection
FORGE_SEARCH_URL=http://localhost:9200
FORGE_SEARCH_USERNAME=elastic
FORGE_SEARCH_PASSWORD=password
FORGE_SEARCH_API_KEY=your-api-key

# Pool settings
FORGE_SEARCH_MAX_CONNECTIONS=20
FORGE_SEARCH_MAX_IDLE_CONNECTIONS=10
FORGE_SEARCH_CONNECT_TIMEOUT=10s
FORGE_SEARCH_REQUEST_TIMEOUT=30s

# Performance
FORGE_SEARCH_BULK_SIZE=100
FORGE_SEARCH_ENABLE_COMPRESSION=true

# Security
FORGE_SEARCH_ENABLE_TLS=true
FORGE_SEARCH_TLS_CERT_FILE=/path/to/cert.pem
FORGE_SEARCH_TLS_KEY_FILE=/path/to/key.pem

# Monitoring
FORGE_SEARCH_ENABLE_METRICS=true
FORGE_SEARCH_ENABLE_TRACING=true
```

### Functional Options

```go
package main

import (
    "time"
    
    "github.com/xraph/forge/v2/extensions/search"
)

func main() {
    // Basic configuration
    ext := search.NewExtension(
        search.WithDriver("elasticsearch"),
        search.WithURL("http://localhost:9200"),
        search.WithAuth("elastic", "password"),
    )
    
    // Advanced configuration
    ext = search.NewExtension(
        search.WithDriver("elasticsearch"),
        search.WithHosts("node1:9200", "node2:9200", "node3:9200"),
        search.WithAuth("elastic", "password"),
        search.WithMaxConnections(50),
        search.WithTimeout(60*time.Second),
        search.WithDefaultLimit(25),
        search.WithMaxLimit(500),
        search.WithTLS("/path/to/cert.pem", "/path/to/key.pem", "/path/to/ca.pem"),
        search.WithMetrics(true),
        search.WithTracing(true),
    )
    
    // Meilisearch configuration
    ext = search.NewExtension(
        search.WithDriver("meilisearch"),
        search.WithURL("http://localhost:7700"),
        search.WithAPIKey("masterKey"),
    )
    
    // Typesense configuration
    ext = search.NewExtension(
        search.WithDriver("typesense"),
        search.WithHosts("localhost:8108"),
        search.WithAPIKey("xyz"),
    )
    
    // In-memory for testing
    ext = search.NewExtension(
        search.WithDriver("inmemory"),
    )
}
```

## Search Manager Interface

### Core Interface

```go
// Search represents a unified search interface
type Search interface {
    // Connection management
    Connect(ctx context.Context) error
    Disconnect(ctx context.Context) error
    Ping(ctx context.Context) error

    // Index management
    CreateIndex(ctx context.Context, name string, schema IndexSchema) error
    DeleteIndex(ctx context.Context, name string) error
    ListIndexes(ctx context.Context) ([]string, error)
    GetIndexInfo(ctx context.Context, name string) (*IndexInfo, error)

    // Document operations
    Index(ctx context.Context, index string, doc Document) error
    BulkIndex(ctx context.Context, index string, docs []Document) error
    Get(ctx context.Context, index string, id string) (*Document, error)
    Delete(ctx context.Context, index string, id string) error
    Update(ctx context.Context, index string, id string, doc Document) error

    // Search operations
    Search(ctx context.Context, query SearchQuery) (*SearchResults, error)
    Suggest(ctx context.Context, query SuggestQuery) (*SuggestResults, error)
    Autocomplete(ctx context.Context, query AutocompleteQuery) (*AutocompleteResults, error)

    // Analytics
    Stats(ctx context.Context) (*SearchStats, error)
}
```

### Data Structures

```go
// Document represents a search document
type Document struct {
    ID     string                 `json:"id"`
    Fields map[string]interface{} `json:"fields"`
}

// IndexSchema defines the structure of an index
type IndexSchema struct {
    Fields       []FieldSchema          `json:"fields"`
    Settings     map[string]interface{} `json:"settings,omitempty"`
    Synonyms     []Synonym              `json:"synonyms,omitempty"`
    StopWords    []string               `json:"stop_words,omitempty"`
    Analyzers    map[string]Analyzer    `json:"analyzers,omitempty"`
    Ranking      *RankingConfig         `json:"ranking,omitempty"`
    Faceting     *FacetingConfig        `json:"faceting,omitempty"`
    Highlighting *HighlightConfig       `json:"highlighting,omitempty"`
}

// FieldSchema defines a field in the index
type FieldSchema struct {
    Name         string      `json:"name"`
    Type         string      `json:"type"` // text, keyword, integer, float, boolean, date, geo_point
    Required     bool        `json:"required"`
    Searchable   bool        `json:"searchable"`
    Filterable   bool        `json:"filterable"`
    Sortable     bool        `json:"sortable"`
    Faceted      bool        `json:"faceted"`
    Stored       bool        `json:"stored"`
    Index        bool        `json:"index"`
    Boost        float64     `json:"boost,omitempty"`
    Analyzer     string      `json:"analyzer,omitempty"`
    Format       string      `json:"format,omitempty"` // For dates
    Locale       string      `json:"locale,omitempty"`
    DefaultValue interface{} `json:"default_value,omitempty"`
}

// SearchQuery represents a search request
type SearchQuery struct {
    Index           string                 `json:"index"`
    Query           string                 `json:"query"`
    Filters         []Filter               `json:"filters,omitempty"`
    Sort            []SortField            `json:"sort,omitempty"`
    Facets          []string               `json:"facets,omitempty"`
    Offset          int                    `json:"offset,omitempty"`
    Limit           int                    `json:"limit,omitempty"`
    Highlight       bool                   `json:"highlight,omitempty"`
    HighlightFields []string               `json:"highlight_fields,omitempty"`
    Fields          []string               `json:"fields,omitempty"`
    MinScore        float64                `json:"min_score,omitempty"`
    BoostFields     map[string]float64     `json:"boost_fields,omitempty"`
    FuzzyLevel      int                    `json:"fuzzy_level,omitempty"` // 0=exact, 1-2=fuzzy
    Options         map[string]interface{} `json:"options,omitempty"`
}

// SearchResults contains search response
type SearchResults struct {
    Hits           []Hit              `json:"hits"`
    Total          int64              `json:"total"`
    Offset         int                `json:"offset"`
    Limit          int                `json:"limit"`
    ProcessingTime time.Duration      `json:"processing_time_ms"`
    Facets         map[string][]Facet `json:"facets,omitempty"`
    Query          string             `json:"query"`
    Exhaustive     bool               `json:"exhaustive"`
}
```

## Advanced Features

### Complex Search Queries

```go
package main

import (
    "context"
    "log"
    
    "github.com/xraph/forge/v2/extensions/search"
)

func advancedSearch(searchService search.Search) {
    ctx := context.Background()
    
    // Complex search with filters, sorting, and facets
    query := search.SearchQuery{
        Index: "products",
        Query: "smartphone camera",
        Filters: []search.Filter{
            {
                Field:    "category",
                Operator: "=",
                Value:    "electronics",
            },
            {
                Field:    "price",
                Operator: "BETWEEN",
                Value:    []float64{100, 1000},
            },
            {
                Field:    "in_stock",
                Operator: "=",
                Value:    true,
            },
        },
        Sort: []search.SortField{
            {Field: "rating", Order: "desc"},
            {Field: "price", Order: "asc"},
        },
        Facets: []string{"brand", "color", "storage"},
        Offset: 0,
        Limit: 20,
        Highlight: true,
        HighlightFields: []string{"title", "description"},
        BoostFields: map[string]float64{
            "title": 2.0,
            "brand": 1.5,
        },
        FuzzyLevel: 1,
        MinScore: 0.5,
    }
    
    results, err := searchService.Search(ctx, query)
    if err != nil {
        log.Fatal(err)
    }
    
    log.Printf("Found %d results in %v", results.Total, results.ProcessingTime)
    
    // Process results
    for _, hit := range results.Hits {
        log.Printf("Product %s (score: %.2f)", hit.ID, hit.Score)
        log.Printf("Title: %s", hit.Document["title"])
        
        // Process highlights
        if highlights, ok := hit.Highlights["title"]; ok {
            log.Printf("Highlighted title: %v", highlights)
        }
    }
    
    // Process facets
    for facetName, facetValues := range results.Facets {
        log.Printf("Facet %s:", facetName)
        for _, facet := range facetValues {
            log.Printf("  %s: %d", facet.Value, facet.Count)
        }
    }
}
```

### Suggestions and Autocomplete

```go
package main

import (
    "context"
    "log"
    
    "github.com/xraph/forge/v2/extensions/search"
)

func searchSuggestions(searchService search.Search) {
    ctx := context.Background()
    
    // Get search suggestions
    suggestQuery := search.SuggestQuery{
        Index: "products",
        Query: "smartph",
        Field: "title",
        Limit: 5,
        Fuzzy: true,
    }
    
    suggestions, err := searchService.Suggest(ctx, suggestQuery)
    if err != nil {
        log.Fatal(err)
    }
    
    log.Printf("Suggestions for 'smartph':")
    for _, suggestion := range suggestions.Suggestions {
        log.Printf("  %s (score: %.2f)", suggestion.Text, suggestion.Score)
    }
    
    // Get autocomplete results
    autocompleteQuery := search.AutocompleteQuery{
        Index: "products",
        Query: "iph",
        Field: "title",
        Limit: 10,
    }
    
    completions, err := searchService.Autocomplete(ctx, autocompleteQuery)
    if err != nil {
        log.Fatal(err)
    }
    
    log.Printf("Autocomplete for 'iph':")
    for _, completion := range completions.Completions {
        log.Printf("  %s (score: %.2f)", completion.Text, completion.Score)
    }
}
```

### Bulk Operations

```go
package main

import (
    "context"
    "log"
    
    "github.com/xraph/forge/v2/extensions/search"
)

func bulkOperations(searchService search.Search) {
    ctx := context.Background()
    
    // Prepare bulk documents
    docs := make([]search.Document, 1000)
    for i := 0; i < 1000; i++ {
        docs[i] = search.Document{
            ID: fmt.Sprintf("doc_%d", i),
            Fields: map[string]interface{}{
                "title":       fmt.Sprintf("Document %d", i),
                "content":     fmt.Sprintf("This is the content of document %d", i),
                "category":    []string{"category1", "category2"}[i%2],
                "created_at":  time.Now().Add(-time.Duration(i)*time.Hour),
                "view_count":  rand.Intn(1000),
                "published":   i%3 == 0,
            },
        }
    }
    
    // Bulk index documents
    start := time.Now()
    if err := searchService.BulkIndex(ctx, "documents", docs); err != nil {
        log.Fatal(err)
    }
    
    log.Printf("Bulk indexed %d documents in %v", len(docs), time.Since(start))
    
    // Get index statistics
    stats, err := searchService.Stats(ctx)
    if err != nil {
        log.Fatal(err)
    }
    
    log.Printf("Index stats:")
    log.Printf("  Indexes: %d", stats.IndexCount)
    log.Printf("  Documents: %d", stats.DocumentCount)
    log.Printf("  Total size: %d bytes", stats.TotalSize)
    log.Printf("  Queries: %d", stats.Queries)
    log.Printf("  Avg latency: %v", stats.AvgLatency)
    log.Printf("  Uptime: %v", stats.Uptime)
}
```

### Index Management

```go
package main

import (
    "context"
    "log"
    
    "github.com/xraph/forge/v2/extensions/search"
)

func indexManagement(searchService search.Search) {
    ctx := context.Background()
    
    // Create index with advanced schema
    schema := search.IndexSchema{
        Fields: []search.FieldSchema{
            {
                Name:       "title",
                Type:       "text",
                Searchable: true,
                Stored:     true,
                Boost:      2.0,
                Analyzer:   "english",
            },
            {
                Name:       "content",
                Type:       "text",
                Searchable: true,
                Stored:     true,
                Analyzer:   "english",
            },
            {
                Name:       "tags",
                Type:       "keyword",
                Filterable: true,
                Faceted:    true,
                Stored:     true,
            },
            {
                Name:       "published_at",
                Type:       "date",
                Sortable:   true,
                Filterable: true,
                Format:     "2006-01-02T15:04:05Z",
            },
            {
                Name:       "location",
                Type:       "geo_point",
                Stored:     true,
            },
        },
        Settings: map[string]interface{}{
            "number_of_shards":   3,
            "number_of_replicas": 1,
        },
        Analyzers: map[string]search.Analyzer{
            "english": {
                Type:      "standard",
                Tokenizer: "standard",
                Filters:   []string{"lowercase", "stop", "stemmer"},
            },
        },
        StopWords: []string{"the", "a", "an", "and", "or", "but"},
        Synonyms: []search.Synonym{
            {Terms: []string{"quick", "fast", "rapid"}},
            {Terms: []string{"big", "large", "huge"}},
        },
        Ranking: &search.RankingConfig{
            Rules: []string{"words", "typo", "proximity", "attribute", "sort", "exactness"},
            Weights: map[string]float64{
                "title":   1.0,
                "content": 0.8,
            },
        },
        Faceting: &search.FacetingConfig{
            MaxValues: 100,
            Sort:      "count",
        },
        Highlighting: &search.HighlightConfig{
            PreTag:  "<mark>",
            PostTag: "</mark>",
        },
    }
    
    if err := searchService.CreateIndex(ctx, "advanced_docs", schema); err != nil {
        log.Fatal(err)
    }
    
    // List all indexes
    indexes, err := searchService.ListIndexes(ctx)
    if err != nil {
        log.Fatal(err)
    }
    
    log.Printf("Available indexes: %v", indexes)
    
    // Get index information
    for _, indexName := range indexes {
        info, err := searchService.GetIndexInfo(ctx, indexName)
        if err != nil {
            log.Printf("Failed to get info for index %s: %v", indexName, err)
            continue
        }
        
        log.Printf("Index %s:", indexName)
        log.Printf("  Documents: %d", info.DocumentCount)
        log.Printf("  Size: %d bytes", info.IndexSize)
        log.Printf("  Created: %v", info.CreatedAt)
        log.Printf("  Updated: %v", info.UpdatedAt)
        log.Printf("  Fields: %d", len(info.Schema.Fields))
    }
}
```

## Testing Utilities

### Unit Tests

```go
package main

import (
    "context"
    "testing"
    
    "github.com/xraph/forge/v2"
    "github.com/xraph/forge/v2/extensions/search"
)

func TestSearchExtension(t *testing.T) {
    // Create test app
    app := forge.NewApp(forge.DefaultAppConfig())
    
    // Add search extension with in-memory driver
    app.AddExtension(search.NewExtension(
        search.WithDriver("inmemory"),
    ))
    
    // Start app
    ctx := context.Background()
    if err := app.Start(ctx); err != nil {
        t.Fatalf("Failed to start app: %v", err)
    }
    defer app.Stop(ctx)
    
    // Get search service
    searchService, err := forge.Resolve[search.Search](app.Container(), "search")
    if err != nil {
        t.Fatalf("Failed to resolve search service: %v", err)
    }
    
    // Test index creation
    schema := search.IndexSchema{
        Fields: []search.FieldSchema{
            {
                Name:       "title",
                Type:       "text",
                Searchable: true,
                Stored:     true,
            },
        },
    }
    
    if err := searchService.CreateIndex(ctx, "test_index", schema); err != nil {
        t.Fatalf("Failed to create index: %v", err)
    }
    
    // Test document indexing
    doc := search.Document{
        ID: "1",
        Fields: map[string]interface{}{
            "title": "Test Document",
        },
    }
    
    if err := searchService.Index(ctx, "test_index", doc); err != nil {
        t.Fatalf("Failed to index document: %v", err)
    }
    
    // Test search
    query := search.SearchQuery{
        Index: "test_index",
        Query: "test",
        Limit: 10,
    }
    
    results, err := searchService.Search(ctx, query)
    if err != nil {
        t.Fatalf("Failed to search: %v", err)
    }
    
    if results.Total != 1 {
        t.Errorf("Expected 1 result, got %d", results.Total)
    }
    
    if len(results.Hits) != 1 {
        t.Errorf("Expected 1 hit, got %d", len(results.Hits))
    }
    
    if results.Hits[0].ID != "1" {
        t.Errorf("Expected hit ID '1', got '%s'", results.Hits[0].ID)
    }
}

func TestSearchWithFilters(t *testing.T) {
    app := forge.NewApp(forge.DefaultAppConfig())
    app.AddExtension(search.NewExtension(search.WithDriver("inmemory")))
    
    ctx := context.Background()
    if err := app.Start(ctx); err != nil {
        t.Fatalf("Failed to start app: %v", err)
    }
    defer app.Stop(ctx)
    
    searchService, _ := forge.Resolve[search.Search](app.Container(), "search")
    
    // Create index
    schema := search.IndexSchema{
        Fields: []search.FieldSchema{
            {Name: "title", Type: "text", Searchable: true, Stored: true},
            {Name: "category", Type: "keyword", Filterable: true, Stored: true},
            {Name: "price", Type: "float", Filterable: true, Stored: true},
        },
    }
    
    if err := searchService.CreateIndex(ctx, "products", schema); err != nil {
        t.Fatalf("Failed to create index: %v", err)
    }
    
    // Index test documents
    docs := []search.Document{
        {
            ID: "1",
            Fields: map[string]interface{}{
                "title":    "Laptop",
                "category": "electronics",
                "price":    999.99,
            },
        },
        {
            ID: "2",
            Fields: map[string]interface{}{
                "title":    "Book",
                "category": "books",
                "price":    19.99,
            },
        },
    }
    
    if err := searchService.BulkIndex(ctx, "products", docs); err != nil {
        t.Fatalf("Failed to bulk index: %v", err)
    }
    
    // Test filtered search
    query := search.SearchQuery{
        Index: "products",
        Query: "*",
        Filters: []search.Filter{
            {Field: "category", Operator: "=", Value: "electronics"},
            {Field: "price", Operator: ">", Value: 500.0},
        },
        Limit: 10,
    }
    
    results, err := searchService.Search(ctx, query)
    if err != nil {
        t.Fatalf("Failed to search with filters: %v", err)
    }
    
    if results.Total != 1 {
        t.Errorf("Expected 1 filtered result, got %d", results.Total)
    }
    
    if results.Hits[0].ID != "1" {
        t.Errorf("Expected laptop result, got ID '%s'", results.Hits[0].ID)
    }
}
```

### Integration Tests

```go
package main

import (
    "context"
    "testing"
    "time"
    
    "github.com/testcontainers/testcontainers-go"
    "github.com/testcontainers/testcontainers-go/wait"
    
    "github.com/xraph/forge/v2"
    "github.com/xraph/forge/v2/extensions/search"
)

func TestElasticsearchIntegration(t *testing.T) {
    if testing.Short() {
        t.Skip("Skipping integration test in short mode")
    }
    
    ctx := context.Background()
    
    // Start Elasticsearch container
    req := testcontainers.ContainerRequest{
        Image:        "elasticsearch:8.11.0",
        ExposedPorts: []string{"9200/tcp"},
        Env: map[string]string{
            "discovery.type":         "single-node",
            "xpack.security.enabled": "false",
        },
        WaitingFor: wait.ForHTTP("/").WithPort("9200/tcp").WithStartupTimeout(60 * time.Second),
    }
    
    container, err := testcontainers.GenericContainer(ctx, testcontainers.GenericContainerRequest{
        ContainerRequest: req,
        Started:          true,
    })
    if err != nil {
        t.Fatalf("Failed to start Elasticsearch container: %v", err)
    }
    defer container.Terminate(ctx)
    
    // Get container endpoint
    endpoint, err := container.Endpoint(ctx, "")
    if err != nil {
        t.Fatalf("Failed to get container endpoint: %v", err)
    }
    
    // Create app with Elasticsearch
    app := forge.NewApp(forge.DefaultAppConfig())
    app.AddExtension(search.NewExtension(
        search.WithDriver("elasticsearch"),
        search.WithURL("http://"+endpoint),
    ))
    
    if err := app.Start(ctx); err != nil {
        t.Fatalf("Failed to start app: %v", err)
    }
    defer app.Stop(ctx)
    
    searchService, _ := forge.Resolve[search.Search](app.Container(), "search")
    
    // Test health check
    if err := searchService.Ping(ctx); err != nil {
        t.Fatalf("Elasticsearch health check failed: %v", err)
    }
    
    // Run search tests
    runSearchTests(t, searchService)
}

func runSearchTests(t *testing.T, searchService search.Search) {
    ctx := context.Background()
    
    // Create test index
    schema := search.IndexSchema{
        Fields: []search.FieldSchema{
            {Name: "title", Type: "text", Searchable: true, Stored: true},
            {Name: "content", Type: "text", Searchable: true, Stored: true},
            {Name: "tags", Type: "keyword", Filterable: true, Faceted: true, Stored: true},
        },
    }
    
    if err := searchService.CreateIndex(ctx, "integration_test", schema); err != nil {
        t.Fatalf("Failed to create index: %v", err)
    }
    
    // Index test documents
    docs := []search.Document{
        {
            ID: "1",
            Fields: map[string]interface{}{
                "title":   "First Document",
                "content": "This is the first test document",
                "tags":    []string{"test", "first"},
            },
        },
        {
            ID: "2",
            Fields: map[string]interface{}{
                "title":   "Second Document",
                "content": "This is the second test document",
                "tags":    []string{"test", "second"},
            },
        },
    }
    
    if err := searchService.BulkIndex(ctx, "integration_test", docs); err != nil {
        t.Fatalf("Failed to bulk index: %v", err)
    }
    
    // Wait for indexing to complete
    time.Sleep(2 * time.Second)
    
    // Test search
    query := search.SearchQuery{
        Index: "integration_test",
        Query: "test document",
        Limit: 10,
    }
    
    results, err := searchService.Search(ctx, query)
    if err != nil {
        t.Fatalf("Failed to search: %v", err)
    }
    
    if results.Total < 2 {
        t.Errorf("Expected at least 2 results, got %d", results.Total)
    }
    
    // Test faceted search
    facetQuery := search.SearchQuery{
        Index:  "integration_test",
        Query:  "*",
        Facets: []string{"tags"},
        Limit:  10,
    }
    
    facetResults, err := searchService.Search(ctx, facetQuery)
    if err != nil {
        t.Fatalf("Failed to search with facets: %v", err)
    }
    
    if len(facetResults.Facets) == 0 {
        t.Error("Expected facets in results")
    }
    
    if tagsFacets, ok := facetResults.Facets["tags"]; ok {
        if len(tagsFacets) < 2 {
            t.Errorf("Expected at least 2 tag facets, got %d", len(tagsFacets))
        }
    } else {
        t.Error("Expected 'tags' facet in results")
    }
}
```

### Benchmark Tests

```go
package main

import (
    "context"
    "fmt"
    "testing"
    
    "github.com/xraph/forge/v2"
    "github.com/xraph/forge/v2/extensions/search"
)

func BenchmarkSearchIndexing(b *testing.B) {
    app := forge.NewApp(forge.DefaultAppConfig())
    app.AddExtension(search.NewExtension(search.WithDriver("inmemory")))
    
    ctx := context.Background()
    if err := app.Start(ctx); err != nil {
        b.Fatalf("Failed to start app: %v", err)
    }
    defer app.Stop(ctx)
    
    searchService, _ := forge.Resolve[search.Search](app.Container(), "search")
    
    // Create index
    schema := search.IndexSchema{
        Fields: []search.FieldSchema{
            {Name: "title", Type: "text", Searchable: true, Stored: true},
            {Name: "content", Type: "text", Searchable: true, Stored: true},
        },
    }
    
    if err := searchService.CreateIndex(ctx, "benchmark", schema); err != nil {
        b.Fatalf("Failed to create index: %v", err)
    }
    
    b.ResetTimer()
    
    for i := 0; i < b.N; i++ {
        doc := search.Document{
            ID: fmt.Sprintf("doc_%d", i),
            Fields: map[string]interface{}{
                "title":   fmt.Sprintf("Document %d", i),
                "content": fmt.Sprintf("This is the content of document %d", i),
            },
        }
        
        if err := searchService.Index(ctx, "benchmark", doc); err != nil {
            b.Fatalf("Failed to index document: %v", err)
        }
    }
}

func BenchmarkSearchQuery(b *testing.B) {
    app := forge.NewApp(forge.DefaultAppConfig())
    app.AddExtension(search.NewExtension(search.WithDriver("inmemory")))
    
    ctx := context.Background()
    if err := app.Start(ctx); err != nil {
        b.Fatalf("Failed to start app: %v", err)
    }
    defer app.Stop(ctx)
    
    searchService, _ := forge.Resolve[search.Search](app.Container(), "search")
    
    // Setup test data
    schema := search.IndexSchema{
        Fields: []search.FieldSchema{
            {Name: "title", Type: "text", Searchable: true, Stored: true},
            {Name: "content", Type: "text", Searchable: true, Stored: true},
        },
    }
    
    if err := searchService.CreateIndex(ctx, "benchmark", schema); err != nil {
        b.Fatalf("Failed to create index: %v", err)
    }
    
    // Index test documents
    docs := make([]search.Document, 1000)
    for i := 0; i < 1000; i++ {
        docs[i] = search.Document{
            ID: fmt.Sprintf("doc_%d", i),
            Fields: map[string]interface{}{
                "title":   fmt.Sprintf("Document %d", i),
                "content": fmt.Sprintf("This is the content of document %d with some searchable text", i),
            },
        }
    }
    
    if err := searchService.BulkIndex(ctx, "benchmark", docs); err != nil {
        b.Fatalf("Failed to bulk index: %v", err)
    }
    
    query := search.SearchQuery{
        Index: "benchmark",
        Query: "searchable text",
        Limit: 20,
    }
    
    b.ResetTimer()
    
    for i := 0; i < b.N; i++ {
        _, err := searchService.Search(ctx, query)
        if err != nil {
            b.Fatalf("Failed to search: %v", err)
        }
    }
}

func BenchmarkBulkIndexing(b *testing.B) {
    app := forge.NewApp(forge.DefaultAppConfig())
    app.AddExtension(search.NewExtension(search.WithDriver("inmemory")))
    
    ctx := context.Background()
    if err := app.Start(ctx); err != nil {
        b.Fatalf("Failed to start app: %v", err)
    }
    defer app.Stop(ctx)
    
    searchService, _ := forge.Resolve[search.Search](app.Container(), "search")
    
    schema := search.IndexSchema{
        Fields: []search.FieldSchema{
            {Name: "title", Type: "text", Searchable: true, Stored: true},
            {Name: "content", Type: "text", Searchable: true, Stored: true},
        },
    }
    
    if err := searchService.CreateIndex(ctx, "benchmark", schema); err != nil {
        b.Fatalf("Failed to create index: %v", err)
    }
    
    // Prepare bulk documents
    docs := make([]search.Document, 100)
    for i := 0; i < 100; i++ {
        docs[i] = search.Document{
            ID: fmt.Sprintf("doc_%d", i),
            Fields: map[string]interface{}{
                "title":   fmt.Sprintf("Document %d", i),
                "content": fmt.Sprintf("This is the content of document %d", i),
            },
        }
    }
    
    b.ResetTimer()
    
    for i := 0; i < b.N; i++ {
        if err := searchService.BulkIndex(ctx, "benchmark", docs); err != nil {
            b.Fatalf("Failed to bulk index: %v", err)
        }
    }
}
```

## Best Practices

### Schema Design

```go
// Good: Well-structured schema with appropriate field types
schema := search.IndexSchema{
    Fields: []search.FieldSchema{
        {
            Name:       "title",
            Type:       "text",
            Searchable: true,
            Stored:     true,
            Boost:      2.0, // Boost important fields
            Analyzer:   "standard",
        },
        {
            Name:       "slug",
            Type:       "keyword", // Use keyword for exact matches
            Filterable: true,
            Stored:     true,
        },
        {
            Name:       "tags",
            Type:       "keyword",
            Filterable: true,
            Faceted:    true, // Enable faceting for filtering UI
            Stored:     true,
        },
        {
            Name:       "published_at",
            Type:       "date",
            Sortable:   true,
            Filterable: true,
            Format:     "2006-01-02T15:04:05Z",
        },
        {
            Name:       "content",
            Type:       "text",
            Searchable: true,
            Stored:     false, // Don't store large content if not needed
            Analyzer:   "english",
        },
    },
    StopWords: []string{"the", "a", "an", "and", "or", "but"},
    Synonyms: []search.Synonym{
        {Terms: []string{"quick", "fast", "rapid"}},
    },
}
```

### Error Handling

```go
package main

import (
    "context"
    "errors"
    "log"
    "time"
    
    "github.com/xraph/forge/v2/extensions/search"
)

func robustSearch(searchService search.Search) {
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    query := search.SearchQuery{
        Index: "products",
        Query: "smartphone",
        Limit: 20,
    }
    
    // Retry logic for transient failures
    var results *search.SearchResults
    var err error
    
    for attempt := 0; attempt < 3; attempt++ {
        results, err = searchService.Search(ctx, query)
        if err == nil {
            break
        }
        
        // Check if error is retryable
        if isRetryableError(err) {
            log.Printf("Search attempt %d failed (retryable): %v", attempt+1, err)
            time.Sleep(time.Duration(attempt+1) * 100 * time.Millisecond)
            continue
        }
        
        // Non-retryable error
        log.Printf("Search failed (non-retryable): %v", err)
        return
    }
    
    if err != nil {
        log.Printf("Search failed after 3 attempts: %v", err)
        return
    }
    
    // Process results
    log.Printf("Found %d results", results.Total)
}

func isRetryableError(err error) bool {
    // Check for specific error types that are retryable
    if errors.Is(err, context.DeadlineExceeded) {
        return true
    }
    
    // Add more retryable error checks based on your search backend
    errStr := err.Error()
    retryableMessages := []string{
        "connection refused",
        "timeout",
        "temporary failure",
        "service unavailable",
    }
    
    for _, msg := range retryableMessages {
        if strings.Contains(strings.ToLower(errStr), msg) {
            return true
        }
    }
    
    return false
}
```

### Performance Optimization

```go
package main

import (
    "context"
    "log"
    
    "github.com/xraph/forge/v2/extensions/search"
)

func optimizedSearch() {
    // Use connection pooling and compression
    ext := search.NewExtension(
        search.WithDriver("elasticsearch"),
        search.WithURL("http://localhost:9200"),
        search.WithMaxConnections(50),
        search.WithTimeout(30*time.Second),
        // Enable compression for large payloads
        search.WithConfig(search.Config{
            EnableCompression: true,
            BulkSize:         500, // Optimize bulk size
            FlushInterval:    5 * time.Second,
        }),
    )
    
    // Use bulk operations for multiple documents
    bulkDocs := make([]search.Document, 0, 1000)
    for i := 0; i < 1000; i++ {
        bulkDocs = append(bulkDocs, search.Document{
            ID: fmt.Sprintf("doc_%d", i),
            Fields: map[string]interface{}{
                "title":   fmt.Sprintf("Document %d", i),
                "content": generateContent(i),
            },
        })
    }
    
    // Bulk index in batches
    batchSize := 100
    for i := 0; i < len(bulkDocs); i += batchSize {
        end := i + batchSize
        if end > len(bulkDocs) {
            end = len(bulkDocs)
        }
        
        batch := bulkDocs[i:end]
        if err := searchService.BulkIndex(ctx, "documents", batch); err != nil {
            log.Printf("Failed to index batch %d-%d: %v", i, end, err)
        }
    }
    
    // Optimize search queries
    optimizedQuery := search.SearchQuery{
        Index: "documents",
        Query: "search terms",
        Fields: []string{"title", "summary"}, // Only return needed fields
        Limit: 20,
        MinScore: 0.5, // Filter low-relevance results
        BoostFields: map[string]float64{
            "title": 2.0, // Boost important fields
        },
    }
    
    results, err := searchService.Search(ctx, optimizedQuery)
    if err != nil {
        log.Fatal(err)
    }
    
    log.Printf("Found %d results in %v", results.Total, results.ProcessingTime)
}

func generateContent(i int) string {
    // Generate sample content
    return fmt.Sprintf("This is the content for document %d with various keywords and phrases", i)
}
```

### Security

```go
package main

import (
    "context"
    "html"
    "regexp"
    "strings"
    
    "github.com/xraph/forge/v2/extensions/search"
)

func secureSearch(searchService search.Search, userQuery string) (*search.SearchResults, error) {
    // Sanitize user input
    sanitizedQuery := sanitizeSearchQuery(userQuery)
    
    // Validate query length
    if len(sanitizedQuery) > 1000 {
        return nil, fmt.Errorf("search query too long")
    }
    
    // Prevent injection attacks
    if containsInjectionPatterns(sanitizedQuery) {
        return nil, fmt.Errorf("invalid search query")
    }
    
    query := search.SearchQuery{
        Index: "public_documents", // Use specific index
        Query: sanitizedQuery,
        Limit: 50, // Limit results to prevent abuse
        Fields: []string{"title", "summary"}, // Only return safe fields
    }
    
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()
    
    results, err := searchService.Search(ctx, query)
    if err != nil {
        return nil, err
    }
    
    // Sanitize results before returning
    sanitizeResults(results)
    
    return results, nil
}

func sanitizeSearchQuery(query string) string {
    // Remove HTML tags
    query = html.EscapeString(query)
    
    // Remove special characters that could be used for injection
    reg := regexp.MustCompile(`[<>\"';&|]`)
    query = reg.ReplaceAllString(query, "")
    
    // Trim whitespace
    query = strings.TrimSpace(query)
    
    return query
}

func containsInjectionPatterns(query string) bool {
    // Check for common injection patterns
    injectionPatterns := []string{
        "script:",
        "javascript:",
        "data:",
        "vbscript:",
        "<script",
        "</script",
        "eval(",
        "expression(",
    }
    
    lowerQuery := strings.ToLower(query)
    for _, pattern := range injectionPatterns {
        if strings.Contains(lowerQuery, pattern) {
            return true
        }
    }
    
    return false
}

func sanitizeResults(results *search.SearchResults) {
    for i := range results.Hits {
        hit := &results.Hits[i]
        
        // Sanitize document fields
        for key, value := range hit.Document {
            if str, ok := value.(string); ok {
                hit.Document[key] = html.EscapeString(str)
            }
        }
        
        // Sanitize highlights
        for key, highlights := range hit.Highlights {
            for j, highlight := range highlights {
                hit.Highlights[key][j] = html.EscapeString(highlight)
            }
        }
    }
}
```

## Troubleshooting

### Common Issues

```go
package main

import (
    "context"
    "fmt"
    "log"
    "time"
    
    "github.com/xraph/forge/v2/extensions/search"
)

func troubleshootSearch(searchService search.Search) {
    ctx := context.Background()
    
    // Check connection
    if err := searchService.Ping(ctx); err != nil {
        log.Printf("Connection failed: %v", err)
        
        // Try to reconnect
        if err := searchService.Connect(ctx); err != nil {
            log.Printf("Reconnection failed: %v", err)
            return
        }
    }
    
    // Check index existence
    indexes, err := searchService.ListIndexes(ctx)
    if err != nil {
        log.Printf("Failed to list indexes: %v", err)
        return
    }
    
    targetIndex := "my_index"
    indexExists := false
    for _, index := range indexes {
        if index == targetIndex {
            indexExists = true
            break
        }
    }
    
    if !indexExists {
        log.Printf("Index %s does not exist", targetIndex)
        return
    }
    
    // Check index health
    info, err := searchService.GetIndexInfo(ctx, targetIndex)
    if err != nil {
        log.Printf("Failed to get index info: %v", err)
        return
    }
    
    log.Printf("Index %s has %d documents", targetIndex, info.DocumentCount)
    
    // Test simple search
    testQuery := search.SearchQuery{
        Index: targetIndex,
        Query: "*",
        Limit: 1,
    }
    
    results, err := searchService.Search(ctx, testQuery)
    if err != nil {
        log.Printf("Test search failed: %v", err)
        return
    }
    
    log.Printf("Test search returned %d results", results.Total)
    
    // Check performance
    start := time.Now()
    _, err = searchService.Search(ctx, testQuery)
    duration := time.Since(start)
    
    if err != nil {
        log.Printf("Performance test failed: %v", err)
    } else {
        log.Printf("Search took %v", duration)
        if duration > 5*time.Second {
            log.Printf("WARNING: Search is slow (>5s)")
        }
    }
}

// Debug search performance
func debugSearchPerformance(searchService search.Search) {
    ctx := context.Background()
    
    // Get search statistics
    stats, err := searchService.Stats(ctx)
    if err != nil {
        log.Printf("Failed to get stats: %v", err)
        return
    }
    
    log.Printf("Search Engine Stats:")
    log.Printf("  Indexes: %d", stats.IndexCount)
    log.Printf("  Documents: %d", stats.DocumentCount)
    log.Printf("  Total Size: %d bytes", stats.TotalSize)
    log.Printf("  Queries: %d", stats.Queries)
    log.Printf("  Avg Latency: %v", stats.AvgLatency)
    log.Printf("  Uptime: %v", stats.Uptime)
    
    // Performance warnings
    if stats.AvgLatency > 1*time.Second {
        log.Printf("WARNING: High average latency (>1s)")
    }
    
    if stats.DocumentCount > 1000000 {
        log.Printf("INFO: Large document count, consider sharding")
    }
}

// Memory usage debugging
func debugMemoryUsage(searchService search.Search) {
    ctx := context.Background()
    
    // Check if using in-memory driver
    stats, err := searchService.Stats(ctx)
    if err != nil {
        log.Printf("Failed to get stats: %v", err)
        return
    }
    
    // Estimate memory usage (rough calculation)
    avgDocSize := float64(stats.TotalSize) / float64(stats.DocumentCount)
    estimatedMemory := avgDocSize * float64(stats.DocumentCount)
    
    log.Printf("Estimated memory usage: %.2f MB", estimatedMemory/1024/1024)
    
    if estimatedMemory > 1024*1024*1024 { // 1GB
        log.Printf("WARNING: High memory usage, consider external search engine")
    }
}
```

### Performance Issues

<Callout type="warning">
**Performance Considerations**: Search performance depends on index size, query complexity, and backend configuration. Monitor query latency and optimize accordingly.
</Callout>

```go
// Optimize slow queries
func optimizeSlowQueries(searchService search.Search) {
    ctx := context.Background()
    
    // Use specific fields instead of full-text search when possible
    fastQuery := search.SearchQuery{
        Index: "products",
        Filters: []search.Filter{
            {Field: "category", Operator: "=", Value: "electronics"},
            {Field: "price", Operator: "BETWEEN", Value: []float64{100, 500}},
        },
        Sort: []search.SortField{
            {Field: "created_at", Order: "desc"},
        },
        Limit: 20,
        Fields: []string{"id", "title", "price"}, // Only return needed fields
    }
    
    results, err := searchService.Search(ctx, fastQuery)
    if err != nil {
        log.Printf("Optimized search failed: %v", err)
        return
    }
    
    log.Printf("Fast query returned %d results in %v", 
        results.Total, results.ProcessingTime)
}
```

### Connection Issues

```go
// Handle connection failures gracefully
func handleConnectionFailures(searchService search.Search) {
    ctx := context.Background()
    
    // Implement circuit breaker pattern
    maxFailures := 5
    failures := 0
    
    for {
        err := searchService.Ping(ctx)
        if err != nil {
            failures++
            log.Printf("Connection failure %d/%d: %v", failures, maxFailures, err)
            
            if failures >= maxFailures {
                log.Printf("Circuit breaker opened, stopping search operations")
                break
            }
            
            // Exponential backoff
            backoff := time.Duration(failures) * time.Second
            log.Printf("Retrying in %v", backoff)
            time.Sleep(backoff)
            continue
        }
        
        // Reset failure count on success
        failures = 0
        log.Printf("Connection restored")
        break
    }
}
```

## Migration Guide

### From Search v1 to v2

<Callout type="info">
**Migration Timeline**: Plan for gradual migration with backward compatibility during transition period.
</Callout>

#### Configuration Migration

```go
// v1 Configuration (deprecated)
config := search.Config{
    Engine: "elasticsearch",
    Host:   "localhost:9200",
    Index:  "default",
}

// v2 Configuration (new)
ext := search.NewExtension(
    search.WithDriver("elasticsearch"),
    search.WithURL("http://localhost:9200"),
    search.WithDefaultLimit(20),
    search.WithMaxLimit(100),
)
```

#### Interface Migration

```go
// v1 Interface (deprecated)
type SearchService interface {
    Index(doc Document) error
    Search(query string) ([]Result, error)
    Delete(id string) error
}

// v2 Interface (new)
type Search interface {
    // Context-aware methods
    Index(ctx context.Context, index string, doc Document) error
    Search(ctx context.Context, query SearchQuery) (*SearchResults, error)
    Delete(ctx context.Context, index string, id string) error
    
    // New capabilities
    BulkIndex(ctx context.Context, index string, docs []Document) error
    Suggest(ctx context.Context, query SuggestQuery) (*SuggestResults, error)
    Autocomplete(ctx context.Context, query AutocompleteQuery) (*AutocompleteResults, error)
}
```

#### Breaking Changes

1. **Context Requirement**: All methods now require `context.Context`
2. **Index Parameter**: Index name is now required for all operations
3. **Structured Queries**: String queries replaced with `SearchQuery` struct
4. **Error Handling**: More specific error types and better error context

#### Migration Steps

```go
// Step 1: Update imports
// Old: import "github.com/xraph/forge/extensions/search"
// New: import "github.com/xraph/forge/extensions/search"

// Step 2: Update configuration
func migrateConfig() {
    // Old way
    // config := search.Config{Engine: "elasticsearch", Host: "localhost:9200"}
    
    // New way
    app.AddExtension(search.NewExtension(
        search.WithDriver("elasticsearch"),
        search.WithURL("http://localhost:9200"),
    ))
}

// Step 3: Update search calls
func migrateSearchCalls(searchService search.Search) {
    ctx := context.Background()
    
    // Old way
    // results, err := searchService.Search("query text")
    
    // New way
    query := search.SearchQuery{
        Index: "documents",
        Query: "query text",
        Limit: 20,
    }
    results, err := searchService.Search(ctx, query)
    if err != nil {
        log.Printf("Search failed: %v", err)
        return
    }
    
    // Process results
    for _, hit := range results.Hits {
        log.Printf("Document: %s", hit.ID)
    }
}

// Step 4: Update indexing calls
func migrateIndexing(searchService search.Search) {
    ctx := context.Background()
    
    // Old way
    // doc := Document{ID: "1", Content: "text"}
    // err := searchService.Index(doc)
    
    // New way
    doc := search.Document{
        ID: "1",
        Fields: map[string]interface{}{
            "title":   "Document Title",
            "content": "Document content",
        },
    }
    err := searchService.Index(ctx, "documents", doc)
    if err != nil {
        log.Printf("Indexing failed: %v", err)
    }
}
```

#### Compatibility Layer

```go
// Create a compatibility wrapper for gradual migration
type LegacySearchWrapper struct {
    search search.Search
    defaultIndex string
}

func NewLegacyWrapper(s search.Search, defaultIndex string) *LegacySearchWrapper {
    return &LegacySearchWrapper{
        search: s,
        defaultIndex: defaultIndex,
    }
}

// Legacy method signatures
func (w *LegacySearchWrapper) Search(query string) ([]LegacyResult, error) {
    ctx := context.Background()
    
    searchQuery := search.SearchQuery{
        Index: w.defaultIndex,
        Query: query,
        Limit: 20,
    }
    
    results, err := w.search.Search(ctx, searchQuery)
    if err != nil {
        return nil, err
    }
    
    // Convert to legacy format
    legacyResults := make([]LegacyResult, len(results.Hits))
    for i, hit := range results.Hits {
        legacyResults[i] = LegacyResult{
            ID:    hit.ID,
            Score: hit.Score,
            Data:  hit.Document,
        }
    }
    
    return legacyResults, nil
}

type LegacyResult struct {
    ID    string                 `json:"id"`
    Score float64                `json:"score"`
    Data  map[string]interface{} `json:"data"`
}
```

## Conclusion

The Search extension provides a powerful and flexible foundation for implementing full-text search capabilities in your Forge applications. With support for multiple backends, advanced search features, and comprehensive testing utilities, you can build robust search experiences that scale with your application needs.

### Key Benefits

- **Unified Interface**: Consistent API across all search backends
- **Multiple Backends**: Choose the right search engine for your use case
- **Advanced Features**: Full-text search, filtering, faceting, suggestions, and autocomplete
- **Performance**: Optimized for high-throughput search operations
- **Security**: Built-in input sanitization and secure query handling
- **Testing**: Comprehensive testing utilities for reliable development

### Next Steps

1. **Choose Your Backend**: Select the appropriate search engine based on your requirements
2. **Design Your Schema**: Plan your index structure and field types
3. **Implement Search**: Start with basic search and gradually add advanced features
4. **Optimize Performance**: Monitor query performance and optimize as needed
5. **Test Thoroughly**: Use the provided testing utilities to ensure reliability

For more information, see the [API Reference](/docs/api/search) and [Examples Repository](https://github.com/xraph/forge/tree/main/examples/search).

<Callout type="tip">
**Pro Tip**: Start with the in-memory driver for development and testing, then migrate to a production search engine like Elasticsearch or Meilisearch when you're ready to deploy.
</Callout>