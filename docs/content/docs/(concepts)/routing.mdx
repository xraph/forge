---
title: Routing
description: Learn how to define routes and handle HTTP requests in Forge Go
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Tab, Tabs } from 'fumadocs-ui/components/tabs'
import { Card, Cards } from 'fumadocs-ui/components/card'

# Routing

Forge Go provides a powerful and flexible routing system that makes it easy to define HTTP endpoints and handle requests.

## Basic Routing

```go
package main

import (
    "log"
    "github.com/xraph/forge"
)

func main() {
    app := forge.New(forge.Config{
        Name: "My App",
    })

    // Basic routes
    app.GET("/", homeHandler)
    app.POST("/users", createUserHandler)
    app.PUT("/users/:id", updateUserHandler)
    app.DELETE("/users/:id", deleteUserHandler)

    log.Fatal(app.Listen(":8080"))
}

func homeHandler(c *forge.Context) error {
    return c.JSON(200, map[string]string{
        "message": "Welcome to Forge!",
    })
}

func createUserHandler(c *forge.Context) error {
    // Handle user creation
    return c.JSON(201, map[string]string{
        "message": "User created",
    })
}

func updateUserHandler(c *forge.Context) error {
    id := c.Param("id")
    return c.JSON(200, map[string]string{
        "message": "User " + id + " updated",
    })
}

func deleteUserHandler(c *forge.Context) error {
    id := c.Param("id")
    return c.JSON(200, map[string]string{
        "message": "User " + id + " deleted",
    })
}
```

## Route Parameters

Forge supports dynamic route parameters using the `:param` syntax:

```go
// Single parameter
app.GET("/users/:id", getUserHandler)

// Multiple parameters
app.GET("/users/:id/posts/:postId", getUserPostHandler)

// Wildcard parameter
app.GET("/files/*path", getFileHandler)

func getUserHandler(c *forge.Context) error {
    id := c.Param("id")
    return c.JSON(200, map[string]string{
        "id": id,
    })
}

func getUserPostHandler(c *forge.Context) error {
    userID := c.Param("id")
    postID := c.Param("postId")
    return c.JSON(200, map[string]string{
        "userId": userID,
        "postId": postID,
    })
}

func getFileHandler(c *forge.Context) error {
    path := c.Param("path")
    return c.JSON(200, map[string]string{
        "path": path,
    })
}
```

## Route Groups

Organize related routes using groups:

```go
// API v1 routes
apiV1 := app.Group("/api/v1")
apiV1.GET("/users", getUsersHandler)
apiV1.POST("/users", createUserHandler)
apiV1.GET("/users/:id", getUserHandler)
apiV1.PUT("/users/:id", updateUserHandler)
apiV1.DELETE("/users/:id", deleteUserHandler)

// API v2 routes
apiV2 := app.Group("/api/v2")
apiV2.GET("/users", getUsersV2Handler)
apiV2.POST("/users", createUserV2Handler)

// Admin routes
admin := app.Group("/admin")
admin.GET("/dashboard", adminDashboardHandler)
admin.GET("/users", adminUsersHandler)
admin.DELETE("/users/:id", adminDeleteUserHandler)
```

## Nested Groups

You can create nested route groups:

```go
// API routes
api := app.Group("/api")

// V1 API
v1 := api.Group("/v1")
v1.GET("/users", getUsersV1Handler)
v1.POST("/users", createUserV1Handler)

// V2 API
v2 := api.Group("/v2")
v2.GET("/users", getUsersV2Handler)
v2.POST("/users", createUserV2Handler)

// Admin API
admin := api.Group("/admin")
admin.GET("/stats", getAdminStatsHandler)
admin.POST("/users", createAdminUserHandler)
```

## HTTP Methods

Forge supports all standard HTTP methods:

```go
app.GET("/users", getUsersHandler)
app.POST("/users", createUserHandler)
app.PUT("/users/:id", updateUserHandler)
app.PATCH("/users/:id", patchUserHandler)
app.DELETE("/users/:id", deleteUserHandler)
app.HEAD("/users", headUsersHandler)
app.OPTIONS("/users", optionsUsersHandler)
```

## Request Handling

### Reading Request Data

```go
func createUserHandler(c *forge.Context) error {
    // Read JSON body
    var user User
    if err := c.BindJSON(&user); err != nil {
        return c.JSON(400, map[string]string{
            "error": "Invalid JSON",
        })
    }

    // Read query parameters
    page := c.Query("page")
    limit := c.Query("limit")

    // Read form data
    name := c.FormValue("name")
    email := c.FormValue("email")

    // Read headers
    contentType := c.Request.Header.Get("Content-Type")
    userAgent := c.Request.Header.Get("User-Agent")

    return c.JSON(201, map[string]interface{}{
        "user": user,
        "page": page,
        "limit": limit,
        "name": name,
        "email": email,
        "contentType": contentType,
        "userAgent": userAgent,
    })
}
```

### Sending Responses

```go
func getUserHandler(c *forge.Context) error {
    id := c.Param("id")
    
    // JSON response
    return c.JSON(200, map[string]string{
        "id": id,
        "name": "John Doe",
    })
}

func getFileHandler(c *forge.Context) error {
    // File response
    return c.File("./uploads/file.pdf")
}

func redirectHandler(c *forge.Context) error {
    // Redirect
    return c.Redirect(301, "/new-location")
}

func htmlHandler(c *forge.Context) error {
    // HTML response
    return c.HTML(200, "<h1>Hello World</h1>")
}

func stringHandler(c *forge.Context) error {
    // String response
    return c.String(200, "Hello World")
}
```

## Route Middleware

Apply middleware to specific routes:

```go
// Global middleware
app.Use(forge.Logger())
app.Use(forge.Recovery())

// Route-specific middleware
app.GET("/public", publicHandler)
app.GET("/protected", AuthMiddleware(), protectedHandler)
app.GET("/admin", AuthMiddleware(), AdminMiddleware(), adminHandler)

// Group middleware
api := app.Group("/api", AuthMiddleware())
api.GET("/users", getUsersHandler)
api.POST("/users", createUserHandler)
```

## Route Patterns

Forge supports various route patterns:

```go
// Exact match
app.GET("/users", getUsersHandler)

// Parameter
app.GET("/users/:id", getUserHandler)

// Wildcard
app.GET("/files/*path", getFileHandler)

// Optional parameter
app.GET("/users/:id?", getUserHandler)

// Regex pattern
app.GET("/users/:id([0-9]+)", getUserHandler)
```

## Error Handling

```go
func getUserHandler(c *forge.Context) error {
    id := c.Param("id")
    
    if id == "" {
        return c.JSON(400, map[string]string{
            "error": "User ID is required",
        })
    }
    
    user, err := getUserByID(id)
    if err != nil {
        return c.JSON(404, map[string]string{
            "error": "User not found",
        })
    }
    
    return c.JSON(200, user)
}
```

## Best Practices

<Cards>
  <Card
    title="RESTful Design"
    description="Follow REST conventions for API endpoints"
  />
  <Card
    title="Group Related Routes"
    description="Use route groups to organize related endpoints"
  />
  <Card
    title="Consistent Naming"
    description="Use consistent naming conventions for routes and handlers"
  />
  <Card
    title="Error Handling"
    description="Always handle errors and return appropriate HTTP status codes"
  />
</Cards>

<Callout type="tip">
**Pro Tip**: Use route groups to organize your API by version and apply common middleware to related routes.
</Callout>
