---
title: Dependency Injection
description: Register and resolve services with Forge's built-in DI container
icon: GitBranch
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Cards, Card } from 'fumadocs-ui/components/card';
import { Tabs, Tab } from 'fumadocs-ui/components/tabs';

Forge includes a full dependency injection container powered by [Vessel](https://github.com/xraph/vessel). Services are registered with factories, resolved by name or type, and managed across three lifetime scopes. The DI container handles startup ordering, shutdown cleanup, and circular dependency detection automatically.

## Service Lifetimes

Every registered service has a lifetime that determines when instances are created and how long they live:

| Lifetime | Description | Use Case |
|---|---|---|
| **Singleton** | Created once, shared across the entire application | Database connections, configuration, caches |
| **Transient** | Created fresh on every `Resolve` call | Request-specific processors, one-off workers |
| **Scoped** | Created once per scope (e.g., per HTTP request) | Request-scoped state, per-request database transactions |

## Registering Services

### Using app.RegisterService

The most common pattern registers a named service through the app:

```go
app := forge.New(forge.WithAppName("my-api"))

// Register a singleton service
app.RegisterService("userRepo", func(c forge.Container) (any, error) {
    db, err := forge.Resolve[*sql.DB](c, "database")
    if err != nil {
        return nil, err
    }
    return NewUserRepository(db), nil
}, forge.Singleton(), forge.WithDependencies("database"))
```

### Type-Safe Generic Registration

Forge provides type-safe generic helpers that wrap the container's registration methods:

<Tabs items={["Singleton", "Transient", "Scoped"]}>
<Tab value="Singleton">
```go
// RegisterSingleton[T] - created once, shared globally
forge.RegisterSingleton[*UserRepository](app.Container(), "userRepo",
    func(c forge.Container) (*UserRepository, error) {
        db, err := forge.Resolve[*sql.DB](c, "database")
        if err != nil {
            return nil, err
        }
        return NewUserRepository(db), nil
    },
)
```
</Tab>
<Tab value="Transient">
```go
// RegisterTransient[T] - new instance on every resolve
forge.RegisterTransient[*RequestLogger](app.Container(), "requestLogger",
    func(c forge.Container) (*RequestLogger, error) {
        logger, err := forge.Resolve[forge.Logger](c, "logger")
        if err != nil {
            return nil, err
        }
        return NewRequestLogger(logger), nil
    },
)
```
</Tab>
<Tab value="Scoped">
```go
// RegisterScoped[T] - one instance per scope (per HTTP request)
forge.RegisterScoped[*Transaction](app.Container(), "transaction",
    func(c forge.Container) (*Transaction, error) {
        db, err := forge.Resolve[*sql.DB](c, "database")
        if err != nil {
            return nil, err
        }
        tx, err := db.Begin()
        return &Transaction{tx: tx}, err
    },
)
```
</Tab>
</Tabs>

### Register a Pre-Built Value

For instances that already exist (no factory needed):

```go
myConfig := &AppSettings{Debug: true, MaxRetries: 3}
forge.RegisterValue(app.Container(), "settings", myConfig)
```

### Register an Interface Implementation

Bind an interface to a concrete implementation:

```go
forge.RegisterSingletonInterface[UserStore, *PostgresUserStore](
    app.Container(), "userStore",
    func(c forge.Container) (*PostgresUserStore, error) {
        db, err := forge.Resolve[*sql.DB](c, "database")
        if err != nil {
            return nil, err
        }
        return &PostgresUserStore{db: db}, nil
    },
)
```

## Resolving Services

### In Handlers

Access the container through the request context to resolve services inside HTTP handlers:

```go
app.Router().GET("/users/:id", func(ctx forge.Context) error {
    // Resolve the user repository from the container
    repo, err := forge.Resolve[*UserRepository](ctx.Container(), "userRepo")
    if err != nil {
        return forge.InternalError("service unavailable")
    }

    user, err := repo.FindByID(ctx.Request().Context(), ctx.Param("id"))
    if err != nil {
        return forge.NotFound("user not found")
    }

    return ctx.JSON(200, user)
})
```

### In Lifecycle Hooks

Resolve services from the app's container during startup:

```go
app.RegisterHookFn(forge.PhaseAfterRegister, "seed-data",
    func(ctx context.Context, app forge.App) error {
        repo := forge.Must[*UserRepository](app.Container(), "userRepo")
        return repo.SeedDefaultUsers(ctx)
    },
)
```

### Must vs Resolve

| Function | Behavior on Error |
|---|---|
| `forge.Resolve[T](c, name)` | Returns `(T, error)` -- safe for runtime use |
| `forge.Must[T](c, name)` | Panics on error -- use only during startup |

<Callout type="warn">
Only use `Must` during application startup (in `main()` or lifecycle hooks) where a panic is acceptable. In HTTP handlers, always use `Resolve` and handle the error gracefully.
</Callout>

## Built-In Services

Forge automatically registers these services in the container at startup. You can resolve them by name or use the provided helper functions:

| Service | Key | Helper Function | Type |
|---|---|---|---|
| Logger | `"forge:logger"` | `forge.GetLogger(c)` | `forge.Logger` |
| Config Manager | `"forge:config"` | Direct via `app.Config()` | `forge.ConfigManager` |
| Metrics | `"forge:metrics"` | `forge.GetMetrics(c)` | `forge.Metrics` |
| Health Manager | `"forge:health"` | `forge.GetHealthManager(c)` | `forge.HealthManager` |
| Router | `"forge:router"` | `forge.GetRouter(c)` | `forge.Router` |

These services are also registered as constructor-injectable types, so they can be resolved by type without a name key.

## Typed Injection with Provide

For cleaner dependency declaration, use `forge.Provide` with typed injection options:

```go
forge.Provide[*UserService](app.Container(), "userService",
    forge.Inject[*sql.DB]("database"),        // Eager: resolved immediately
    forge.Inject[forge.Logger]("logger"),       // Eager: resolved immediately
    forge.LazyInject[*CacheClient]("cache"),    // Lazy: resolved on first access
    func(db *sql.DB, log forge.Logger, cache *forge.LazyAny) (*UserService, error) {
        return &UserService{
            db:     db,
            logger: log,
            cache:  cache,
        }, nil
    },
)
```

### Injection Modes

| Mode | Function | Behavior |
|---|---|---|
| Eager | `forge.Inject[T](name)` | Resolved immediately during service creation; fails if not found |
| Lazy | `forge.LazyInject[T](name)` | Resolved on first access via `.Get()` |
| Optional | `forge.OptionalInject[T](name)` | Resolved immediately; returns nil if not found |
| Lazy Optional | `forge.LazyOptionalInject[T](name)` | Resolved on first access; returns nil if not found |
| Provider | `forge.ProviderInject[T](name)` | Creates a new instance on each `.Get()` call |

## Constructor Injection

For the cleanest DI pattern, use constructor injection where dependencies are resolved by their Go types rather than string keys:

```go
// Define constructors as plain functions
func NewDatabase(dsn string) *Database {
    return &Database{dsn: dsn}
}

func NewUserService(db *Database, log forge.Logger) *UserService {
    return &UserService{db: db, log: log}
}

// Register constructors -- dependencies are auto-resolved by type
forge.ProvideConstructor(app.Container(), NewDatabase)
forge.ProvideConstructor(app.Container(), NewUserService)

// Resolve by type (no string keys needed)
userService, err := forge.InjectType[*UserService](app.Container())
```

### Named Constructor Instances

When you have multiple instances of the same type, use names to distinguish them:

```go
import "github.com/xraph/vessel"

forge.ProvideConstructor(app.Container(), NewPrimaryDB, vessel.WithName("primary"))
forge.ProvideConstructor(app.Container(), NewReplicaDB, vessel.WithName("replica"))

primary, err := forge.InjectNamed[*Database](app.Container(), "primary")
replica, err := forge.InjectNamed[*Database](app.Container(), "replica")
```

### Service Groups

Register multiple implementations under a group and resolve them all at once:

```go
import "github.com/xraph/vessel"

forge.ProvideConstructor(app.Container(), NewEmailNotifier, vessel.AsGroup("notifiers"))
forge.ProvideConstructor(app.Container(), NewSlackNotifier, vessel.AsGroup("notifiers"))
forge.ProvideConstructor(app.Container(), NewSMSNotifier, vessel.AsGroup("notifiers"))

// Resolve all notifiers
notifiers, err := forge.InjectGroup[Notifier](app.Container(), "notifiers")
for _, n := range notifiers {
    n.Send("Application started")
}
```

## Lazy References

Lazy references let you break circular dependencies or defer resolution of expensive services:

```go
// Create a lazy reference (resolved on first .Get() call)
cacheRef := forge.NewLazyRef[*CacheClient](app.Container(), "cache")

// Later, when you need it:
cache, err := cacheRef.Get()
if err != nil {
    // Handle cache unavailable
}

// Optional lazy reference (returns nil without error if not found)
optRef := forge.NewOptionalLazyRef[*FeatureFlags](app.Container(), "featureFlags")
flags, _ := optRef.Get() // flags may be nil
```

## Type Checking

Check if a service is registered before resolving:

```go
if forge.HasType[*CacheClient](app.Container()) {
    cache, _ := forge.InjectType[*CacheClient](app.Container())
    // Use cache
}

if forge.HasTypeNamed[*Database](app.Container(), "replica") {
    // Replica database is available
}
```

## Registration Options

When registering services through `app.RegisterService()`, you can pass additional options:

```go
app.RegisterService("myService", factory,
    forge.Singleton(),                          // Lifetime
    forge.WithDependencies("database", "cache"), // Explicit dependency declaration
    forge.WithGroup("handlers"),                 // Add to a named group
    forge.WithDIMetadata("version", "2.0"),     // Diagnostic metadata
)
```

| Option | Description |
|---|---|
| `forge.Singleton()` | Service is created once and shared (default) |
| `forge.Transient()` | Service is created on every resolve |
| `forge.Scoped()` | Service is created once per scope |
| `forge.WithDependencies(names...)` | Declares dependencies for startup ordering |
| `forge.WithGroup(name)` | Adds the service to a named group |
| `forge.WithDIMetadata(key, value)` | Attaches diagnostic metadata |

## Next Steps

<Cards>
  <Card title="Lifecycle" href="/docs/forge/lifecycle">
    Use lifecycle hooks to register services at the right time during startup.
  </Card>
  <Card title="Architecture" href="/docs/forge/architecture">
    See how the DI container fits into the overall application structure.
  </Card>
  <Card title="Extensions System" href="/docs/forge/extensions-system">
    Build extensions that register their own services with the container.
  </Card>
</Cards>
