---
title: Introduction
description: What is Forge and why use it
icon: Hammer
---

import { Cards, Card } from 'fumadocs-ui/components/card';

Forge is a production-grade Go framework for building modular, extensible, and observable backend applications. It provides a batteries-included foundation with dependency injection, lifecycle management, automatic configuration, built-in observability, and a powerful routing system -- all while staying out of your way when you need to go beyond its defaults.

## Design Philosophy

Forge is built around four core principles:

- **Modular**: Every component is a well-defined interface. Swap out the router backend, logger, metrics provider, or configuration system without touching your application code.
- **Extensible**: The extension system lets you add capabilities (gRPC, GraphQL, Kafka, WebRTC, and more) as pluggable modules with automatic dependency resolution and lifecycle management.
- **Observable**: Health checks, metrics collection, and structured logging are first-class citizens. Built-in endpoints expose application state at `/_/info`, `/_/health`, and `/_/metrics`.
- **Developer-Friendly**: Sensible defaults get you running in seconds. Functional options, auto-discovered configuration files, and a clean handler signature (`func(ctx forge.Context) error`) keep boilerplate to a minimum.

## Key Features

<Cards>
  <Card title="Dependency Injection" href="/docs/forge/dependency-injection">
    Type-safe DI container powered by Vessel with singleton, transient, and scoped lifetimes.
  </Card>
  <Card title="Lifecycle Management" href="/docs/forge/lifecycle">
    Seven lifecycle phases with prioritized hooks for startup orchestration and graceful shutdown.
  </Card>
  <Card title="Configuration" href="/docs/forge/configuration">
    Auto-discovers YAML config files, supports local overrides, and reads environment variables.
  </Card>
  <Card title="Routing" href="/docs/forge/router">
    HTTP routing with groups, middleware, interceptors, WebSocket, SSE, and WebTransport support.
  </Card>
  <Card title="OpenAPI & AsyncAPI" href="/docs/forge/openapi">
    Automatic schema generation from route definitions with tag-based request classification.
  </Card>
  <Card title="Extension System" href="/docs/forge/extensions-system">
    Pluggable extensions for databases, message brokers, streaming, AI, and more.
  </Card>
</Cards>

## Who Is Forge For?

Forge is designed for teams building:

- **Microservices** that need structured lifecycle management, health checks, and observability from day one.
- **API servers** with automatic OpenAPI documentation and clean request/response handling.
- **Real-time applications** using WebSocket, SSE, or WebTransport with built-in AsyncAPI specs.
- **Modular monoliths** where extensions provide clear boundaries between subsystems.

## Quick Example

A complete Forge application in a few lines:

```go
package main

import "github.com/xraph/forge"

func main() {
    app := forge.New(
        forge.WithAppName("my-api"),
        forge.WithAppVersion("1.0.0"),
    )

    app.Router().GET("/hello", func(ctx forge.Context) error {
        return ctx.JSON(200, map[string]string{
            "message": "Hello from Forge!",
        })
    })

    app.Run()
}
```

Running this gives you an HTTP server on port 8080 with structured logging, health checks at `/_/health`, metrics at `/_/metrics`, and application info at `/_/info` -- all out of the box.

## Next Steps

<Cards>
  <Card title="Quick Start" href="/docs/forge/quick-start">
    Get up and running with Forge in 5 minutes.
  </Card>
  <Card title="Installation" href="/docs/forge/installation">
    Install Forge and configure your development environment.
  </Card>
  <Card title="Your First App" href="/docs/forge/first-app">
    Build a complete REST API step by step.
  </Card>
  <Card title="Forge CLI" href="/docs/forge/cli">
    Use `forge` commands for project bootstrap, development, generation, database, and deploy workflows.
  </Card>
</Cards>
