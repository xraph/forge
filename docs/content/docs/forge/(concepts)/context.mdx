---
title: Context
description: Request context with powerful features for handling HTTP requests and responses
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Tabs, Tab } from 'fumadocs-ui/components/tabs'

The Forge Context provides a powerful, type-safe interface for handling HTTP requests and responses. It wraps `http.Request` and `http.ResponseWriter` with convenient methods for common operations.

## Context Interface

Every handler receives a `forge.Context` instance:

```go
app.Router().GET("/users/:id", func(ctx forge.Context) error {
    // Access request, params, query, body, etc.
    id := ctx.Param("id")
    
    // Return response
    return ctx.JSON(200, user)
})
```

## Request Access

### Basic Request Data

```go
app.Router().GET("/info", func(ctx forge.Context) error {
    // Get HTTP request
    req := ctx.Request()
    
    // Access common properties
    method := req.Method
    path := req.URL.Path
    userAgent := req.UserAgent()
    
    // Get response writer
    w := ctx.Response()
    
    return ctx.JSON(200, map[string]string{
        "method": method,
        "path":   path,
    })
})
```

## Path Parameters

### Basic Parameters

```go
// Route: /users/:id
app.Router().GET("/users/:id", func(ctx forge.Context) error {
    id := ctx.Param("id")
    
    return ctx.JSON(200, map[string]string{"id": id})
})

// Multiple parameters
// Route: /users/:userId/posts/:postId
app.Router().GET("/users/:userId/posts/:postId", func(ctx forge.Context) error {
    userID := ctx.Param("userId")
    postID := ctx.Param("postId")
    
    // Get all parameters
    params := ctx.Params()
    
    return ctx.JSON(200, params)
})
```

### Type Conversion

Convert path parameters to specific types:

```go
app.Router().GET("/users/:id", func(ctx forge.Context) error {
    // Convert to int (returns error if invalid)
    id, err := ctx.ParamInt("id")
    if err != nil {
        return forge.BadRequest("invalid user ID")
    }
    
    // Convert to int64
    bigID, err := ctx.ParamInt64("id")
    
    // Convert to float64
    rating, err := ctx.ParamFloat64("rating")
    
    // Convert to bool
    active, err := ctx.ParamBool("active")
    
    return ctx.JSON(200, map[string]interface{}{"id": id})
})
```

### Parameters with Defaults

```go
app.Router().GET("/items/:page", func(ctx forge.Context) error {
    // Get int with default value (never errors)
    page := ctx.ParamIntDefault("page", 1)
    limit := ctx.ParamIntDefault("limit", 10)
    
    // Other types with defaults
    offset := ctx.ParamInt64Default("offset", 0)
    score := ctx.ParamFloat64Default("score", 0.0)
    active := ctx.ParamBoolDefault("active", true)
    
    return ctx.JSON(200, map[string]interface{}{
        "page":  page,
        "limit": limit,
    })
})
```

## Query Parameters

### Basic Query Access

```go
app.Router().GET("/search", func(ctx forge.Context) error {
    // Get query parameter
    q := ctx.Query("q")
    
    // Get with default value
    page := ctx.QueryDefault("page", "1")
    limit := ctx.QueryDefault("limit", "10")
    
    return ctx.JSON(200, map[string]string{
        "query": q,
        "page":  page,
        "limit": limit,
    })
})
```

## Request Body

### JSON Binding

```go
type CreateUserRequest struct {
    Name  string `json:"name" validate:"required"`
    Email string `json:"email" validate:"required,email"`
    Age   int    `json:"age" validate:"min=18"`
}

app.Router().POST("/users", func(ctx forge.Context) error {
    var req CreateUserRequest
    
    // Bind JSON body
    if err := ctx.BindJSON(&req); err != nil {
        return forge.BadRequest("invalid JSON")
    }
    
    // Validate (if using validator)
    if err := validate.Struct(req); err != nil {
        return forge.NewHTTPError(422, "validation failed")
    }
    
    return ctx.JSON(201, req)
})
```

### XML Binding

```go
type XMLUser struct {
    XMLName xml.Name `xml:"user"`
    Name    string   `xml:"name"`
    Email   string   `xml:"email"`
}

app.Router().POST("/users/xml", func(ctx forge.Context) error {
    var user XMLUser
    
    if err := ctx.BindXML(&user); err != nil {
        return forge.BadRequest("invalid XML")
    }
    
    return ctx.XML(200, user)
})
```

### Unified Request Binding

Bind data from all sources (path, query, headers, body):

```go
type UserRequest struct {
    // Path parameters
    ID string `path:"id" validate:"required"`
    
    // Query parameters
    Page   int  `query:"page" default:"1"`
    Limit  int  `query:"limit" default:"10"`
    Active bool `query:"active" default:"true"`
    
    // Headers
    APIKey    string `header:"X-API-Key" validate:"required"`
    UserAgent string `header:"User-Agent"`
    
    // Body
    Name  string `json:"name" body:"" validate:"required"`
    Email string `json:"email" body:"" validate:"required,email"`
}

app.Router().POST("/users/:id", func(ctx forge.Context) error {
    var req UserRequest
    
    // Automatically binds and validates all sources
    if err := ctx.BindRequest(&req); err != nil {
        return forge.BadRequest(err.Error())
    }
    
    return ctx.JSON(200, req)
})
```

<Callout type="info">
`BindRequest()` automatically handles:
- Path parameter extraction
- Query parameter parsing
- Header extraction
- JSON body parsing
- Type conversion
- Validation (if tags present)
</Callout>

## Multipart Forms

### File Uploads

```go
app.Router().POST("/upload", func(ctx forge.Context) error {
    // Parse multipart form (max 10MB)
    if err := ctx.ParseMultipartForm(10 << 20); err != nil {
        return forge.BadRequest("failed to parse form")
    }
    
    // Get single file
    file, header, err := ctx.FormFile("file")
    if err != nil {
        return forge.BadRequest("file required")
    }
    defer file.Close()
    
    // Process file
    data, err := io.ReadAll(file)
    if err != nil {
        return forge.InternalError("failed to read file")
    }
    
    return ctx.JSON(200, map[string]interface{}{
        "filename": header.Filename,
        "size":     header.Size,
        "uploaded": true,
    })
})
```

### Multiple Files

```go
app.Router().POST("/upload/multiple", func(ctx forge.Context) error {
    if err := ctx.ParseMultipartForm(50 << 20); err != nil { // 50MB
        return forge.BadRequest("failed to parse form")
    }
    
    // Get multiple files
    headers, err := ctx.FormFiles("files")
    if err != nil {
        return forge.BadRequest("files required")
    }
    
    results := make([]map[string]interface{}, 0, len(headers))
    
    for _, header := range headers {
        file, err := header.Open()
        if err != nil {
            continue
        }
        defer file.Close()
        
        // Process each file
        results = append(results, map[string]interface{}{
            "filename": header.Filename,
            "size":     header.Size,
        })
    }
    
    return ctx.JSON(200, results)
})
```

### Form Values

```go
app.Router().POST("/form", func(ctx forge.Context) error {
    if err := ctx.ParseMultipartForm(1 << 20); err != nil {
        return forge.BadRequest("failed to parse form")
    }
    
    // Get single form value
    name := ctx.FormValue("name")
    email := ctx.FormValue("email")
    
    // Get multiple values (e.g., checkboxes)
    tags := ctx.FormValues("tags")
    
    return ctx.JSON(200, map[string]interface{}{
        "name":  name,
        "email": email,
        "tags":  tags,
    })
})
```

## Response Helpers

### JSON Response

```go
app.Router().GET("/users", func(ctx forge.Context) error {
    users := []User{
        {ID: 1, Name: "John"},
        {ID: 2, Name: "Jane"},
    }
    
    return ctx.JSON(200, users)
})
```

### String Response

```go
app.Router().GET("/hello", func(ctx forge.Context) error {
    return ctx.String(200, "Hello, World!")
})
```

### Bytes Response

```go
app.Router().GET("/binary", func(ctx forge.Context) error {
    data := []byte{0x48, 0x65, 0x6c, 0x6c, 0x6f}
    return ctx.Bytes(200, data)
})
```

### No Content

```go
app.Router().DELETE("/users/:id", func(ctx forge.Context) error {
    id := ctx.Param("id")
    
    if err := userService.Delete(id); err != nil {
        return forge.InternalError("failed to delete")
    }
    
    return ctx.NoContent(204)
})
```

### Redirect

```go
app.Router().GET("/old-path", func(ctx forge.Context) error {
    return ctx.Redirect(301, "/new-path")
})
```

### Fluent Response Builder

Build responses with chaining:

```go
app.Router().GET("/custom", func(ctx forge.Context) error {
    return ctx.Status(200).
        Header("X-Custom", "value").
        Header("X-Rate-Limit", "100").
        JSON(map[string]string{
            "message": "success",
        })
})
```

## Headers

### Read Headers

```go
app.Router().GET("/info", func(ctx forge.Context) error {
    // Get header value
    auth := ctx.Header("Authorization")
    contentType := ctx.Header("Content-Type")
    userAgent := ctx.Header("User-Agent")
    
    return ctx.JSON(200, map[string]string{
        "auth":        auth,
        "contentType": contentType,
    })
})
```

### Set Headers

```go
app.Router().GET("/download", func(ctx forge.Context) error {
    // Set response headers
    ctx.SetHeader("Content-Type", "application/octet-stream")
    ctx.SetHeader("Content-Disposition", "attachment; filename=data.bin")
    ctx.SetHeader("X-Custom-Header", "custom-value")
    
    return ctx.Bytes(200, data)
})
```

## Context Values

Store and retrieve request-scoped data:

```go
// Middleware sets context values
func authMiddleware() forge.Middleware {
    return func(next forge.Handler) forge.Handler {
        return func(ctx forge.Context) error {
            // Authenticate and store user
            user := authenticateUser(ctx)
            
            ctx.Set("user_id", user.ID)
            ctx.Set("user_role", user.Role)
            ctx.Set("authenticated", true)
            
            return next(ctx)
        }
    }
}

// Handler retrieves context values
app.Router().GET("/profile", func(ctx forge.Context) error {
    // Get value (returns nil if not found)
    userID := ctx.Get("user_id")
    
    // MustGet panics if not found (use in non-critical paths)
    role := ctx.MustGet("user_role").(string)
    
    return ctx.JSON(200, map[string]interface{}{
        "user_id": userID,
        "role":    role,
    })
})
```

## Standard Context

Access Go's standard `context.Context`:

```go
app.Router().GET("/data", func(ctx forge.Context) error {
    // Get standard context
    stdCtx := ctx.Context()
    
    // Use with services
    data, err := service.GetData(stdCtx)
    if err != nil {
        return forge.InternalError("failed to get data")
    }
    
    return ctx.JSON(200, data)
})

// Replace context
func timeoutMiddleware(timeout time.Duration) forge.Middleware {
    return func(next forge.Handler) forge.Handler {
        return func(ctx forge.Context) error {
            stdCtx, cancel := context.WithTimeout(ctx.Context(), timeout)
            defer cancel()
            
            ctx.WithContext(stdCtx)
            
            return next(ctx)
        }
    }
}
```

## Dependency Injection

Access the DI container from context:

```go
app.Router().GET("/users", func(ctx forge.Context) error {
    // Get container
    container := ctx.Container()
    
    // Get scoped instance
    scope := ctx.Scope()
    
    // Resolve service by name
    svc, err := ctx.Resolve("userService")
    if err != nil {
        return forge.InternalError("service not found")
    }
    
    userService := svc.(*UserService)
    users, err := userService.List()
    
    // Or use Must (panics if not found)
    db := ctx.Must("database").(*sql.DB)
    
    return ctx.JSON(200, users)
})
```

## Cookies

### Read Cookies

```go
app.Router().GET("/check-cookie", func(ctx forge.Context) error {
    // Get cookie value
    token, err := ctx.Cookie("auth_token")
    if err != nil {
        return forge.Unauthorized("no auth token")
    }
    
    // Check if cookie exists
    if ctx.HasCookie("preferences") {
        prefs, _ := ctx.Cookie("preferences")
        // Use preferences
    }
    
    // Get all cookies
    allCookies := ctx.GetAllCookies()
    
    return ctx.JSON(200, map[string]interface{}{
        "token":   token,
        "cookies": allCookies,
    })
})
```

### Set Cookies

```go
app.Router().POST("/login", func(ctx forge.Context) error {
    // Simple cookie (session cookie)
    ctx.SetCookie("auth_token", "token_value", 0)
    
    // Cookie with max age (1 hour)
    ctx.SetCookie("session_id", "session_value", 3600)
    
    // Cookie with full options
    ctx.SetCookieWithOptions(
        "secure_token",
        "token_value",
        "/",           // path
        ".example.com", // domain
        3600,          // maxAge
        true,          // secure
        true,          // httpOnly
    )
    
    return ctx.JSON(200, map[string]string{
        "message": "logged in",
    })
})
```

### Delete Cookies

```go
app.Router().POST("/logout", func(ctx forge.Context) error {
    ctx.DeleteCookie("auth_token")
    ctx.DeleteCookie("session_id")
    
    return ctx.JSON(200, map[string]string{
        "message": "logged out",
    })
})
```

## Sessions

### Session Management

```go
app.Router().POST("/login", func(ctx forge.Context) error {
    // Get or create session
    session, err := ctx.Session()
    if err != nil {
        return forge.InternalError("session error")
    }
    
    // Set session values
    ctx.SetSessionValue("user_id", "123")
    ctx.SetSessionValue("username", "john")
    ctx.SetSessionValue("authenticated", true)
    
    // Save session
    if err := ctx.SaveSession(); err != nil {
        return forge.InternalError("failed to save session")
    }
    
    return ctx.JSON(200, map[string]string{
        "message": "logged in",
    })
})
```

### Access Session Data

```go
app.Router().GET("/profile", func(ctx forge.Context) error {
    // Get session value
    userID, exists := ctx.GetSessionValue("user_id")
    if !exists {
        return forge.Unauthorized("not authenticated")
    }
    
    username, _ := ctx.GetSessionValue("username")
    
    // Get session ID
    sessionID := ctx.SessionID()
    
    return ctx.JSON(200, map[string]interface{}{
        "user_id":    userID,
        "username":   username,
        "session_id": sessionID,
    })
})
```

### Destroy Session

```go
app.Router().POST("/logout", func(ctx forge.Context) error {
    // Delete specific session value
    ctx.DeleteSessionValue("user_id")
    
    // Or destroy entire session
    if err := ctx.DestroySession(); err != nil {
        return forge.InternalError("failed to destroy session")
    }
    
    return ctx.JSON(200, map[string]string{
        "message": "logged out",
    })
})
```

## Best Practices

<Callout type="info">
**Context Best Practices**

1. **Type Safety**: Use type assertions carefully with `Get()`
2. **Error Handling**: Always check errors from `BindJSON()`, `Cookie()`, etc.
3. **Request Validation**: Validate input using `BindRequest()` or validation libraries
4. **Context Values**: Use for request-scoped data, not global config
5. **Standard Context**: Pass `ctx.Context()` to services for cancellation
6. **Session Security**: Always use `secure` and `httpOnly` cookies in production
7. **Headers**: Set security headers (CORS, CSP, etc.) early
8. **Response Once**: Return only one response per request
</Callout>

## Complete Example

```go
package main

import (
    "github.com/xraph/forge"
    "github.com/xraph/forge/middleware"
)

type User struct {
    ID    string `json:"id"`
    Name  string `json:"name"`
    Email string `json:"email"`
}

type CreateUserRequest struct {
    // Body fields
    Name  string `json:"name" body:"" validate:"required,min=2"`
    Email string `json:"email" body:"" validate:"required,email"`
    
    // Header
    APIKey string `header:"X-API-Key" validate:"required"`
    
    // Query
    DryRun bool `query:"dry_run" default:"false"`
}

func main() {
    app := forge.New()
    
    // Middleware
    app.Router().Use(
        middleware.RequestID(),
        middleware.Recovery(app.Logger()),
        middleware.Logging(app.Logger()),
    )
    
    // Routes
    app.Router().POST("/users", func(ctx forge.Context) error {
        var req CreateUserRequest
        
        // Bind and validate all request data
        if err := ctx.BindRequest(&req); err != nil {
            return forge.BadRequest(err.Error())
        }
        
        // Access context values
        requestID := middleware.GetRequestIDFromForgeContext(ctx)
        ctx.Logger().Info("creating user",
            "request_id", requestID,
            "email", req.Email,
        )
        
        // Create user
        user := User{
            ID:    generateID(),
            Name:  req.Name,
            Email: req.Email,
        }
        
        // Set cookie
        ctx.SetCookie("user_id", user.ID, 3600)
        
        // Return response with custom header
        ctx.SetHeader("X-Request-ID", requestID)
        
        return ctx.JSON(201, user)
    })
    
    if err := app.Run(); err != nil {
        panic(err)
    }
}
```

## Next Steps

- Learn about [Middleware](/docs/forge/router/middleware) for request processing
- Explore [Error Handling](/docs/forge/concepts/error-handling) for proper error management
- Check [Dependency Injection](/docs/forge/concepts/dependency-injection) for service access

