---
title: MQTT Extension
description: MQTT broker integration for IoT and real-time messaging with publish/subscribe patterns
---

import { Card, Cards } from 'fumadocs-ui/components/card'
import { Callout } from 'fumadocs-ui/components/callout'
import { Tab, Tabs } from 'fumadocs-ui/components/tabs'

The MQTT Extension provides a complete MQTT broker integration for IoT applications, real-time messaging, and publish/subscribe patterns with support for QoS levels, retained messages, and last will and testament.

## Key Features

<Cards>
  <Card
    title="ðŸ“¡ Pub/Sub Messaging"
    description="Lightweight publish/subscribe messaging protocol"
  />
  <Card
    title="ðŸŽ¯ QoS Levels"
    description="Quality of Service levels 0, 1, and 2"
  />
  <Card
    title="ðŸ”„ Retained Messages"
    description="Store and deliver last known good values"
  />
  <Card
    title="ðŸ’” Last Will & Testament"
    description="Automatic notification of client disconnections"
  />
  <Card
    title="ðŸŒ IoT Ready"
    description="Optimized for IoT devices and constrained networks"
  />
  <Card
    title="ðŸ” Security"
    description="TLS encryption and authentication support"
  />
</Cards>

## Installation

```bash
go get github.com/xraph/forge/extensions/mqtt
go get github.com/eclipse/paho.mqtt.golang
```

## Basic Usage

<Tabs items={['Publisher', 'Subscriber', 'IoT Device', 'Broker Setup', 'Advanced Features']}>
  <Tab value="Publisher">
    ```go
    package main
    
    import (
        "context"
        "encoding/json"
        "fmt"
        "time"
        
        "github.com/xraph/forge/v2"
        "github.com/xraph/forge/v2/extensions/mqtt"
    )
    
    func main() {
        app := forge.NewApp(forge.AppConfig{
            Name: "mqtt-publisher",
        })
        
        // Register MQTT extension
        app.RegisterExtension(mqtt.NewExtension(
            mqtt.WithBroker("tcp://localhost:1883"),
            mqtt.WithClientID("sensor-gateway"),
            mqtt.WithCleanSession(true),
            mqtt.WithKeepAlive(30*time.Second),
            mqtt.WithAuth("username", "password"),
        ))
        
        // Get MQTT manager
        mqttManager := forge.GetService[mqtt.Manager](app.Container())
        
        // Create publisher
        publisher, err := mqttManager.NewPublisher()
        if err != nil {
            panic(err)
        }
        defer publisher.Close()
        
        ctx := context.Background()
        
        // Publish sensor data
        sensorData := SensorReading{
            DeviceID:    "sensor-001",
            Temperature: 23.5,
            Humidity:    65.2,
            Timestamp:   time.Now(),
            Location: Location{
                Latitude:  40.7128,
                Longitude: -74.0060,
            },
        }
        
        data, err := json.Marshal(sensorData)
        if err != nil {
            panic(err)
        }
        
        // Publish with QoS 1 (at least once delivery)
        err = publisher.Publish(ctx, mqtt.Message{
            Topic:   "sensors/temperature/sensor-001",
            Payload: data,
            QoS:     mqtt.QoS1,
            Retain:  true, // Retain last known value
        })
        if err != nil {
            panic(err)
        }
        
        // Publish device status
        status := DeviceStatus{
            DeviceID:  "sensor-001",
            Status:    "online",
            Battery:   85,
            Signal:    -45, // dBm
            Timestamp: time.Now(),
        }
        
        statusData, _ := json.Marshal(status)
        
        err = publisher.Publish(ctx, mqtt.Message{
            Topic:   "devices/status/sensor-001",
            Payload: statusData,
            QoS:     mqtt.QoS1,
            Retain:  true,
        })
        if err != nil {
            panic(err)
        }
        
        // Publish batch of readings
        readings := []SensorReading{}
        for i := 0; i < 10; i++ {
            reading := SensorReading{
                DeviceID:    fmt.Sprintf("sensor-%03d", i+1),
                Temperature: 20.0 + float64(i)*0.5,
                Humidity:    60.0 + float64(i)*1.0,
                Timestamp:   time.Now().Add(time.Duration(i) * time.Second),
            }
            readings = append(readings, reading)
        }
        
        // Publish readings to different topics
        for _, reading := range readings {
            topic := fmt.Sprintf("sensors/temperature/%s", reading.DeviceID)
            data, _ := json.Marshal(reading)
            
            err = publisher.Publish(ctx, mqtt.Message{
                Topic:   topic,
                Payload: data,
                QoS:     mqtt.QoS0, // Fire and forget for bulk data
            })
            if err != nil {
                log.Printf("Failed to publish reading for %s: %v", reading.DeviceID, err)
            }
        }
        
        // Publish alert with high QoS
        alert := Alert{
            DeviceID:  "sensor-001",
            Type:      "temperature_high",
            Message:   "Temperature exceeded threshold",
            Severity:  "critical",
            Value:     45.2,
            Threshold: 40.0,
            Timestamp: time.Now(),
        }
        
        alertData, _ := json.Marshal(alert)
        
        err = publisher.Publish(ctx, mqtt.Message{
            Topic:   "alerts/temperature",
            Payload: alertData,
            QoS:     mqtt.QoS2, // Exactly once delivery for critical alerts
        })
        if err != nil {
            panic(err)
        }
        
        log.Println("Published sensor data and alerts")
        
        app.Run()
    }
    
    type SensorReading struct {
        DeviceID    string    `json:"device_id"`
        Temperature float64   `json:"temperature"`
        Humidity    float64   `json:"humidity"`
        Timestamp   time.Time `json:"timestamp"`
        Location    Location  `json:"location,omitempty"`
    }
    
    type Location struct {
        Latitude  float64 `json:"latitude"`
        Longitude float64 `json:"longitude"`
    }
    
    type DeviceStatus struct {
        DeviceID  string    `json:"device_id"`
        Status    string    `json:"status"`
        Battery   int       `json:"battery"`
        Signal    int       `json:"signal"`
        Timestamp time.Time `json:"timestamp"`
    }
    
    type Alert struct {
        DeviceID  string    `json:"device_id"`
        Type      string    `json:"type"`
        Message   string    `json:"message"`
        Severity  string    `json:"severity"`
        Value     float64   `json:"value"`
        Threshold float64   `json:"threshold"`
        Timestamp time.Time `json:"timestamp"`
    }
    ```
  </Tab>
  <Tab value="Subscriber">
    ```go
    package main
    
    import (
        "context"
        "encoding/json"
        "log"
        "strings"
        
        "github.com/xraph/forge/v2"
        "github.com/xraph/forge/v2/extensions/mqtt"
        "github.com/xraph/forge/v2/extensions/database"
    )
    
    func main() {
        app := forge.NewApp(forge.AppConfig{
            Name: "mqtt-subscriber",
        })
        
        // Register extensions
        app.RegisterExtension(database.NewExtension(
            database.WithPostgreSQL("postgres://localhost/iot_db"),
        ))
        
        app.RegisterExtension(mqtt.NewExtension(
            mqtt.WithBroker("tcp://localhost:1883"),
            mqtt.WithClientID("data-processor"),
            mqtt.WithCleanSession(false), // Persistent session
            mqtt.WithAuth("username", "password"),
            mqtt.WithLastWill(mqtt.LastWill{
                Topic:   "system/status/data-processor",
                Message: []byte(`{"status":"offline","timestamp":"` + time.Now().Format(time.RFC3339) + `"}`),
                QoS:     mqtt.QoS1,
                Retain:  true,
            }),
        ))
        
        mqttManager := forge.GetService[mqtt.Manager](app.Container())
        dbManager := forge.GetService[database.Manager](app.Container())
        
        // Create subscriber
        subscriber, err := mqttManager.NewSubscriber()
        if err != nil {
            panic(err)
        }
        defer subscriber.Close()
        
        // Create message handlers
        handlers := &MessageHandlers{
            db: dbManager,
        }
        
        ctx := context.Background()
        
        // Subscribe to sensor data with different QoS levels
        subscriptions := []mqtt.Subscription{
            {
                Topic:   "sensors/+/+",           // All sensor data
                QoS:     mqtt.QoS1,
                Handler: handlers.HandleSensorData,
            },
            {
                Topic:   "devices/status/+",      // Device status updates
                QoS:     mqtt.QoS1,
                Handler: handlers.HandleDeviceStatus,
            },
            {
                Topic:   "alerts/+",              // All alerts
                QoS:     mqtt.QoS2,               // Critical alerts need exactly once
                Handler: handlers.HandleAlert,
            },
            {
                Topic:   "commands/+/+",          // Device commands
                QoS:     mqtt.QoS1,
                Handler: handlers.HandleCommand,
            },
            {
                Topic:   "system/+/+",            // System messages
                QoS:     mqtt.QoS0,
                Handler: handlers.HandleSystemMessage,
            },
        }
        
        // Subscribe to all topics
        err = subscriber.SubscribeMultiple(ctx, subscriptions)
        if err != nil {
            panic(err)
        }
        
        // Publish online status
        publisher, _ := mqttManager.NewPublisher()
        onlineStatus := map[string]interface{}{
            "status":    "online",
            "timestamp": time.Now().Format(time.RFC3339),
            "version":   "1.0.0",
        }
        statusData, _ := json.Marshal(onlineStatus)
        
        publisher.Publish(ctx, mqtt.Message{
            Topic:   "system/status/data-processor",
            Payload: statusData,
            QoS:     mqtt.QoS1,
            Retain:  true,
        })
        
        log.Println("MQTT subscriber started, waiting for messages...")
        
        app.Run()
    }
    
    type MessageHandlers struct {
        db database.Manager
    }
    
    func (h *MessageHandlers) HandleSensorData(ctx context.Context, msg mqtt.Message) error {
        log.Printf("Received sensor data on topic: %s", msg.Topic)
        
        // Parse topic to extract device info
        parts := strings.Split(msg.Topic, "/")
        if len(parts) < 3 {
            return fmt.Errorf("invalid sensor topic format: %s", msg.Topic)
        }
        
        sensorType := parts[1] // temperature, humidity, etc.
        deviceID := parts[2]
        
        // Parse message payload
        var reading SensorReading
        if err := json.Unmarshal(msg.Payload, &reading); err != nil {
            log.Printf("Failed to parse sensor data: %v", err)
            return err
        }
        
        // Validate reading
        if reading.DeviceID != deviceID {
            log.Printf("Device ID mismatch: topic=%s, payload=%s", deviceID, reading.DeviceID)
        }
        
        // Store in database
        err := h.storeSensorReading(ctx, sensorType, reading)
        if err != nil {
            log.Printf("Failed to store sensor reading: %v", err)
            return err
        }
        
        // Check for alerts
        if sensorType == "temperature" && reading.Temperature > 40.0 {
            h.triggerTemperatureAlert(ctx, reading)
        }
        
        log.Printf("Processed %s reading from %s: %.2f", sensorType, deviceID, reading.Temperature)
        return nil
    }
    
    func (h *MessageHandlers) HandleDeviceStatus(ctx context.Context, msg mqtt.Message) error {
        log.Printf("Received device status on topic: %s", msg.Topic)
        
        // Extract device ID from topic
        parts := strings.Split(msg.Topic, "/")
        if len(parts) < 3 {
            return fmt.Errorf("invalid status topic format: %s", msg.Topic)
        }
        
        deviceID := parts[2]
        
        // Parse status message
        var status DeviceStatus
        if err := json.Unmarshal(msg.Payload, &status); err != nil {
            log.Printf("Failed to parse device status: %v", err)
            return err
        }
        
        // Update device status in database
        err := h.updateDeviceStatus(ctx, deviceID, status)
        if err != nil {
            log.Printf("Failed to update device status: %v", err)
            return err
        }
        
        // Check for low battery
        if status.Battery < 20 {
            h.triggerLowBatteryAlert(ctx, status)
        }
        
        log.Printf("Updated status for device %s: %s (battery: %d%%)", deviceID, status.Status, status.Battery)
        return nil
    }
    
    func (h *MessageHandlers) HandleAlert(ctx context.Context, msg mqtt.Message) error {
        log.Printf("Received alert on topic: %s", msg.Topic)
        
        // Parse alert
        var alert Alert
        if err := json.Unmarshal(msg.Payload, &alert); err != nil {
            log.Printf("Failed to parse alert: %v", err)
            return err
        }
        
        // Store alert in database
        err := h.storeAlert(ctx, alert)
        if err != nil {
            log.Printf("Failed to store alert: %v", err)
            return err
        }
        
        // Send notifications for critical alerts
        if alert.Severity == "critical" {
            h.sendNotification(ctx, alert)
        }
        
        log.Printf("Processed %s alert from %s: %s", alert.Severity, alert.DeviceID, alert.Message)
        return nil
    }
    
    func (h *MessageHandlers) HandleCommand(ctx context.Context, msg mqtt.Message) error {
        log.Printf("Received command on topic: %s", msg.Topic)
        
        // Parse topic to extract device and command type
        parts := strings.Split(msg.Topic, "/")
        if len(parts) < 3 {
            return fmt.Errorf("invalid command topic format: %s", msg.Topic)
        }
        
        deviceID := parts[1]
        commandType := parts[2]
        
        // Parse command payload
        var command map[string]interface{}
        if err := json.Unmarshal(msg.Payload, &command); err != nil {
            log.Printf("Failed to parse command: %v", err)
            return err
        }
        
        // Process command based on type
        switch commandType {
        case "config":
            return h.handleConfigCommand(ctx, deviceID, command)
        case "restart":
            return h.handleRestartCommand(ctx, deviceID, command)
        case "update":
            return h.handleUpdateCommand(ctx, deviceID, command)
        default:
            log.Printf("Unknown command type: %s", commandType)
            return nil
        }
    }
    
    func (h *MessageHandlers) HandleSystemMessage(ctx context.Context, msg mqtt.Message) error {
        log.Printf("Received system message on topic: %s", msg.Topic)
        
        // Parse system message
        var sysMsg map[string]interface{}
        if err := json.Unmarshal(msg.Payload, &sysMsg); err != nil {
            log.Printf("Failed to parse system message: %v", err)
            return err
        }
        
        // Log system events
        log.Printf("System message: %+v", sysMsg)
        
        return nil
    }
    
    // Database operations
    func (h *MessageHandlers) storeSensorReading(ctx context.Context, sensorType string, reading SensorReading) error {
        query := `
            INSERT INTO sensor_readings (device_id, sensor_type, temperature, humidity, timestamp, location)
            VALUES ($1, $2, $3, $4, $5, $6)
        `
        
        var location *string
        if reading.Location.Latitude != 0 || reading.Location.Longitude != 0 {
            locationJSON, _ := json.Marshal(reading.Location)
            locationStr := string(locationJSON)
            location = &locationStr
        }
        
        _, err := h.db.Exec(ctx, query,
            reading.DeviceID,
            sensorType,
            reading.Temperature,
            reading.Humidity,
            reading.Timestamp,
            location,
        )
        
        return err
    }
    
    func (h *MessageHandlers) updateDeviceStatus(ctx context.Context, deviceID string, status DeviceStatus) error {
        query := `
            INSERT INTO device_status (device_id, status, battery, signal, timestamp)
            VALUES ($1, $2, $3, $4, $5)
            ON CONFLICT (device_id) DO UPDATE SET
                status = EXCLUDED.status,
                battery = EXCLUDED.battery,
                signal = EXCLUDED.signal,
                timestamp = EXCLUDED.timestamp
        `
        
        _, err := h.db.Exec(ctx, query,
            status.DeviceID,
            status.Status,
            status.Battery,
            status.Signal,
            status.Timestamp,
        )
        
        return err
    }
    
    func (h *MessageHandlers) storeAlert(ctx context.Context, alert Alert) error {
        query := `
            INSERT INTO alerts (device_id, type, message, severity, value, threshold, timestamp)
            VALUES ($1, $2, $3, $4, $5, $6, $7)
        `
        
        _, err := h.db.Exec(ctx, query,
            alert.DeviceID,
            alert.Type,
            alert.Message,
            alert.Severity,
            alert.Value,
            alert.Threshold,
            alert.Timestamp,
        )
        
        return err
    }
    
    // Alert handlers
    func (h *MessageHandlers) triggerTemperatureAlert(ctx context.Context, reading SensorReading) {
        log.Printf("Temperature alert triggered for device %s: %.2fÂ°C", reading.DeviceID, reading.Temperature)
        // Implement alert logic (email, SMS, webhook, etc.)
    }
    
    func (h *MessageHandlers) triggerLowBatteryAlert(ctx context.Context, status DeviceStatus) {
        log.Printf("Low battery alert for device %s: %d%%", status.DeviceID, status.Battery)
        // Implement alert logic
    }
    
    func (h *MessageHandlers) sendNotification(ctx context.Context, alert Alert) {
        log.Printf("Sending critical alert notification: %s", alert.Message)
        // Implement notification logic (email, Slack, PagerDuty, etc.)
    }
    
    // Command handlers
    func (h *MessageHandlers) handleConfigCommand(ctx context.Context, deviceID string, command map[string]interface{}) error {
        log.Printf("Handling config command for device %s: %+v", deviceID, command)
        // Implement configuration update logic
        return nil
    }
    
    func (h *MessageHandlers) handleRestartCommand(ctx context.Context, deviceID string, command map[string]interface{}) error {
        log.Printf("Handling restart command for device %s", deviceID)
        // Implement restart logic
        return nil
    }
    
    func (h *MessageHandlers) handleUpdateCommand(ctx context.Context, deviceID string, command map[string]interface{}) error {
        log.Printf("Handling update command for device %s: %+v", deviceID, command)
        // Implement firmware update logic
        return nil
    }
    ```
  </Tab>
  <Tab value="IoT Device">
    ```go
    package main
    
    import (
        "context"
        "encoding/json"
        "math/rand"
        "time"
        
        "github.com/xraph/forge/v2"
        "github.com/xraph/forge/v2/extensions/mqtt"
    )
    
    func main() {
        app := forge.NewApp(forge.AppConfig{
            Name: "iot-device-simulator",
        })
        
        // Register MQTT extension with device-specific settings
        app.RegisterExtension(mqtt.NewExtension(
            mqtt.WithBroker("tcp://localhost:1883"),
            mqtt.WithClientID("device-sensor-001"),
            mqtt.WithCleanSession(false), // Persistent session for reliability
            mqtt.WithKeepAlive(60*time.Second),
            mqtt.WithAuth("device-001", "device-password"),
            mqtt.WithAutoReconnect(true),
            mqtt.WithMaxReconnectInterval(5*time.Minute),
            mqtt.WithLastWill(mqtt.LastWill{
                Topic:   "devices/status/sensor-001",
                Message: []byte(`{"status":"offline","reason":"unexpected_disconnect"}`),
                QoS:     mqtt.QoS1,
                Retain:  true,
            }),
        ))
        
        mqttManager := forge.GetService[mqtt.Manager](app.Container())
        
        // Create device simulator
        device := &IoTDevice{
            DeviceID:  "sensor-001",
            Type:      "environmental",
            Location:  "Building A, Floor 2, Room 201",
            mqtt:      mqttManager,
        }
        
        ctx := context.Background()
        
        // Initialize device
        err := device.Initialize(ctx)
        if err != nil {
            panic(err)
        }
        defer device.Shutdown(ctx)
        
        // Start device operations
        device.Start(ctx)
        
        app.Run()
    }
    
    type IoTDevice struct {
        DeviceID    string
        Type        string
        Location    string
        mqtt        mqtt.Manager
        publisher   mqtt.Publisher
        subscriber  mqtt.Subscriber
        
        // Device state
        isOnline    bool
        battery     int
        temperature float64
        humidity    float64
        lastReading time.Time
        
        // Configuration
        config DeviceConfig
    }
    
    type DeviceConfig struct {
        ReadingInterval    time.Duration `json:"reading_interval"`
        ReportingInterval  time.Duration `json:"reporting_interval"`
        TemperatureOffset  float64       `json:"temperature_offset"`
        HumidityOffset     float64       `json:"humidity_offset"`
        AlertThresholds    AlertThresholds `json:"alert_thresholds"`
    }
    
    type AlertThresholds struct {
        TemperatureMin float64 `json:"temperature_min"`
        TemperatureMax float64 `json:"temperature_max"`
        HumidityMin    float64 `json:"humidity_min"`
        HumidityMax    float64 `json:"humidity_max"`
        BatteryMin     int     `json:"battery_min"`
    }
    
    func (d *IoTDevice) Initialize(ctx context.Context) error {
        var err error
        
        // Create publisher
        d.publisher, err = d.mqtt.NewPublisher()
        if err != nil {
            return fmt.Errorf("failed to create publisher: %w", err)
        }
        
        // Create subscriber
        d.subscriber, err = d.mqtt.NewSubscriber()
        if err != nil {
            return fmt.Errorf("failed to create subscriber: %w", err)
        }
        
        // Set default configuration
        d.config = DeviceConfig{
            ReadingInterval:   30 * time.Second,
            ReportingInterval: 5 * time.Minute,
            TemperatureOffset: 0.0,
            HumidityOffset:    0.0,
            AlertThresholds: AlertThresholds{
                TemperatureMin: 10.0,
                TemperatureMax: 35.0,
                HumidityMin:    30.0,
                HumidityMax:    80.0,
                BatteryMin:     20,
            },
        }
        
        // Initialize device state
        d.isOnline = true
        d.battery = 100
        d.temperature = 22.0
        d.humidity = 50.0
        
        // Subscribe to device commands
        commandTopic := fmt.Sprintf("commands/%s/+", d.DeviceID)
        err = d.subscriber.Subscribe(ctx, mqtt.Subscription{
            Topic:   commandTopic,
            QoS:     mqtt.QoS1,
            Handler: d.handleCommand,
        })
        if err != nil {
            return fmt.Errorf("failed to subscribe to commands: %w", err)
        }
        
        // Subscribe to configuration updates
        configTopic := fmt.Sprintf("config/%s", d.DeviceID)
        err = d.subscriber.Subscribe(ctx, mqtt.Subscription{
            Topic:   configTopic,
            QoS:     mqtt.QoS1,
            Handler: d.handleConfigUpdate,
        })
        if err != nil {
            return fmt.Errorf("failed to subscribe to config: %w", err)
        }
        
        // Publish device online status
        err = d.publishStatus(ctx, "online", "Device initialized successfully")
        if err != nil {
            return fmt.Errorf("failed to publish online status: %w", err)
        }
        
        log.Printf("IoT Device %s initialized successfully", d.DeviceID)
        return nil
    }
    
    func (d *IoTDevice) Start(ctx context.Context) {
        // Start sensor reading goroutine
        go d.sensorReadingLoop(ctx)
        
        // Start status reporting goroutine
        go d.statusReportingLoop(ctx)
        
        // Start battery simulation goroutine
        go d.batterySimulationLoop(ctx)
        
        log.Printf("IoT Device %s started", d.DeviceID)
    }
    
    func (d *IoTDevice) sensorReadingLoop(ctx context.Context) {
        ticker := time.NewTicker(d.config.ReadingInterval)
        defer ticker.Stop()
        
        for {
            select {
            case <-ctx.Done():
                return
            case <-ticker.C:
                d.takeSensorReading(ctx)
            }
        }
    }
    
    func (d *IoTDevice) takeSensorReading(ctx context.Context) {
        // Simulate sensor readings with some randomness
        d.temperature = 22.0 + (rand.Float64()-0.5)*10.0 + d.config.TemperatureOffset
        d.humidity = 50.0 + (rand.Float64()-0.5)*30.0 + d.config.HumidityOffset
        d.lastReading = time.Now()
        
        // Create sensor reading
        reading := SensorReading{
            DeviceID:    d.DeviceID,
            Temperature: d.temperature,
            Humidity:    d.humidity,
            Timestamp:   d.lastReading,
            Location: Location{
                Latitude:  40.7128 + (rand.Float64()-0.5)*0.01,
                Longitude: -74.0060 + (rand.Float64()-0.5)*0.01,
            },
        }
        
        // Publish temperature reading
        d.publishSensorData(ctx, "temperature", reading)
        
        // Check for alerts
        d.checkAlerts(ctx, reading)
        
        log.Printf("Sensor reading: T=%.1fÂ°C, H=%.1f%%", d.temperature, d.humidity)
    }
    
    func (d *IoTDevice) publishSensorData(ctx context.Context, sensorType string, reading SensorReading) {
        topic := fmt.Sprintf("sensors/%s/%s", sensorType, d.DeviceID)
        
        data, err := json.Marshal(reading)
        if err != nil {
            log.Printf("Failed to marshal sensor data: %v", err)
            return
        }
        
        err = d.publisher.Publish(ctx, mqtt.Message{
            Topic:   topic,
            Payload: data,
            QoS:     mqtt.QoS1,
            Retain:  true, // Retain last known value
        })
        if err != nil {
            log.Printf("Failed to publish sensor data: %v", err)
        }
    }
    
    func (d *IoTDevice) checkAlerts(ctx context.Context, reading SensorReading) {
        thresholds := d.config.AlertThresholds
        
        // Check temperature alerts
        if reading.Temperature < thresholds.TemperatureMin {
            d.publishAlert(ctx, "temperature_low", fmt.Sprintf("Temperature below minimum: %.1fÂ°C", reading.Temperature), "warning")
        } else if reading.Temperature > thresholds.TemperatureMax {
            d.publishAlert(ctx, "temperature_high", fmt.Sprintf("Temperature above maximum: %.1fÂ°C", reading.Temperature), "critical")
        }
        
        // Check humidity alerts
        if reading.Humidity < thresholds.HumidityMin {
            d.publishAlert(ctx, "humidity_low", fmt.Sprintf("Humidity below minimum: %.1f%%", reading.Humidity), "warning")
        } else if reading.Humidity > thresholds.HumidityMax {
            d.publishAlert(ctx, "humidity_high", fmt.Sprintf("Humidity above maximum: %.1f%%", reading.Humidity), "warning")
        }
        
        // Check battery alerts
        if d.battery < thresholds.BatteryMin {
            d.publishAlert(ctx, "battery_low", fmt.Sprintf("Battery level low: %d%%", d.battery), "warning")
        }
    }
    
    func (d *IoTDevice) publishAlert(ctx context.Context, alertType, message, severity string) {
        alert := Alert{
            DeviceID:  d.DeviceID,
            Type:      alertType,
            Message:   message,
            Severity:  severity,
            Timestamp: time.Now(),
        }
        
        // Add specific values based on alert type
        switch alertType {
        case "temperature_low", "temperature_high":
            alert.Value = d.temperature
            alert.Threshold = d.config.AlertThresholds.TemperatureMax
        case "humidity_low", "humidity_high":
            alert.Value = d.humidity
            alert.Threshold = d.config.AlertThresholds.HumidityMax
        }
        
        data, err := json.Marshal(alert)
        if err != nil {
            log.Printf("Failed to marshal alert: %v", err)
            return
        }
        
        topic := fmt.Sprintf("alerts/%s", alertType)
        
        err = d.publisher.Publish(ctx, mqtt.Message{
            Topic:   topic,
            Payload: data,
            QoS:     mqtt.QoS2, // Exactly once for alerts
        })
        if err != nil {
            log.Printf("Failed to publish alert: %v", err)
        } else {
            log.Printf("Alert published: %s - %s", alertType, message)
        }
    }
    
    func (d *IoTDevice) statusReportingLoop(ctx context.Context) {
        ticker := time.NewTicker(d.config.ReportingInterval)
        defer ticker.Stop()
        
        for {
            select {
            case <-ctx.Done():
                return
            case <-ticker.C:
                d.publishDeviceStatus(ctx)
            }
        }
    }
    
    func (d *IoTDevice) publishDeviceStatus(ctx context.Context) {
        status := DeviceStatus{
            DeviceID:  d.DeviceID,
            Status:    "online",
            Battery:   d.battery,
            Signal:    -45 + rand.Intn(20), // Simulate signal strength variation
            Timestamp: time.Now(),
        }
        
        data, err := json.Marshal(status)
        if err != nil {
            log.Printf("Failed to marshal device status: %v", err)
            return
        }
        
        topic := fmt.Sprintf("devices/status/%s", d.DeviceID)
        
        err = d.publisher.Publish(ctx, mqtt.Message{
            Topic:   topic,
            Payload: data,
            QoS:     mqtt.QoS1,
            Retain:  true,
        })
        if err != nil {
            log.Printf("Failed to publish device status: %v", err)
        }
    }
    
    func (d *IoTDevice) batterySimulationLoop(ctx context.Context) {
        ticker := time.NewTicker(1 * time.Hour) // Simulate battery drain every hour
        defer ticker.Stop()
        
        for {
            select {
            case <-ctx.Done():
                return
            case <-ticker.C:
                if d.battery > 0 {
                    d.battery -= rand.Intn(3) + 1 // Drain 1-3% per hour
                    if d.battery < 0 {
                        d.battery = 0
                    }
                    log.Printf("Battery level: %d%%", d.battery)
                }
            }
        }
    }
    
    func (d *IoTDevice) handleCommand(ctx context.Context, msg mqtt.Message) error {
        log.Printf("Received command on topic: %s", msg.Topic)
        
        // Parse command from topic
        parts := strings.Split(msg.Topic, "/")
        if len(parts) < 3 {
            return fmt.Errorf("invalid command topic: %s", msg.Topic)
        }
        
        commandType := parts[2]
        
        // Parse command payload
        var command map[string]interface{}
        if err := json.Unmarshal(msg.Payload, &command); err != nil {
            log.Printf("Failed to parse command: %v", err)
            return err
        }
        
        // Handle different command types
        switch commandType {
        case "restart":
            return d.handleRestartCommand(ctx, command)
        case "config":
            return d.handleConfigCommand(ctx, command)
        case "calibrate":
            return d.handleCalibrateCommand(ctx, command)
        default:
            log.Printf("Unknown command type: %s", commandType)
            return nil
        }
    }
    
    func (d *IoTDevice) handleRestartCommand(ctx context.Context, command map[string]interface{}) error {
        log.Printf("Handling restart command: %+v", command)
        
        // Publish offline status
        d.publishStatus(ctx, "restarting", "Device restart initiated")
        
        // Simulate restart delay
        time.Sleep(5 * time.Second)
        
        // Reset device state
        d.battery = 100
        d.temperature = 22.0
        d.humidity = 50.0
        
        // Publish online status
        d.publishStatus(ctx, "online", "Device restarted successfully")
        
        return nil
    }
    
    func (d *IoTDevice) handleConfigCommand(ctx context.Context, command map[string]interface{}) error {
        log.Printf("Handling config command: %+v", command)
        
        // Update configuration based on command
        if interval, ok := command["reading_interval"]; ok {
            if intervalStr, ok := interval.(string); ok {
                if duration, err := time.ParseDuration(intervalStr); err == nil {
                    d.config.ReadingInterval = duration
                    log.Printf("Updated reading interval to %v", duration)
                }
            }
        }
        
        if tempOffset, ok := command["temperature_offset"]; ok {
            if offset, ok := tempOffset.(float64); ok {
                d.config.TemperatureOffset = offset
                log.Printf("Updated temperature offset to %.2f", offset)
            }
        }
        
        // Acknowledge configuration update
        ack := map[string]interface{}{
            "status":    "success",
            "message":   "Configuration updated",
            "timestamp": time.Now().Format(time.RFC3339),
        }
        
        ackData, _ := json.Marshal(ack)
        ackTopic := fmt.Sprintf("commands/%s/config/ack", d.DeviceID)
        
        return d.publisher.Publish(ctx, mqtt.Message{
            Topic:   ackTopic,
            Payload: ackData,
            QoS:     mqtt.QoS1,
        })
    }
    
    func (d *IoTDevice) handleCalibrateCommand(ctx context.Context, command map[string]interface{}) error {
        log.Printf("Handling calibrate command: %+v", command)
        
        // Simulate calibration process
        d.publishStatus(ctx, "calibrating", "Sensor calibration in progress")
        
        time.Sleep(10 * time.Second)
        
        // Reset offsets
        d.config.TemperatureOffset = 0.0
        d.config.HumidityOffset = 0.0
        
        d.publishStatus(ctx, "online", "Sensor calibration completed")
        
        return nil
    }
    
    func (d *IoTDevice) handleConfigUpdate(ctx context.Context, msg mqtt.Message) error {
        log.Printf("Received config update: %s", string(msg.Payload))
        
        var newConfig DeviceConfig
        if err := json.Unmarshal(msg.Payload, &newConfig); err != nil {
            log.Printf("Failed to parse config update: %v", err)
            return err
        }
        
        // Update device configuration
        d.config = newConfig
        
        log.Printf("Device configuration updated: %+v", d.config)
        
        return nil
    }
    
    func (d *IoTDevice) publishStatus(ctx context.Context, status, message string) error {
        statusMsg := map[string]interface{}{
            "status":    status,
            "message":   message,
            "timestamp": time.Now().Format(time.RFC3339),
            "battery":   d.battery,
        }
        
        data, err := json.Marshal(statusMsg)
        if err != nil {
            return err
        }
        
        topic := fmt.Sprintf("devices/status/%s", d.DeviceID)
        
        return d.publisher.Publish(ctx, mqtt.Message{
            Topic:   topic,
            Payload: data,
            QoS:     mqtt.QoS1,
            Retain:  true,
        })
    }
    
    func (d *IoTDevice) Shutdown(ctx context.Context) {
        log.Printf("Shutting down IoT Device %s", d.DeviceID)
        
        // Publish offline status
        d.publishStatus(ctx, "offline", "Device shutdown initiated")
        
        // Close MQTT connections
        if d.publisher != nil {
            d.publisher.Close()
        }
        if d.subscriber != nil {
            d.subscriber.Close()
        }
        
        log.Printf("IoT Device %s shutdown complete", d.DeviceID)
    }
    ```
  </Tab>
  <Tab value="Broker Setup">
    ```go
    package main
    
    import (
        "context"
        "crypto/tls"
        "time"
        
        "github.com/xraph/forge/v2"
        "github.com/xraph/forge/v2/extensions/mqtt"
    )
    
    func main() {
        app := forge.NewApp(forge.AppConfig{
            Name: "mqtt-broker-setup",
        })
        
        // Register MQTT extension with broker configuration
        app.RegisterExtension(mqtt.NewExtension(
            // Multiple broker URLs for high availability
            mqtt.WithBrokers([]string{
                "tcp://mqtt-1.example.com:1883",
                "tcp://mqtt-2.example.com:1883",
                "tcp://mqtt-3.example.com:1883",
            }),
            
            // TLS configuration for secure connections
            mqtt.WithTLS(&tls.Config{
                ServerName:         "mqtt.example.com",
                InsecureSkipVerify: false,
                MinVersion:         tls.VersionTLS12,
            }),
            
            // Authentication
            mqtt.WithAuth("client-username", "client-password"),
            
            // Client configuration
            mqtt.WithClientID("forge-app-001"),
            mqtt.WithCleanSession(false), // Persistent session
            mqtt.WithKeepAlive(60 * time.Second),
            mqtt.WithPingTimeout(10 * time.Second),
            mqtt.WithConnectTimeout(30 * time.Second),
            
            // Automatic reconnection
            mqtt.WithAutoReconnect(true),
            mqtt.WithMaxReconnectInterval(5 * time.Minute),
            mqtt.WithConnectRetryInterval(1 * time.Second),
            
            // Last Will and Testament
            mqtt.WithLastWill(mqtt.LastWill{
                Topic:   "clients/status/forge-app-001",
                Message: []byte(`{"status":"offline","reason":"unexpected_disconnect","timestamp":"` + time.Now().Format(time.RFC3339) + `"}`),
                QoS:     mqtt.QoS1,
                Retain:  true,
            }),
            
            // Message handling
            mqtt.WithMessageChannelDepth(1000),
            mqtt.WithResumeSubs(true),
            
            // Store configuration for persistent sessions
            mqtt.WithStore(mqtt.NewFileStore("/tmp/mqtt-store")),
            
            // Connection handlers
            mqtt.WithOnConnect(func(client mqtt.Client) {
                log.Println("Connected to MQTT broker")
                
                // Publish online status
                client.Publish("clients/status/forge-app-001", 1, true, 
                    `{"status":"online","timestamp":"`+time.Now().Format(time.RFC3339)+`"}`)
            }),
            
            mqtt.WithOnConnectionLost(func(client mqtt.Client, err error) {
                log.Printf("Connection lost: %v", err)
            }),
            
            mqtt.WithOnReconnecting(func(client mqtt.Client, options *mqtt.ClientOptions) {
                log.Println("Attempting to reconnect to MQTT broker")
            }),
        ))
        
        mqttManager := forge.GetService[mqtt.Manager](app.Container())
        
        // Test broker connection
        ctx := context.Background()
        
        // Create a test publisher
        publisher, err := mqttManager.NewPublisher()
        if err != nil {
            panic(err)
        }
        defer publisher.Close()
        
        // Create a test subscriber
        subscriber, err := mqttManager.NewSubscriber()
        if err != nil {
            panic(err)
        }
        defer subscriber.Close()
        
        // Test publish/subscribe
        testTopic := "test/connection"
        
        // Subscribe to test topic
        err = subscriber.Subscribe(ctx, mqtt.Subscription{
            Topic: testTopic,
            QoS:   mqtt.QoS1,
            Handler: func(ctx context.Context, msg mqtt.Message) error {
                log.Printf("Received test message: %s", string(msg.Payload))
                return nil
            },
        })
        if err != nil {
            panic(err)
        }
        
        // Publish test message
        err = publisher.Publish(ctx, mqtt.Message{
            Topic:   testTopic,
            Payload: []byte("Hello, MQTT!"),
            QoS:     mqtt.QoS1,
        })
        if err != nil {
            panic(err)
        }
        
        log.Println("MQTT broker setup complete")
        
        app.Run()
    }
    
    // Advanced broker configuration with clustering
    func setupClusteredBroker() {
        app := forge.NewApp(forge.AppConfig{Name: "mqtt-cluster"})
        
        app.RegisterExtension(mqtt.NewExtension(
            // Cluster configuration
            mqtt.WithCluster(mqtt.ClusterConfig{
                Nodes: []mqtt.BrokerNode{
                    {
                        URL:      "tcp://mqtt-node-1:1883",
                        Priority: 1,
                        Weight:   100,
                    },
                    {
                        URL:      "tcp://mqtt-node-2:1883",
                        Priority: 2,
                        Weight:   80,
                    },
                    {
                        URL:      "tcp://mqtt-node-3:1883",
                        Priority: 3,
                        Weight:   60,
                    },
                },
                LoadBalancing: mqtt.LoadBalanceRoundRobin,
                FailoverMode:  mqtt.FailoverAutomatic,
                HealthCheck: mqtt.HealthCheckConfig{
                    Interval: 30 * time.Second,
                    Timeout:  5 * time.Second,
                    Retries:  3,
                },
            }),
            
            // Connection pooling
            mqtt.WithConnectionPool(mqtt.ConnectionPoolConfig{
                MaxConnections:    10,
                MaxIdleTime:      5 * time.Minute,
                ConnectionTimeout: 30 * time.Second,
            }),
            
            // Message persistence
            mqtt.WithPersistence(mqtt.PersistenceConfig{
                Enabled:    true,
                Directory:  "/var/lib/mqtt/persistence",
                MaxSize:    100 * 1024 * 1024, // 100MB
                SyncPolicy: mqtt.SyncPolicyPeriodic,
                SyncInterval: 5 * time.Second,
            }),
            
            // Quality of Service settings
            mqtt.WithQoSSettings(mqtt.QoSSettings{
                MaxInflight:     20,
                MessageExpiry:   24 * time.Hour,
                RetryInterval:   30 * time.Second,
                MaxRetries:      3,
            }),
        ))
        
        app.Run()
    }
    
    // Embedded MQTT broker for testing
    func setupEmbeddedBroker() {
        app := forge.NewApp(forge.AppConfig{Name: "embedded-mqtt"})
        
        app.RegisterExtension(mqtt.NewExtension(
            mqtt.WithEmbeddedBroker(mqtt.EmbeddedBrokerConfig{
                Port:           1883,
                TLSPort:        8883,
                WebSocketPort:  8080,
                
                // Authentication
                AllowAnonymous: false,
                Users: map[string]string{
                    "admin":  "admin-password",
                    "device": "device-password",
                    "client": "client-password",
                },
                
                // ACL (Access Control List)
                ACL: []mqtt.ACLRule{
                    {
                        User:       "admin",
                        Topic:      "#",
                        Permission: mqtt.PermissionReadWrite,
                    },
                    {
                        User:       "device",
                        Topic:      "devices/+/+",
                        Permission: mqtt.PermissionWrite,
                    },
                    {
                        User:       "device",
                        Topic:      "commands/+/+",
                        Permission: mqtt.PermissionRead,
                    },
                    {
                        User:       "client",
                        Topic:      "sensors/+/+",
                        Permission: mqtt.PermissionRead,
                    },
                },
                
                // Persistence
                Persistence: mqtt.PersistenceConfig{
                    Enabled:   true,
                    Directory: "/tmp/embedded-mqtt",
                },
                
                // Limits
                MaxConnections:    1000,
                MaxMessageSize:    1024 * 1024, // 1MB
                MaxTopicLength:    256,
                MaxClientIDLength: 64,
                
                // Logging
                LogLevel: mqtt.LogLevelInfo,
                LogFile:  "/var/log/mqtt/broker.log",
            }),
        ))
        
        app.Run()
    }
    ```
  </Tab>
  <Tab value="Advanced Features">
    ```go
    package main
    
    import (
        "context"
        "encoding/json"
        "fmt"
        "time"
        
        "github.com/xraph/forge/v2"
        "github.com/xraph/forge/v2/extensions/mqtt"
        "github.com/xraph/forge/v2/extensions/cache"
    )
    
    func main() {
        app := forge.NewApp(forge.AppConfig{
            Name: "mqtt-advanced-features",
        })
        
        // Register extensions
        app.RegisterExtension(cache.NewExtension(
            cache.WithRedis("localhost:6379"),
        ))
        
        app.RegisterExtension(mqtt.NewExtension(
            mqtt.WithBroker("tcp://localhost:1883"),
            mqtt.WithClientID("advanced-client"),
            
            // Message filtering and routing
            mqtt.WithMessageFilters([]mqtt.MessageFilter{
                &TopicFilter{},
                &PayloadSizeFilter{MaxSize: 1024 * 1024}, // 1MB max
                &RateLimitFilter{MaxRate: 1000},           // 1000 msg/sec
            }),
            
            // Message transformation
            mqtt.WithMessageTransformers([]mqtt.MessageTransformer{
                &CompressionTransformer{},
                &EncryptionTransformer{Key: "encryption-key"},
                &ValidationTransformer{},
            }),
            
            // Advanced QoS handling
            mqtt.WithAdvancedQoS(mqtt.AdvancedQoSConfig{
                EnableDuplicateDetection: true,
                DuplicateWindow:         5 * time.Minute,
                EnableMessageOrdering:   true,
                OrderingWindow:          1 * time.Minute,
                EnableDeadLetterQueue:   true,
                DeadLetterTopic:         "dlq/messages",
                MaxRetries:              3,
            }),
        ))
        
        mqttManager := forge.GetService[mqtt.Manager](app.Container())
        cacheManager := forge.GetService[cache.Manager](app.Container())
        
        // Create advanced message processor
        processor := &AdvancedMessageProcessor{
            mqtt:  mqttManager,
            cache: cacheManager,
        }
        
        ctx := context.Background()
        
        // Start advanced processing
        processor.Start(ctx)
        
        app.Run()
    }
    
    type AdvancedMessageProcessor struct {
        mqtt  mqtt.Manager
        cache cache.Manager
    }
    
    func (p *AdvancedMessageProcessor) Start(ctx context.Context) {
        // Create subscriber with advanced features
        subscriber, err := p.mqtt.NewAdvancedSubscriber(mqtt.AdvancedSubscriberConfig{
            BufferSize:       10000,
            WorkerCount:      10,
            BatchSize:        100,
            BatchTimeout:     1 * time.Second,
            EnableMetrics:    true,
            EnableTracing:    true,
        })
        if err != nil {
            panic(err)
        }
        
        // Subscribe with message routing
        subscriptions := []mqtt.AdvancedSubscription{
            {
                Topic:   "sensors/+/temperature",
                QoS:     mqtt.QoS1,
                Handler: p.handleTemperatureData,
                Options: mqtt.SubscriptionOptions{
                    EnableBatching:    true,
                    BatchSize:        50,
                    EnableCompression: true,
                    EnableCaching:    true,
                    CacheTTL:         5 * time.Minute,
                },
            },
            {
                Topic:   "alerts/+",
                QoS:     mqtt.QoS2,
                Handler: p.handleAlerts,
                Options: mqtt.SubscriptionOptions{
                    Priority:         mqtt.PriorityHigh,
                    EnableDLQ:        true,
                    MaxRetries:       5,
                    RetryBackoff:     mqtt.ExponentialBackoff,
                },
            },
            {
                Topic:   "commands/+/+",
                QoS:     mqtt.QoS1,
                Handler: p.handleCommands,
                Options: mqtt.SubscriptionOptions{
                    EnableValidation: true,
                    Schema:          "command-schema.json",
                    EnableAudit:     true,
                },
            },
        }
        
        err = subscriber.SubscribeAdvanced(ctx, subscriptions)
        if err != nil {
            panic(err)
        }
        
        // Start message aggregation
        go p.startMessageAggregation(ctx)
        
        // Start pattern detection
        go p.startPatternDetection(ctx)
        
        log.Println("Advanced message processor started")
    }
    
    func (p *AdvancedMessageProcessor) handleTemperatureData(ctx context.Context, batch []mqtt.Message) error {
        log.Printf("Processing temperature batch: %d messages", len(batch))
        
        // Process messages in batch
        var readings []SensorReading
        for _, msg := range batch {
            var reading SensorReading
            if err := json.Unmarshal(msg.Payload, &reading); err != nil {
                log.Printf("Failed to parse temperature reading: %v", err)
                continue
            }
            readings = append(readings, reading)
        }
        
        // Aggregate readings
        aggregated := p.aggregateTemperatureReadings(readings)
        
        // Store in cache for quick access
        cacheKey := fmt.Sprintf("temp_aggregated_%d", time.Now().Unix()/300) // 5-minute windows
        err := p.cache.Set(ctx, cacheKey, aggregated, 1*time.Hour)
        if err != nil {
            log.Printf("Failed to cache aggregated data: %v", err)
        }
        
        // Detect anomalies
        anomalies := p.detectTemperatureAnomalies(readings)
        if len(anomalies) > 0 {
            p.publishAnomalyAlerts(ctx, anomalies)
        }
        
        return nil
    }
    
    func (p *AdvancedMessageProcessor) handleAlerts(ctx context.Context, msg mqtt.Message) error {
        log.Printf("Processing alert: %s", msg.Topic)
        
        var alert Alert
        if err := json.Unmarshal(msg.Payload, &alert); err != nil {
            return fmt.Errorf("failed to parse alert: %w", err)
        }
        
        // Enrich alert with additional context
        enrichedAlert := p.enrichAlert(ctx, alert)
        
        // Apply alert correlation
        correlatedAlerts := p.correlateAlerts(ctx, enrichedAlert)
        
        // Send notifications based on severity and correlation
        for _, correlatedAlert := range correlatedAlerts {
            if correlatedAlert.Severity == "critical" {
                p.sendImmediateNotification(ctx, correlatedAlert)
            } else {
                p.queueNotification(ctx, correlatedAlert)
            }
        }
        
        return nil
    }
    
    func (p *AdvancedMessageProcessor) handleCommands(ctx context.Context, msg mqtt.Message) error {
        log.Printf("Processing command: %s", msg.Topic)
        
        // Extract device ID and command type from topic
        parts := strings.Split(msg.Topic, "/")
        if len(parts) < 3 {
            return fmt.Errorf("invalid command topic: %s", msg.Topic)
        }
        
        deviceID := parts[1]
        commandType := parts[2]
        
        // Validate command
        if !p.validateCommand(ctx, deviceID, commandType, msg.Payload) {
            return fmt.Errorf("command validation failed")
        }
        
        // Log command for audit
        p.auditCommand(ctx, deviceID, commandType, msg.Payload)
        
        // Route command to appropriate handler
        switch commandType {
        case "config":
            return p.handleConfigCommand(ctx, deviceID, msg.Payload)
        case "firmware":
            return p.handleFirmwareCommand(ctx, deviceID, msg.Payload)
        case "diagnostic":
            return p.handleDiagnosticCommand(ctx, deviceID, msg.Payload)
        default:
            return fmt.Errorf("unknown command type: %s", commandType)
        }
    }
    
    func (p *AdvancedMessageProcessor) startMessageAggregation(ctx context.Context) {
        ticker := time.NewTicker(1 * time.Minute)
        defer ticker.Stop()
        
        for {
            select {
            case <-ctx.Done():
                return
            case <-ticker.C:
                p.performMessageAggregation(ctx)
            }
        }
    }
    
    func (p *AdvancedMessageProcessor) performMessageAggregation(ctx context.Context) {
        // Get recent temperature data from cache
        pattern := "temp_*"
        keys, err := p.cache.Keys(ctx, pattern)
        if err != nil {
            log.Printf("Failed to get cache keys: %v", err)
            return
        }
        
        var allReadings []SensorReading
        for _, key := range keys {
            var readings []SensorReading
            err := p.cache.Get(ctx, key, &readings)
            if err != nil {
                continue
            }
            allReadings = append(allReadings, readings...)
        }
        
        if len(allReadings) == 0 {
            return
        }
        
        // Perform aggregation
        aggregated := p.aggregateTemperatureReadings(allReadings)
        
        // Publish aggregated data
        publisher, err := p.mqtt.NewPublisher()
        if err != nil {
            log.Printf("Failed to create publisher: %v", err)
            return
        }
        defer publisher.Close()
        
        data, _ := json.Marshal(aggregated)
        
        err = publisher.Publish(ctx, mqtt.Message{
            Topic:   "analytics/temperature/aggregated",
            Payload: data,
            QoS:     mqtt.QoS1,
            Retain:  true,
        })
        if err != nil {
            log.Printf("Failed to publish aggregated data: %v", err)
        }
    }
    
    func (p *AdvancedMessageProcessor) startPatternDetection(ctx context.Context) {
        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()
        
        for {
            select {
            case <-ctx.Done():
                return
            case <-ticker.C:
                p.detectPatterns(ctx)
            }
        }
    }
    
    func (p *AdvancedMessageProcessor) detectPatterns(ctx context.Context) {
        // Implement pattern detection logic
        // - Seasonal patterns
        // - Anomaly detection
        // - Trend analysis
        // - Correlation analysis
        
        log.Println("Performing pattern detection...")
        
        // Example: Detect temperature trends
        trends := p.detectTemperatureTrends(ctx)
        if len(trends) > 0 {
            p.publishTrendAnalysis(ctx, trends)
        }
    }
    
    // Helper methods
    func (p *AdvancedMessageProcessor) aggregateTemperatureReadings(readings []SensorReading) TemperatureAggregation {
        if len(readings) == 0 {
            return TemperatureAggregation{}
        }
        
        var sum, min, max float64
        min = readings[0].Temperature
        max = readings[0].Temperature
        
        deviceCounts := make(map[string]int)
        
        for _, reading := range readings {
            sum += reading.Temperature
            if reading.Temperature < min {
                min = reading.Temperature
            }
            if reading.Temperature > max {
                max = reading.Temperature
            }
            deviceCounts[reading.DeviceID]++
        }
        
        return TemperatureAggregation{
            Count:       len(readings),
            Average:     sum / float64(len(readings)),
            Min:         min,
            Max:         max,
            DeviceCount: len(deviceCounts),
            Timestamp:   time.Now(),
        }
    }
    
    func (p *AdvancedMessageProcessor) detectTemperatureAnomalies(readings []SensorReading) []TemperatureAnomaly {
        var anomalies []TemperatureAnomaly
        
        // Simple anomaly detection based on standard deviation
        if len(readings) < 3 {
            return anomalies
        }
        
        // Calculate mean and standard deviation
        var sum float64
        for _, reading := range readings {
            sum += reading.Temperature
        }
        mean := sum / float64(len(readings))
        
        var variance float64
        for _, reading := range readings {
            variance += (reading.Temperature - mean) * (reading.Temperature - mean)
        }
        stdDev := math.Sqrt(variance / float64(len(readings)))
        
        // Flag readings that are more than 2 standard deviations from mean
        threshold := 2.0
        for _, reading := range readings {
            if math.Abs(reading.Temperature-mean) > threshold*stdDev {
                anomalies = append(anomalies, TemperatureAnomaly{
                    DeviceID:    reading.DeviceID,
                    Temperature: reading.Temperature,
                    Expected:    mean,
                    Deviation:   math.Abs(reading.Temperature - mean),
                    Timestamp:   reading.Timestamp,
                })
            }
        }
        
        return anomalies
    }
    
    type TemperatureAggregation struct {
        Count       int       `json:"count"`
        Average     float64   `json:"average"`
        Min         float64   `json:"min"`
        Max         float64   `json:"max"`
        DeviceCount int       `json:"device_count"`
        Timestamp   time.Time `json:"timestamp"`
    }
    
    type TemperatureAnomaly struct {
        DeviceID    string    `json:"device_id"`
        Temperature float64   `json:"temperature"`
        Expected    float64   `json:"expected"`
        Deviation   float64   `json:"deviation"`
        Timestamp   time.Time `json:"timestamp"`
    }
    ```
   </Tab>
 </Tabs>

## Configuration

<Tabs items={['YAML', 'Environment Variables', 'Functional Options']}>
  <Tab value="YAML">
    ```yaml
    mqtt:
      # Broker Configuration
      brokers:
        - "tcp://localhost:1883"
        - "tcp://backup-broker:1883"
      
      # Client Settings
      client_id: "forge-app-001"
      clean_session: false
      keep_alive: 60s
      ping_timeout: 10s
      connect_timeout: 30s
      
      # Authentication
      auth:
        username: "mqtt-user"
        password: "mqtt-password"
      
      # TLS Configuration
      tls:
        enabled: true
        server_name: "mqtt.example.com"
        insecure_skip_verify: false
        min_version: "1.2"
        cert_file: "/path/to/client.crt"
        key_file: "/path/to/client.key"
        ca_file: "/path/to/ca.crt"
      
      # Reconnection Settings
      auto_reconnect: true
      max_reconnect_interval: 5m
      connect_retry_interval: 1s
      
      # Last Will and Testament
      last_will:
        topic: "clients/status/forge-app-001"
        message: '{"status":"offline","reason":"unexpected_disconnect"}'
        qos: 1
        retain: true
      
      # Message Handling
      message_channel_depth: 1000
      resume_subs: true
      
      # Store Configuration
      store:
        type: "file"
        directory: "/tmp/mqtt-store"
      
      # Advanced Features
      advanced:
        enable_duplicate_detection: true
        duplicate_window: 5m
        enable_message_ordering: true
        ordering_window: 1m
        enable_dead_letter_queue: true
        dead_letter_topic: "dlq/messages"
        max_retries: 3
      
      # Connection Pool
      connection_pool:
        max_connections: 10
        max_idle_time: 5m
        connection_timeout: 30s
      
      # Quality of Service
      qos_settings:
        max_inflight: 20
        message_expiry: 24h
        retry_interval: 30s
        max_retries: 3
      
      # Monitoring
      monitoring:
        enabled: true
        metrics_interval: 30s
        health_check_interval: 60s
      
      # Logging
      logging:
        level: "info"
        enable_debug: false
        log_messages: false
    ```
  </Tab>
  <Tab value="Environment Variables">
    ```bash
    # Broker Configuration
    MQTT_BROKERS="tcp://localhost:1883,tcp://backup:1883"
    MQTT_CLIENT_ID="forge-app-001"
    MQTT_CLEAN_SESSION="false"
    MQTT_KEEP_ALIVE="60s"
    
    # Authentication
    MQTT_USERNAME="mqtt-user"
    MQTT_PASSWORD="mqtt-password"
    
    # TLS Configuration
    MQTT_TLS_ENABLED="true"
    MQTT_TLS_SERVER_NAME="mqtt.example.com"
    MQTT_TLS_CERT_FILE="/path/to/client.crt"
    MQTT_TLS_KEY_FILE="/path/to/client.key"
    MQTT_TLS_CA_FILE="/path/to/ca.crt"
    
    # Reconnection
    MQTT_AUTO_RECONNECT="true"
    MQTT_MAX_RECONNECT_INTERVAL="5m"
    
    # Last Will
    MQTT_LAST_WILL_TOPIC="clients/status/forge-app-001"
    MQTT_LAST_WILL_MESSAGE='{"status":"offline"}'
    MQTT_LAST_WILL_QOS="1"
    MQTT_LAST_WILL_RETAIN="true"
    
    # Advanced Features
    MQTT_ENABLE_DLQ="true"
    MQTT_DLQ_TOPIC="dlq/messages"
    MQTT_MAX_RETRIES="3"
    
    # Monitoring
    MQTT_MONITORING_ENABLED="true"
    MQTT_METRICS_INTERVAL="30s"
    ```
  </Tab>
  <Tab value="Functional Options">
    ```go
    app.RegisterExtension(mqtt.NewExtension(
        // Basic Configuration
        mqtt.WithBroker("tcp://localhost:1883"),
        mqtt.WithBrokers([]string{
            "tcp://primary:1883",
            "tcp://secondary:1883",
        }),
        mqtt.WithClientID("forge-app"),
        mqtt.WithCleanSession(false),
        mqtt.WithKeepAlive(60*time.Second),
        
        // Authentication
        mqtt.WithAuth("username", "password"),
        mqtt.WithCertAuth("/path/to/cert.pem", "/path/to/key.pem"),
        
        // TLS Configuration
        mqtt.WithTLS(&tls.Config{
            ServerName: "mqtt.example.com",
            MinVersion: tls.VersionTLS12,
        }),
        
        // Reconnection
        mqtt.WithAutoReconnect(true),
        mqtt.WithMaxReconnectInterval(5*time.Minute),
        
        // Last Will and Testament
        mqtt.WithLastWill(mqtt.LastWill{
            Topic:   "status/offline",
            Message: []byte("offline"),
            QoS:     mqtt.QoS1,
            Retain:  true,
        }),
        
        // Message Handling
        mqtt.WithMessageChannelDepth(1000),
        mqtt.WithResumeSubs(true),
        
        // Store Configuration
        mqtt.WithStore(mqtt.NewFileStore("/tmp/mqtt")),
        mqtt.WithStore(mqtt.NewMemoryStore()),
        
        // Advanced Features
        mqtt.WithAdvancedQoS(mqtt.AdvancedQoSConfig{
            EnableDuplicateDetection: true,
            DuplicateWindow:         5*time.Minute,
            EnableDeadLetterQueue:   true,
            DeadLetterTopic:         "dlq/messages",
        }),
        
        // Connection Handlers
        mqtt.WithOnConnect(func(client mqtt.Client) {
            log.Println("Connected to MQTT broker")
        }),
        mqtt.WithOnConnectionLost(func(client mqtt.Client, err error) {
            log.Printf("Connection lost: %v", err)
        }),
        
        // Monitoring
        mqtt.WithMonitoring(mqtt.MonitoringConfig{
            Enabled:         true,
            MetricsInterval: 30*time.Second,
        }),
    ))
     ```
   </Tab>
 </Tabs>

## MQTT Manager Interface

The MQTT extension provides a comprehensive manager interface for all MQTT operations:

```go
type MQTTManager interface {
    // Connection Management
    Connect(ctx context.Context) error
    Disconnect(ctx context.Context) error
    IsConnected() bool
    
    // Publishing
    Publish(ctx context.Context, topic string, payload []byte, qos QoS) error
    PublishRetained(ctx context.Context, topic string, payload []byte, qos QoS) error
    PublishWithOptions(ctx context.Context, opts PublishOptions) error
    
    // Subscribing
    Subscribe(ctx context.Context, topic string, qos QoS, handler MessageHandler) error
    SubscribeMultiple(ctx context.Context, filters map[string]QoS, handler MessageHandler) error
    Unsubscribe(ctx context.Context, topics ...string) error
    
    // Message Handling
    SetDefaultHandler(handler MessageHandler)
    SetConnectionHandler(handler ConnectionHandler)
    SetConnectionLostHandler(handler ConnectionLostHandler)
    
    // Client Information
    GetClientID() string
    GetConnectionState() ConnectionState
    GetLastError() error
    
    // Advanced Features
    GetRetainedMessage(ctx context.Context, topic string) (*Message, error)
    ClearRetainedMessage(ctx context.Context, topic string) error
    GetSubscriptions() []Subscription
    
    // Metrics and Monitoring
    GetMetrics() Metrics
    GetHealthStatus() HealthStatus
    
    // Store Operations
    GetStore() Store
    ClearStore() error
}

// Usage Example
func setupMQTTManager(app *forge.App) {
    mqttManager := app.GetExtension("mqtt").(*mqtt.Extension).GetManager()
    
    // Connect to broker
    if err := mqttManager.Connect(context.Background()); err != nil {
        log.Fatalf("Failed to connect: %v", err)
    }
    
    // Set up handlers
    mqttManager.SetConnectionHandler(func(client mqtt.Client) {
        log.Println("Connected to MQTT broker")
        
        // Subscribe to topics after connection
        err := mqttManager.Subscribe(context.Background(), 
            "sensors/+/temperature", 
            mqtt.QoS1,
            handleTemperatureMessage,
        )
        if err != nil {
            log.Printf("Failed to subscribe: %v", err)
        }
    })
    
    mqttManager.SetConnectionLostHandler(func(client mqtt.Client, err error) {
        log.Printf("Connection lost: %v", err)
        // Implement reconnection logic if needed
    })
}
```

## Testing Utilities

The MQTT extension provides comprehensive testing utilities:

<Tabs items={['Unit Tests', 'Integration Tests', 'Mock Broker', 'Benchmark Tests']}>
  <Tab value="Unit Tests">
    ```go
    func TestMQTTPublisher(t *testing.T) {
        // Create test app with MQTT extension
        app := forge.NewApp()
        app.RegisterExtension(mqtt.NewExtension(
            mqtt.WithBroker("tcp://localhost:1883"),
            mqtt.WithClientID("test-client"),
        ))
        
        // Start app
        ctx := context.Background()
        require.NoError(t, app.Start(ctx))
        defer app.Stop(ctx)
        
        // Get MQTT manager
        mqttExt := app.GetExtension("mqtt").(*mqtt.Extension)
        manager := mqttExt.GetManager()
        
        // Test publishing
        err := manager.Publish(ctx, "test/topic", []byte("test message"), mqtt.QoS1)
        assert.NoError(t, err)
        
        // Verify message was published
        metrics := manager.GetMetrics()
        assert.Equal(t, int64(1), metrics.MessagesSent)
    }
    
    func TestMQTTSubscriber(t *testing.T) {
        app := forge.NewApp()
        app.RegisterExtension(mqtt.NewExtension(
            mqtt.WithBroker("tcp://localhost:1883"),
            mqtt.WithClientID("test-subscriber"),
        ))
        
        ctx := context.Background()
        require.NoError(t, app.Start(ctx))
        defer app.Stop(ctx)
        
        manager := app.GetExtension("mqtt").(*mqtt.Extension).GetManager()
        
        // Set up message channel for testing
        messageReceived := make(chan mqtt.Message, 1)
        
        // Subscribe to topic
        err := manager.Subscribe(ctx, "test/topic", mqtt.QoS1, 
            func(client mqtt.Client, msg mqtt.Message) {
                messageReceived <- msg
            },
        )
        require.NoError(t, err)
        
        // Publish test message
        err = manager.Publish(ctx, "test/topic", []byte("test payload"), mqtt.QoS1)
        require.NoError(t, err)
        
        // Wait for message
        select {
        case msg := <-messageReceived:
            assert.Equal(t, "test/topic", msg.Topic())
            assert.Equal(t, []byte("test payload"), msg.Payload())
        case <-time.After(5 * time.Second):
            t.Fatal("Message not received within timeout")
        }
    }
    ```
  </Tab>
  <Tab value="Integration Tests">
    ```go
    func TestMQTTIntegration(t *testing.T) {
        // Start embedded MQTT broker for testing
        broker := mqtt.NewEmbeddedBroker(mqtt.EmbeddedBrokerConfig{
            Port: 1883,
            Auth: false,
        })
        require.NoError(t, broker.Start())
        defer broker.Stop()
        
        // Create publisher app
        publisherApp := forge.NewApp()
        publisherApp.RegisterExtension(mqtt.NewExtension(
            mqtt.WithBroker("tcp://localhost:1883"),
            mqtt.WithClientID("publisher"),
        ))
        
        // Create subscriber app
        subscriberApp := forge.NewApp()
        subscriberApp.RegisterExtension(mqtt.NewExtension(
            mqtt.WithBroker("tcp://localhost:1883"),
            mqtt.WithClientID("subscriber"),
        ))
        
        ctx := context.Background()
        
        // Start both apps
        require.NoError(t, publisherApp.Start(ctx))
        require.NoError(t, subscriberApp.Start(ctx))
        defer publisherApp.Stop(ctx)
        defer subscriberApp.Stop(ctx)
        
        // Get managers
        publisher := publisherApp.GetExtension("mqtt").(*mqtt.Extension).GetManager()
        subscriber := subscriberApp.GetExtension("mqtt").(*mqtt.Extension).GetManager()
        
        // Set up subscription
        messageReceived := make(chan mqtt.Message, 1)
        err := subscriber.Subscribe(ctx, "integration/test", mqtt.QoS1,
            func(client mqtt.Client, msg mqtt.Message) {
                messageReceived <- msg
            },
        )
        require.NoError(t, err)
        
        // Wait for subscription to be active
        time.Sleep(100 * time.Millisecond)
        
        // Publish message
        testPayload := []byte("integration test message")
        err = publisher.Publish(ctx, "integration/test", testPayload, mqtt.QoS1)
        require.NoError(t, err)
        
        // Verify message received
        select {
        case msg := <-messageReceived:
            assert.Equal(t, "integration/test", msg.Topic())
            assert.Equal(t, testPayload, msg.Payload())
        case <-time.After(5 * time.Second):
            t.Fatal("Integration test message not received")
        }
    }
    ```
  </Tab>
  <Tab value="Mock Broker">
    ```go
    // Mock MQTT broker for testing
    type MockBroker struct {
        messages map[string][]mqtt.Message
        clients  map[string]mqtt.Client
        mu       sync.RWMutex
    }
    
    func NewMockBroker() *MockBroker {
        return &MockBroker{
            messages: make(map[string][]mqtt.Message),
            clients:  make(map[string]mqtt.Client),
        }
    }
    
    func (m *MockBroker) Publish(topic string, payload []byte, qos mqtt.QoS) error {
        m.mu.Lock()
        defer m.mu.Unlock()
        
        msg := &mockMessage{
            topic:   topic,
            payload: payload,
            qos:     qos,
        }
        
        m.messages[topic] = append(m.messages[topic], msg)
        return nil
    }
    
    func (m *MockBroker) GetMessages(topic string) []mqtt.Message {
        m.mu.RLock()
        defer m.mu.RUnlock()
        return m.messages[topic]
    }
    
    func TestWithMockBroker(t *testing.T) {
        mockBroker := NewMockBroker()
        
        app := forge.NewApp()
        app.RegisterExtension(mqtt.NewExtension(
            mqtt.WithMockBroker(mockBroker),
            mqtt.WithClientID("test-client"),
        ))
        
        ctx := context.Background()
        require.NoError(t, app.Start(ctx))
        defer app.Stop(ctx)
        
        manager := app.GetExtension("mqtt").(*mqtt.Extension).GetManager()
        
        // Publish to mock broker
        err := manager.Publish(ctx, "test/topic", []byte("mock test"), mqtt.QoS1)
        require.NoError(t, err)
        
        // Verify message in mock broker
        messages := mockBroker.GetMessages("test/topic")
        assert.Len(t, messages, 1)
        assert.Equal(t, []byte("mock test"), messages[0].Payload())
    }
    ```
  </Tab>
  <Tab value="Benchmark Tests">
    ```go
    func BenchmarkMQTTPublish(b *testing.B) {
        app := forge.NewApp()
        app.RegisterExtension(mqtt.NewExtension(
            mqtt.WithBroker("tcp://localhost:1883"),
            mqtt.WithClientID("benchmark-client"),
        ))
        
        ctx := context.Background()
        require.NoError(b, app.Start(ctx))
        defer app.Stop(ctx)
        
        manager := app.GetExtension("mqtt").(*mqtt.Extension).GetManager()
        payload := []byte("benchmark test message")
        
        b.ResetTimer()
        b.RunParallel(func(pb *testing.PB) {
            for pb.Next() {
                err := manager.Publish(ctx, "benchmark/topic", payload, mqtt.QoS0)
                if err != nil {
                    b.Errorf("Publish failed: %v", err)
                }
            }
        })
    }
    
    func BenchmarkMQTTSubscribe(b *testing.B) {
        app := forge.NewApp()
        app.RegisterExtension(mqtt.NewExtension(
            mqtt.WithBroker("tcp://localhost:1883"),
            mqtt.WithClientID("benchmark-subscriber"),
        ))
        
        ctx := context.Background()
        require.NoError(b, app.Start(ctx))
        defer app.Stop(ctx)
        
        manager := app.GetExtension("mqtt").(*mqtt.Extension).GetManager()
        
        // Set up subscription
        messageCount := int64(0)
        err := manager.Subscribe(ctx, "benchmark/+", mqtt.QoS0,
            func(client mqtt.Client, msg mqtt.Message) {
                atomic.AddInt64(&messageCount, 1)
            },
        )
        require.NoError(b, err)
        
        b.ResetTimer()
        
        // Publish messages
        for i := 0; i < b.N; i++ {
            topic := fmt.Sprintf("benchmark/%d", i%100)
            err := manager.Publish(ctx, topic, []byte("benchmark"), mqtt.QoS0)
            if err != nil {
                b.Errorf("Publish failed: %v", err)
            }
        }
        
        // Wait for all messages to be processed
        for atomic.LoadInt64(&messageCount) < int64(b.N) {
            time.Sleep(time.Millisecond)
        }
    }
    ```
  </Tab>
</Tabs>

## Best Practices

### Message Design

```go
// Use structured message formats
type SensorReading struct {
    DeviceID    string    `json:"device_id"`
    SensorType  string    `json:"sensor_type"`
    Value       float64   `json:"value"`
    Unit        string    `json:"unit"`
    Timestamp   time.Time `json:"timestamp"`
    Location    Location  `json:"location,omitempty"`
}

// Implement message validation
func (s *SensorReading) Validate() error {
    if s.DeviceID == "" {
        return errors.New("device_id is required")
    }
    if s.SensorType == "" {
        return errors.New("sensor_type is required")
    }
    if s.Timestamp.IsZero() {
        s.Timestamp = time.Now()
    }
    return nil
}

// Use consistent topic naming
const (
    TopicSensorData     = "sensors/{device_id}/{sensor_type}/data"
    TopicDeviceStatus   = "devices/{device_id}/status"
    TopicAlerts         = "alerts/{severity}/{device_id}"
    TopicCommands       = "commands/{device_id}/{command_type}"
)
```

### Error Handling

```go
// Implement robust error handling
func handleMQTTMessage(client mqtt.Client, msg mqtt.Message) {
    defer func() {
        if r := recover(); r != nil {
            log.Printf("Panic in message handler: %v", r)
            // Send to dead letter queue
            sendToDeadLetterQueue(msg, fmt.Sprintf("panic: %v", r))
        }
    }()
    
    // Validate message
    if len(msg.Payload()) == 0 {
        log.Printf("Empty message received on topic: %s", msg.Topic())
        return
    }
    
    // Process with timeout
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    
    if err := processMessage(ctx, msg); err != nil {
        log.Printf("Failed to process message: %v", err)
        
        // Implement retry logic
        if shouldRetry(err) {
            retryMessage(msg, err)
        } else {
            sendToDeadLetterQueue(msg, err.Error())
        }
    }
}

// Implement connection resilience
func setupConnectionHandlers(manager mqtt.MQTTManager) {
    manager.SetConnectionLostHandler(func(client mqtt.Client, err error) {
        log.Printf("MQTT connection lost: %v", err)
        
        // Implement exponential backoff
        backoff := time.Second
        maxBackoff := 5 * time.Minute
        
        for {
            time.Sleep(backoff)
            
            if err := manager.Connect(context.Background()); err == nil {
                log.Println("MQTT reconnected successfully")
                break
            }
            
            backoff *= 2
            if backoff > maxBackoff {
                backoff = maxBackoff
            }
        }
    })
}
```

### Performance Optimization

```go
// Use connection pooling for high-throughput scenarios
func setupHighThroughputMQTT() {
    app.RegisterExtension(mqtt.NewExtension(
        mqtt.WithBrokers([]string{
            "tcp://broker1:1883",
            "tcp://broker2:1883",
            "tcp://broker3:1883",
        }),
        mqtt.WithConnectionPool(mqtt.ConnectionPoolConfig{
            MaxConnections:    10,
            MaxIdleTime:      5 * time.Minute,
            ConnectionTimeout: 30 * time.Second,
        }),
        mqtt.WithAdvancedQoS(mqtt.AdvancedQoSConfig{
            MaxInflight:             100,
            EnableMessageBatching:   true,
            BatchSize:              50,
            BatchTimeout:           100 * time.Millisecond,
        }),
    ))
}

// Implement message batching
type MessageBatcher struct {
    messages []mqtt.Message
    timer    *time.Timer
    mu       sync.Mutex
}

func (b *MessageBatcher) AddMessage(msg mqtt.Message) {
    b.mu.Lock()
    defer b.mu.Unlock()
    
    b.messages = append(b.messages, msg)
    
    if len(b.messages) >= 50 {
        b.flush()
    } else if b.timer == nil {
        b.timer = time.AfterFunc(100*time.Millisecond, b.flush)
    }
}

func (b *MessageBatcher) flush() {
    b.mu.Lock()
    defer b.mu.Unlock()
    
    if len(b.messages) == 0 {
        return
    }
    
    // Process batch
    processBatch(b.messages)
    
    b.messages = b.messages[:0]
    if b.timer != nil {
        b.timer.Stop()
        b.timer = nil
    }
}
```

### Security Best Practices

```go
// Implement secure MQTT configuration
func setupSecureMQTT() {
    app.RegisterExtension(mqtt.NewExtension(
        mqtt.WithBroker("tls://secure-broker:8883"),
        mqtt.WithTLS(&tls.Config{
            ServerName:         "mqtt.example.com",
            MinVersion:         tls.VersionTLS12,
            InsecureSkipVerify: false,
            ClientAuth:         tls.RequireAndVerifyClientCert,
        }),
        mqtt.WithAuth("secure-user", "secure-password"),
        mqtt.WithClientCertAuth("/path/to/client.crt", "/path/to/client.key"),
        
        // Enable message encryption
        mqtt.WithMessageEncryption(mqtt.EncryptionConfig{
            Algorithm: "AES-256-GCM",
            KeyFile:   "/path/to/encryption.key",
        }),
        
        // Topic-based access control
        mqtt.WithTopicACL(map[string][]string{
            "sensors/+/data":     {"read", "write"},
            "commands/+/execute": {"write"},
            "status/+":          {"read"},
        }),
    ))
}

// Validate message authenticity
func validateMessage(msg mqtt.Message) error {
    // Check message signature
    signature := msg.Headers()["signature"]
    if signature == "" {
        return errors.New("missing message signature")
    }
    
    // Verify signature
    if !verifySignature(msg.Payload(), signature) {
        return errors.New("invalid message signature")
    }
    
    // Check timestamp to prevent replay attacks
    timestamp := msg.Headers()["timestamp"]
    if timestamp == "" {
        return errors.New("missing timestamp")
    }
    
    msgTime, err := time.Parse(time.RFC3339, timestamp)
    if err != nil {
        return fmt.Errorf("invalid timestamp format: %v", err)
    }
    
    if time.Since(msgTime) > 5*time.Minute {
        return errors.New("message too old")
    }
    
    return nil
}
```

The MQTT extension provides a robust, scalable solution for IoT and real-time messaging applications with comprehensive features for security, monitoring, and high-performance operations.