---
title: Cost Management
description: Track usage, set budgets, and optimize AI costs
---

import { Callout } from 'fumadocs-ui/components/callout'

# Cost Management

Comprehensive cost tracking, budget management, and optimization recommendations.

## Basic Tracking

```go
tracker := sdk.NewCostTracker(logger, metrics)

// Track a request
tracker.TrackRequest(ctx, sdk.CostEntry{
    Model:        "gpt-4",
    InputTokens:  100,
    OutputTokens: 200,
    Provider:     "openai",
})

// Get total cost
total := tracker.GetTotalCost()
fmt.Printf("Total spent: $%.2f\n", total)
```

## Budget Management

```go
tracker := sdk.NewCostTracker(logger, metrics)

// Set monthly budget
tracker.SetMonthlyBudget(1000.00)  // $1000/month

// Set alert threshold
tracker.SetAlertThreshold(0.8)  // Alert at 80%

// Check budget status
status := tracker.GetBudgetStatus()
fmt.Printf("Used: $%.2f / $%.2f (%.1f%%)\n",
    status.Used, status.Total, status.Percentage * 100)

if status.Alert {
    fmt.Println("⚠️  Budget alert!")
}
```

## Cost Breakdown

### By Model

```go
breakdown := tracker.GetCostByModel()

for model, cost := range breakdown {
    fmt.Printf("%s: $%.2f\n", model, cost)
}

// Output:
// gpt-4: $450.00
// gpt-3.5-turbo: $120.00
// claude-3-opus: $280.00
```

### By Provider

```go
breakdown := tracker.GetCostByProvider()

for provider, cost := range breakdown {
    fmt.Printf("%s: $%.2f\n", provider, cost)
}

// Output:
// openai: $570.00
// anthropic: $280.00
```

### By Time Period

```go
// This month
thisMonth := tracker.GetCostForPeriod(
    time.Now().AddDate(0, 0, -30),
    time.Now(),
)

// Last 7 days
lastWeek := tracker.GetCostForPeriod(
    time.Now().AddDate(0, 0, -7),
    time.Now(),
)

// Today
today := tracker.GetCostForPeriod(
    time.Now().Truncate(24*time.Hour),
    time.Now(),
)
```

## Optimization Recommendations

```go
recommendations := tracker.GetOptimizationRecommendations()

for _, rec := range recommendations {
    fmt.Printf("💡 %s\n", rec.Title)
    fmt.Printf("   Potential savings: $%.2f/month\n", rec.PotentialSavings)
    fmt.Printf("   Action: %s\n", rec.Action)
}

// Output:
// 💡 Switch to GPT-3.5-Turbo for simple queries
//    Potential savings: $180.00/month
//    Action: Use gpt-3.5-turbo for non-complex tasks
//
// 💡 Enable caching
//    Potential savings: $120.00/month
//    Action: Cache similar requests to reduce API calls
```

## Cost Insights

```go
insights := tracker.GetInsights()

fmt.Printf("Average cost per request: $%.4f\n", insights.AvgCostPerRequest)
fmt.Printf("Total requests: %d\n", insights.TotalRequests)
fmt.Printf("Most expensive model: %s ($%.2f)\n", 
    insights.MostExpensiveModel, insights.MostExpensiveCost)
fmt.Printf("Projected monthly cost: $%.2f\n", insights.ProjectedMonthly)
```

## Real-Time Monitoring

```go
// Set up alerts
tracker.OnBudgetAlert(func(status sdk.BudgetStatus) {
    log.Printf("⚠️  Budget alert: %.1f%% used", status.Percentage * 100)
    notifyAdmin("Budget alert", status)
})

tracker.OnBudgetExceeded(func(status sdk.BudgetStatus) {
    log.Printf("🚨 Budget exceeded: $%.2f / $%.2f", 
        status.Used, status.Total)
    
    // Take action
    disableExpensiveModels()
    notifyAdmin("Budget exceeded", status)
})

// Monitor continuously
go tracker.MonitorBudget(ctx, 5*time.Minute)
```

## Cost Limits

### Per Request

```go
generator := sdk.NewGenerateBuilder(ctx, llm, logger, metrics).
    WithPrompt("Long prompt...").
    WithCostLimit(0.10)  // Max $0.10 per request

result, err := generator.Execute()
if errors.Is(err, sdk.ErrCostLimitExceeded) {
    fmt.Println("Request would exceed cost limit")
}
```

### Per User

```go
type UserCostTracker struct {
    tracker *sdk.CostTracker
    limits  map[string]float64
}

func (u *UserCostTracker) CheckLimit(userID string, cost float64) error {
    limit := u.limits[userID]
    used := u.tracker.GetCostForUser(userID)
    
    if used + cost > limit {
        return fmt.Errorf("user %s exceeds limit", userID)
    }
    
    return nil
}
```

## Export & Reporting

### CSV Export

```go
// Export to CSV
err := tracker.ExportToCSV("costs.csv", time.Now().AddDate(0, -1, 0), time.Now())

// CSV format:
// timestamp,model,provider,input_tokens,output_tokens,cost
// 2024-01-15 10:30:00,gpt-4,openai,100,200,0.006
```

### JSON Export

```go
data, err := tracker.ExportToJSON(startDate, endDate)

// Save to file
os.WriteFile("costs.json", data, 0644)
```

### Daily Summary

```go
summary := tracker.GetDailySummary()

for date, cost := range summary {
    fmt.Printf("%s: $%.2f\n", date.Format("2006-01-02"), cost)
}
```

## Integration with Builders

### Automatic Tracking

```go
// Cost is automatically tracked
result, _ := sdk.NewGenerateBuilder(ctx, llm, logger, metrics).
    WithPrompt("Hello").
    WithCost(tracker).  // Enable cost tracking
    Execute()

// Cost automatically recorded
fmt.Printf("Request cost: $%.4f\n", result.Cost)
```

### With Budget Check

```go
result, err := sdk.NewGenerateBuilder(ctx, llm, logger, metrics).
    WithPrompt("Expensive query...").
    WithCost(tracker).
    WithBudgetCheck(true).  // Check budget before executing
    Execute()

if errors.Is(err, sdk.ErrBudgetExceeded) {
    fmt.Println("Budget exceeded, request blocked")
}
```

## Cost Optimization Strategies

### 1. Model Selection

```go
// Use cheaper models when possible
func selectModel(complexity string) string {
    switch complexity {
    case "high":
        return "gpt-4"           // $0.03/1K tokens
    case "medium":
        return "gpt-3.5-turbo"   // $0.002/1K tokens
    default:
        return "gpt-3.5-turbo"
    }
}

result, _ := sdk.NewGenerateBuilder(ctx, llm, logger, metrics).
    WithModel(selectModel(taskComplexity)).
    Execute()
```

### 2. Caching

```go
cache := sdk.NewSemanticCache(vectorStore, cacheStore, logger, metrics,
    sdk.SemanticCacheConfig{
        SimilarityThreshold: 0.95,
        TTL: 1 * time.Hour,
    },
)

// Saves ~30% on repeated queries
result, _ := sdk.NewGenerateBuilder(ctx, llm, logger, metrics).
    WithCache(cache).
    Execute()
```

### 3. Batch Processing

```go
processor := sdk.NewBatchProcessor(llm, logger, metrics,
    sdk.BatchConfig{
        MaxBatchSize: 10,
        MaxWaitTime:  100 * time.Millisecond,
    },
)

// Saves ~20% through batching
for _, prompt := range prompts {
    processor.Submit(ctx, sdk.BatchRequest{Prompt: prompt})
}
```

### 4. Token Optimization

```go
result, _ := sdk.NewGenerateBuilder(ctx, llm, logger, metrics).
    WithPrompt(prompt).
    WithMaxTokens(500).          // Limit output tokens
    WithTemperature(0.7).        // Lower = more focused
    WithTopP(0.9).               // Reduce variety
    Execute()
```

## Best Practices

### 1. Set Realistic Budgets

```go
// Start with monitoring
tracker := sdk.NewCostTracker(logger, metrics)

// After 1 month, set budget based on data
insights := tracker.GetInsights()
monthlyBudget := insights.AverageDaily * 30 * 1.2  // +20% buffer
tracker.SetMonthlyBudget(monthlyBudget)
```

### 2. Alert Early

```go
// Alert at 80%, critical at 95%
tracker.SetAlertThreshold(0.8)
tracker.OnBudgetAlert(func(status sdk.BudgetStatus) {
    if status.Percentage > 0.95 {
        // Critical - take action
        switchToEconomy Mode()
    } else {
        // Warning - monitor closely
        sendWarning()
    }
})
```

### 3. Regular Reviews

```go
// Weekly cost review
ticker := time.NewTicker(7 * 24 * time.Hour)
go func() {
    for range ticker.C {
        insights := tracker.GetInsights()
        recommendations := tracker.GetOptimizationRecommendations()
        
        // Send report
        sendWeeklyReport(insights, recommendations)
    }
}()
```

## Next Steps

- [Resilience](/docs/extensions/ai/ai/resilience) - Add rate limiting
- [Caching & Batching](/docs/extensions/ai/ai/caching-batching) - Optimize costs
- [Examples](/docs/extensions/ai/ai/examples) - Cost tracking examples

