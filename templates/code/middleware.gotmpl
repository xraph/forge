package {{.Package}}

import (
	"net/http"
	"time"
	{{- if or (eq .Type "auth") (eq .Type "jwt")}}
	"strings"
	"errors"
	{{- end}}
	{{- if eq .Type "cors"}}
	"strconv"
	{{- end}}
	{{- if eq .Type "rate_limit"}}
	"fmt"
	"sync"
	{{- end}}

	"github.com/xraph/forge/pkg/common"
	{{- if .Config}}
	"github.com/xraph/forge/pkg/config"
	{{- end}}
	{{- if .Metrics}}
	"github.com/xraph/forge/pkg/metrics"
	{{- end}}
)

{{- if .Config}}
// {{.Name}}Config represents configuration for {{.Name}} middleware
type {{.Name}}Config struct {
	{{- if eq .Type "auth"}}
	Enabled      bool     `json:"enabled" yaml:"enabled" default:"true"`
	SkipPaths    []string `json:"skip_paths" yaml:"skip_paths"`
	TokenHeader  string   `json:"token_header" yaml:"token_header" default:"Authorization"`
	TokenPrefix  string   `json:"token_prefix" yaml:"token_prefix" default:"Bearer "`
	{{- else if eq .Type "cors"}}
	Enabled          bool     `json:"enabled" yaml:"enabled" default:"true"`
	AllowOrigins     []string `json:"allow_origins" yaml:"allow_origins"`
	AllowMethods     []string `json:"allow_methods" yaml:"allow_methods"`
	AllowHeaders     []string `json:"allow_headers" yaml:"allow_headers"`
	ExposeHeaders    []string `json:"expose_headers" yaml:"expose_headers"`
	AllowCredentials bool     `json:"allow_credentials" yaml:"allow_credentials"`
	MaxAge           int      `json:"max_age" yaml:"max_age" default:"86400"`
	{{- else if eq .Type "rate_limit"}}
	Enabled    bool          `json:"enabled" yaml:"enabled" default:"true"`
	Rate       int           `json:"rate" yaml:"rate" default:"100"`
	Window     time.Duration `json:"window" yaml:"window" default:"1h"`
	SkipPaths  []string      `json:"skip_paths" yaml:"skip_paths"`
	{{- else if eq .Type "logging"}}
	Enabled       bool     `json:"enabled" yaml:"enabled" default:"true"`
	SkipPaths     []string `json:"skip_paths" yaml:"skip_paths"`
	LogBody       bool     `json:"log_body" yaml:"log_body" default:"false"`
	LogHeaders    bool     `json:"log_headers" yaml:"log_headers" default:"false"`
	BodySizeLimit int      `json:"body_size_limit" yaml:"body_size_limit" default:"1024"`
	{{- else}}
	Enabled   bool     `json:"enabled" yaml:"enabled" default:"true"`
	SkipPaths []string `json:"skip_paths" yaml:"skip_paths"`
	{{- end}}
}

// DefaultConfig returns default configuration
func Default{{.Name}}Config() *{{.Name}}Config {
	return &{{.Name}}Config{
		{{- if eq .Type "auth"}}
		Enabled:     true,
		SkipPaths:   []string{"/health", "/metrics"},
		TokenHeader: "Authorization",
		TokenPrefix: "Bearer ",
		{{- else if eq .Type "cors"}}
		Enabled:          true,
		AllowOrigins:     []string{"*"},
		AllowMethods:     []string{"GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"},
		AllowHeaders:     []string{"Content-Type", "Authorization", "X-Request-ID"},
		ExposeHeaders:    []string{"X-Request-ID"},
		AllowCredentials: false,
		MaxAge:           86400,
		{{- else if eq .Type "rate_limit"}}
		Enabled:   true,
		Rate:      100,
		Window:    time.Hour,
		SkipPaths: []string{"/health", "/metrics"},
		{{- else if eq .Type "logging"}}
		Enabled:       true,
		SkipPaths:     []string{"/health", "/metrics"},
		LogBody:       false,
		LogHeaders:    false,
		BodySizeLimit: 1024,
		{{- else}}
		Enabled:   true,
		SkipPaths: []string{"/health", "/metrics"},
		{{- end}}
	}
}
{{- end}}

// {{.Name}}Middleware provides {{.Type | default "custom"}} functionality
{{- if .Description}}
// {{.Description}}
{{- end}}
type {{.Name}}Middleware struct {
	logger   common.Logger
	{{- if .Config}}
	config   *{{.Name}}Config
	{{- end}}
	{{- if .Metrics}}
	metrics  common.Metrics
	{{- end}}
	{{- if eq .Type "rate_limit"}}
	clients  map[string]*rateLimitInfo
	mutex    sync.RWMutex
	{{- end}}
	{{- if .Priority}}
	priority int
	{{- end}}
}

{{- if eq .Type "rate_limit"}}
type rateLimitInfo struct {
	requests  int
	resetTime time.Time
}
{{- end}}

// New{{.Name}}Middleware creates a new {{.Name | toLower}} middleware instance
func New{{.Name}}Middleware(
	logger common.Logger{{if .Config}},
	config *{{.Name}}Config{{end}}{{if .Metrics}},
	metrics common.Metrics{{end}},
) *{{.Name}}Middleware {
	{{- if .Config}}
	if config == nil {
		config = Default{{.Name}}Config()
	}
	{{- end}}

	return &{{.Name}}Middleware{
		logger: logger,
		{{- if .Config}}
		config: config,
		{{- end}}
		{{- if .Metrics}}
		metrics: metrics,
		{{- end}}
		{{- if eq .Type "rate_limit"}}
		clients: make(map[string]*rateLimitInfo),
		mutex:   sync.RWMutex{},
		{{- end}}
		{{- if .Priority}}
		priority: {{.Priority}},
		{{- end}}
	}
}

// Handler returns the HTTP middleware handler
func (m *{{.Name}}Middleware) Handler() func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			{{- if .Config}}
			// Check if middleware is enabled
			if !m.config.Enabled {
				next.ServeHTTP(w, r)
				return
			}

			// Check if path should be skipped
			if m.shouldSkipPath(r.URL.Path) {
				next.ServeHTTP(w, r)
				return
			}
			{{- end}}

			{{- if .Metrics}}
			// Record middleware execution
			start := time.Now()
			defer func() {
				m.metrics.Histogram("middleware.{{.Name | toLower}}.duration").Observe(time.Since(start).Seconds())
				m.metrics.Counter("middleware.{{.Name | toLower}}.requests").Inc()
			}()
			{{- end}}

			{{- if eq .Type "auth"}}
			// Authentication logic
			if err := m.authenticate(r); err != nil {
				{{- if .Metrics}}
				m.metrics.Counter("middleware.{{.Name | toLower}}.auth_failures").Inc()
				{{- end}}
				m.logger.Warn("authentication failed",
					common.LogField{Key: "path", Value: r.URL.Path},
					common.LogField{Key: "error", Value: err})
				http.Error(w, "Unauthorized", http.StatusUnauthorized)
				return
			}
			{{- else if eq .Type "cors"}}
			// CORS logic
			m.handleCORS(w, r)

			// Handle preflight requests
			if r.Method == "OPTIONS" {
				w.WriteHeader(http.StatusOK)
				return
			}
			{{- else if eq .Type "rate_limit"}}
			// Rate limiting logic
			clientID := m.getClientID(r)
			if m.isRateLimited(clientID) {
				{{- if .Metrics}}
				m.metrics.Counter("middleware.{{.Name | toLower}}.rate_limited").Inc()
				{{- end}}
				m.logger.Warn("rate limit exceeded",
					common.LogField{Key: "client_id", Value: clientID},
					common.LogField{Key: "path", Value: r.URL.Path})
				http.Error(w, "Too Many Requests", http.StatusTooManyRequests)
				return
			}
			{{- else if eq .Type "logging"}}
			// Logging logic
			m.logRequest(r)

			// Wrap response writer to capture response data
			wrappedWriter := &responseWriter{ResponseWriter: w, statusCode: 200}
			defer m.logResponse(r, wrappedWriter, time.Now())

			next.ServeHTTP(wrappedWriter, r)
			return
			{{- else}}
			// Custom middleware logic
			m.logger.Debug("{{.Name | toLower}} middleware processing request",
				common.LogField{Key: "method", Value: r.Method},
				common.LogField{Key: "path", Value: r.URL.Path})

			// TODO: Implement your custom middleware logic here
			{{- end}}

			// Call the next handler
			next.ServeHTTP(w, r)
		})
	}
}

// Name returns the middleware name
func (m *{{.Name}}Middleware) Name() string {
	return "{{.Name | toLower}}"
}

{{- if .Priority}}
// Priority returns the middleware priority (lower = higher priority)
func (m *{{.Name}}Middleware) Priority() int {
	return m.priority
}
{{- end}}

{{- if .Config}}
// shouldSkipPath checks if the path should be skipped
func (m *{{.Name}}Middleware) shouldSkipPath(path string) bool {
	for _, skipPath := range m.config.SkipPaths {
		if path == skipPath {
			return true
		}
	}
	return false
}

// UpdateConfig updates the middleware configuration
func (m *{{.Name}}Middleware) UpdateConfig(config *{{.Name}}Config) {
	if config != nil {
		m.config = config
		m.logger.Info("{{.Name | toLower}} middleware configuration updated")
	}
}
{{- end}}

{{- if eq .Type "auth"}}

// authenticate performs authentication logic
func (m *{{.Name}}Middleware) authenticate(r *http.Request) error {
	// Get token from header
	authHeader := r.Header.Get(m.config.TokenHeader)
	if authHeader == "" {
		return errors.New("missing authorization header")
	}

	// Extract token
	if !strings.HasPrefix(authHeader, m.config.TokenPrefix) {
		return errors.New("invalid authorization header format")
	}

	token := strings.TrimPrefix(authHeader, m.config.TokenPrefix)
	if token == "" {
		return errors.New("empty token")
	}

	// TODO: Implement your token validation logic here
	// This could include JWT validation, database lookup, etc.

	// Example: Basic validation (implement your own logic)
	if !m.validateToken(token) {
		return errors.New("invalid token")
	}

	// TODO: Set user context or other authentication info
	// For example, you might want to add user ID to the request context

	return nil
}

// validateToken validates the authentication token
func (m *{{.Name}}Middleware) validateToken(token string) bool {
	// TODO: Implement your token validation logic
	// This is a placeholder - implement JWT validation, database lookup, etc.
	return token != ""
}

{{- else if eq .Type "cors"}}

// handleCORS sets CORS headers
func (m *{{.Name}}Middleware) handleCORS(w http.ResponseWriter, r *http.Request) {
	origin := r.Header.Get("Origin")

	// Check if origin is allowed
	if m.isOriginAllowed(origin) {
		w.Header().Set("Access-Control-Allow-Origin", origin)
	} else if len(m.config.AllowOrigins) == 1 && m.config.AllowOrigins[0] == "*" {
		w.Header().Set("Access-Control-Allow-Origin", "*")
	}

	// Set other CORS headers
	if len(m.config.AllowMethods) > 0 {
		w.Header().Set("Access-Control-Allow-Methods", strings.Join(m.config.AllowMethods, ", "))
	}

	if len(m.config.AllowHeaders) > 0 {
		w.Header().Set("Access-Control-Allow-Headers", strings.Join(m.config.AllowHeaders, ", "))
	}

	if len(m.config.ExposeHeaders) > 0 {
		w.Header().Set("Access-Control-Expose-Headers", strings.Join(m.config.ExposeHeaders, ", "))
	}

	if m.config.AllowCredentials {
		w.Header().Set("Access-Control-Allow-Credentials", "true")
	}

	if m.config.MaxAge > 0 {
		w.Header().Set("Access-Control-Max-Age", strconv.Itoa(m.config.MaxAge))
	}
}

// isOriginAllowed checks if the origin is in the allowed list
func (m *{{.Name}}Middleware) isOriginAllowed(origin string) bool {
	for _, allowedOrigin := range m.config.AllowOrigins {
		if allowedOrigin == origin || allowedOrigin == "*" {
			return true
		}
	}
	return false
}

{{- else if eq .Type "rate_limit"}}

// getClientID extracts client identifier from request
func (m *{{.Name}}Middleware) getClientID(r *http.Request) string {
	// Use IP address as client ID (you might want to use user ID instead)
	return r.RemoteAddr
}

// isRateLimited checks if the client has exceeded rate limit
func (m *{{.Name}}Middleware) isRateLimited(clientID string) bool {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	now := time.Now()
	client, exists := m.clients[clientID]

	if !exists || now.After(client.resetTime) {
		// New client or window expired
		m.clients[clientID] = &rateLimitInfo{
			requests:  1,
			resetTime: now.Add(m.config.Window),
		}
		return false
	}

	// Check if rate limit exceeded
	if client.requests >= m.config.Rate {
		return true
	}

	// Increment request count
	client.requests++
	return false
}

// cleanupExpiredClients removes expired rate limit entries
func (m *{{.Name}}Middleware) cleanupExpiredClients() {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	now := time.Now()
	for clientID, client := range m.clients {
		if now.After(client.resetTime) {
			delete(m.clients, clientID)
		}
	}
}

{{- else if eq .Type "logging"}}

// responseWriter wraps http.ResponseWriter to capture response data
type responseWriter struct {
	http.ResponseWriter
	statusCode int
	size       int
}

func (rw *responseWriter) WriteHeader(code int) {
	rw.statusCode = code
	rw.ResponseWriter.WriteHeader(code)
}

func (rw *responseWriter) Write(b []byte) (int, error) {
	size, err := rw.ResponseWriter.Write(b)
	rw.size += size
	return size, err
}

// logRequest logs incoming request details
func (m *{{.Name}}Middleware) logRequest(r *http.Request) {
	fields := []common.LogField{
		{Key: "method", Value: r.Method},
		{Key: "path", Value: r.URL.Path},
		{Key: "remote_addr", Value: r.RemoteAddr},
		{Key: "user_agent", Value: r.UserAgent()},
	}

	if m.config.LogHeaders {
		for key, values := range r.Header {
			fields = append(fields, common.LogField{
				Key:   fmt.Sprintf("header_%s", strings.ToLower(key)),
				Value: strings.Join(values, ", "),
			})
		}
	}

	if m.config.LogBody && r.ContentLength > 0 && r.ContentLength <= int64(m.config.BodySizeLimit) {
		// TODO: Implement body logging if needed (be careful with memory usage)
	}

	m.logger.Info("incoming request", fields...)
}

// logResponse logs response details
func (m *{{.Name}}Middleware) logResponse(r *http.Request, rw *responseWriter, start time.Time) {
	duration := time.Since(start)

	m.logger.Info("request completed",
		common.LogField{Key: "method", Value: r.Method},
		common.LogField{Key: "path", Value: r.URL.Path},
		common.LogField{Key: "status_code", Value: rw.statusCode},
		common.LogField{Key: "response_size", Value: rw.size},
		common.LogField{Key: "duration", Value: duration},
		common.LogField{Key: "duration_ms", Value: float64(duration.Nanoseconds()) / 1000000})
}

{{- end}}

// =============================================================================
// Helper methods
// =============================================================================

{{- if eq .Type "rate_limit"}}
// StartCleanupRoutine starts a goroutine to periodically clean up expired clients
func (m *{{.Name}}Middleware) StartCleanupRoutine() {
	go func() {
		ticker := time.NewTicker(time.Minute * 5) // Clean up every 5 minutes
		defer ticker.Stop()

		for {
			select {
			case <-ticker.C:
				m.cleanupExpiredClients()
			}
		}
	}()
}
{{- end}}

{{- if .Metrics}}
// GetStats returns middleware statistics
func (m *{{.Name}}Middleware) GetStats() map[string]interface{} {
	stats := map[string]interface{}{
		"name":    m.Name(),
		"type":    "{{.Type}}",
		"enabled": {{if .Config}}m.config.Enabled{{else}}true{{end}},
	}

	{{- if eq .Type "rate_limit"}}
	m.mutex.RLock()
	stats["active_clients"] = len(m.clients)
	m.mutex.RUnlock()
	{{- end}}

	return stats
}
{{- end}}

// IsEnabled returns whether the middleware is enabled
func (m *{{.Name}}Middleware) IsEnabled() bool {
	{{- if .Config}}
	return m.config.Enabled
	{{- else}}
	return true
	{{- end}}
}

// SetEnabled enables or disables the middleware
func (m *{{.Name}}Middleware) SetEnabled(enabled bool) {
	{{- if .Config}}
	m.config.Enabled = enabled
	m.logger.Info("{{.Name | toLower}} middleware enabled status changed",
		common.LogField{Key: "enabled", Value: enabled})
	{{- else}}
	// No configuration support - middleware is always enabled
	m.logger.Warn("{{.Name | toLower}} middleware does not support runtime enable/disable")
	{{- end}}
}