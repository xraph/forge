---
title: Dependency Injection
description: Learn how to use Forge's powerful dependency injection system
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Tab, Tabs } from 'fumadocs-ui/components/tabs'
import { Card, Cards } from 'fumadocs-ui/components/card'

# Dependency Injection

Forge Go includes a powerful dependency injection (DI) system that helps you manage dependencies, improve testability, and create loosely coupled applications.

## Basic Usage

### Creating a Container

```go
package main

import (
    "log"
    "github.com/xraph/forge"
    "github.com/xraph/forge/pkg/di"
)

func main() {
    // Create a new DI container
    container := di.NewContainer()
    
    // Register services
    container.RegisterSingleton("database", &DatabaseService{})
    container.RegisterTransient("userService", &UserService{})
    
    // Build the container
    if err := container.Build(); err != nil {
        log.Fatal(err)
    }
    
    // Use the container
    app := forge.New(forge.Config{
        Name: "My App",
    })
    
    // Inject container into Forge
    app.Use(di.Middleware(container))
    
    log.Fatal(app.Listen(":8080"))
}
```

### Service Registration

```go
// Register a singleton service
container.RegisterSingleton("database", &DatabaseService{
    ConnectionString: "postgres://user:pass@localhost/db",
})

// Register a transient service
container.RegisterTransient("userService", func() *UserService {
    db := container.Get("database").(*DatabaseService)
    return &UserService{db: db}
})

// Register with interface
container.RegisterSingleton("logger", &LoggerService{})
container.RegisterAs("logger", (*common.Logger)(nil))
```

## Service Lifecycles

### Singleton

```go
// Singleton services are created once and reused
container.RegisterSingleton("config", &ConfigService{})

// The same instance is returned every time
config1 := container.Get("config").(*ConfigService)
config2 := container.Get("config").(*ConfigService)
// config1 == config2 (same instance)
```

### Transient

```go
// Transient services are created fresh each time
container.RegisterTransient("userService", func() *UserService {
    return &UserService{}
})

// New instance is created each time
user1 := container.Get("userService").(*UserService)
user2 := container.Get("userService").(*UserService)
// user1 != user2 (different instances)
```

### Scoped

```go
// Scoped services live for the duration of a request
container.RegisterScoped("requestContext", func() *RequestContext {
    return &RequestContext{
        RequestID: generateRequestID(),
    }
})
```

## Constructor Injection

### Basic Constructor

```go
type UserService struct {
    db     *DatabaseService
    logger common.Logger
    config *ConfigService
}

// Constructor function
func NewUserService(db *DatabaseService, logger common.Logger, config *ConfigService) *UserService {
    return &UserService{
        db:     db,
        logger: logger,
        config: config,
    }
}

// Register with constructor
container.RegisterTransient("userService", NewUserService)
```

### Interface Injection

```go
// Define interface
type UserRepository interface {
    GetUser(id string) (*User, error)
    CreateUser(user *User) error
}

// Implement interface
type DatabaseUserRepository struct {
    db *DatabaseService
}

func (r *DatabaseUserRepository) GetUser(id string) (*User, error) {
    // Implementation
}

func (r *DatabaseUserRepository) CreateUser(user *User) error {
    // Implementation
}

// Register implementation
container.RegisterSingleton("userRepository", &DatabaseUserRepository{})
container.RegisterAs("userRepository", (*UserRepository)(nil))
```

## Service Resolution

### Get Service

```go
// Get service by name
userService := container.Get("userService").(*UserService)

// Get service by type
var userService *UserService
container.GetByType(&userService)

// Get service by interface
var userRepo UserRepository
container.GetByType(&userRepo)
```

### Optional Resolution

```go
// Try to get service (returns nil if not found)
if userService, ok := container.TryGet("userService").(*UserService); ok {
    // Use userService
}

// Check if service exists
if container.Has("userService") {
    userService := container.Get("userService").(*UserService)
    // Use userService
}
```

## Service Configuration

### Configuration Injection

```go
type DatabaseService struct {
    ConnectionString string
    MaxConnections   int
    Timeout          time.Duration
}

// Register with configuration
container.RegisterSingleton("database", &DatabaseService{})
container.Configure("database", DatabaseConfig{
    ConnectionString: "postgres://user:pass@localhost/db",
    MaxConnections:   100,
    Timeout:          30 * time.Second,
})
```

### Environment-based Configuration

```go
// Load configuration from environment
container.ConfigureFromEnv("database", "DB_")

// This will map:
// DB_CONNECTION_STRING -> ConnectionString
// DB_MAX_CONNECTIONS -> MaxConnections
// DB_TIMEOUT -> Timeout
```

## Service Dependencies

### Automatic Dependency Resolution

```go
type UserService struct {
    db     *DatabaseService
    logger common.Logger
    cache  *CacheService
}

func NewUserService(db *DatabaseService, logger common.Logger, cache *CacheService) *UserService {
    return &UserService{
        db:     db,
        logger: logger,
        cache:  cache,
    }
}

// Register all dependencies
container.RegisterSingleton("database", &DatabaseService{})
container.RegisterSingleton("logger", &LoggerService{})
container.RegisterSingleton("cache", &CacheService{})

// Register service - dependencies are automatically resolved
container.RegisterTransient("userService", NewUserService)
```

### Manual Dependency Specification

```go
// Specify dependencies explicitly
container.RegisterTransient("userService", NewUserService).
    WithDependencies("database", "logger", "cache")
```

## Service Tags and Metadata

### Tagging Services

```go
// Register service with tags
container.RegisterSingleton("database", &DatabaseService{}).
    WithTag("infrastructure", "true").
    WithTag("critical", "true")

// Find services by tag
infraServices := container.GetByTag("infrastructure")
criticalServices := container.GetByTag("critical")
```

### Service Metadata

```go
// Add metadata to services
container.RegisterSingleton("database", &DatabaseService{}).
    WithMetadata("version", "1.0.0").
    WithMetadata("description", "Main database service")
```

## Service Interceptors

### Logging Interceptor

```go
// Create logging interceptor
loggingInterceptor := func(serviceName string, method string, args []interface{}, result interface{}, err error) {
    log.Printf("Service %s.%s called with args %v, result %v, error %v", 
        serviceName, method, args, result, err)
}

// Register interceptor
container.AddInterceptor(loggingInterceptor)
```

### Metrics Interceptor

```go
// Create metrics interceptor
metricsInterceptor := func(serviceName string, method string, args []interface{}, result interface{}, err error) {
    // Record metrics
    metrics.Counter("service_calls_total").
        WithLabelValues(serviceName, method).
        Inc()
}

container.AddInterceptor(metricsInterceptor)
```

## Service Lifecycle Management

### Lifecycle Hooks

```go
type DatabaseService struct {
    connection *sql.DB
}

func (d *DatabaseService) Start(ctx context.Context) error {
    // Initialize database connection
    db, err := sql.Open("postgres", d.ConnectionString)
    if err != nil {
        return err
    }
    d.connection = db
    return nil
}

func (d *DatabaseService) Stop(ctx context.Context) error {
    // Close database connection
    return d.connection.Close()
}

// Register with lifecycle
container.RegisterSingleton("database", &DatabaseService{}).
    WithLifecycle(di.LifecycleManaged)
```

### Container Lifecycle

```go
// Start all managed services
if err := container.Start(context.Background()); err != nil {
    log.Fatal(err)
}

// Stop all managed services
defer container.Stop(context.Background())
```

## Testing with DI

### Mock Services

```go
// Create mock service
type MockUserRepository struct {
    users map[string]*User
}

func (m *MockUserRepository) GetUser(id string) (*User, error) {
    if user, exists := m.users[id]; exists {
        return user, nil
    }
    return nil, errors.New("user not found")
}

// Register mock in test
func TestUserService(t *testing.T) {
    container := di.NewContainer()
    container.RegisterSingleton("userRepository", &MockUserRepository{
        users: make(map[string]*User),
    })
    container.RegisterTransient("userService", NewUserService)
    
    // Test with mock
    userService := container.Get("userService").(*UserService)
    // ... test logic
}
```

### Test Container

```go
// Create test container with common test services
func NewTestContainer() *di.Container {
    container := di.NewContainer()
    
    // Register test services
    container.RegisterSingleton("logger", &TestLogger{})
    container.RegisterSingleton("database", &TestDatabase{})
    
    return container
}
```

## Advanced Features

### Service Factories

```go
// Service factory for complex creation logic
type ServiceFactory func(container *di.Container) interface{}

func CreateUserService(container *di.Container) interface{} {
    db := container.Get("database").(*DatabaseService)
    logger := container.Get("logger").(common.Logger)
    
    // Complex initialization logic
    if db.IsReadOnly() {
        return &ReadOnlyUserService{db: db, logger: logger}
    }
    return &UserService{db: db, logger: logger}
}

// Register factory
container.RegisterFactory("userService", CreateUserService)
```

### Service Decorators

```go
// Decorator pattern with DI
type CachedUserService struct {
    userService *UserService
    cache       *CacheService
}

func NewCachedUserService(userService *UserService, cache *CacheService) *CachedUserService {
    return &CachedUserService{
        userService: userService,
        cache:       cache,
    }
}

// Register decorator
container.RegisterTransient("cachedUserService", NewCachedUserService).
    WithDependencies("userService", "cache")
```

## Best Practices

<Cards>
  <Card
    title="Interface Segregation"
    description="Register services by interface, not concrete types"
  />
  <Card
    title="Lifecycle Management"
    description="Use appropriate lifecycles for different service types"
  />
  <Card
    title="Dependency Order"
    description="Register dependencies before dependents"
  />
  <Card
    title="Error Handling"
    description="Handle service resolution errors gracefully"
  />
  <Card
    title="Testing"
    description="Use DI for easy mocking and testing"
  />
  <Card
    title="Configuration"
    description="Use configuration injection for service settings"
  />
</Cards>

<Callout type="tip">
**Pro Tip**: Start with simple service registration and gradually add more advanced features like interceptors and lifecycle management as your application grows.
</Callout>
