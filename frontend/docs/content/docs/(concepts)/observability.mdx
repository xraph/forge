---
title: Observability
description: Learn about logging, metrics, and tracing in Forge Go
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Tab, Tabs } from 'fumadocs-ui/components/tabs'
import { Card, Cards } from 'fumadocs-ui/components/card'

# Observability

Forge Go provides built-in observability features including logging, metrics, and tracing to help you monitor and debug your applications.

## Built-in Logging

Forge includes a powerful logging system with configurable levels and formats:

```go
package main

import (
    "log"
    "github.com/xraph/forge"
)

func main() {
    app := forge.New(forge.Config{
        Name: "My App",
    })

    // Add logging middleware
    app.Use(forge.Logger())

    // Your routes
    app.GET("/", func(c *forge.Context) error {
        return c.JSON(200, map[string]string{
            "message": "Hello from Forge!",
        })
    })

    log.Fatal(app.Listen(":8080"))
}
```

### Log Levels

```go
// Configure log level
app.Use(forge.Logger(forge.LoggerConfig{
    Level:  "info", // debug, info, warn, error
    Format: "json", // json, text
}))
```

### Custom Logging

```go
import (
    "log/slog"
)

func customLogger() forge.HandlerFunc {
    return func(c *forge.Context) error {
        start := time.Now()
        
        // Process request
        err := c.Next()
        
        // Log request details
        duration := time.Since(start)
        slog.Info("Request completed",
            "method", c.Request.Method,
            "path", c.Request.URL.Path,
            "status", c.Response.Status,
            "duration", duration,
            "userAgent", c.Request.UserAgent(),
        )
        
        return err
    }
}
```

## Metrics

### Built-in Metrics

```go
package main

import (
    "log"
    "github.com/xraph/forge"
    "github.com/xraph/forge/plugins/observability"
)

func main() {
    app := forge.New(forge.Config{
        Name: "My App",
    })

    // Add observability plugin
    obsPlugin := observability.New(observability.Config{
        Metrics: true,
    })
    app.Use(obsPlugin)

    // Your routes
    app.GET("/", func(c *forge.Context) error {
        return c.JSON(200, map[string]string{
            "message": "Hello from Forge!",
        })
    })

    log.Fatal(app.Listen(":8080"))
}
```

### Custom Metrics

```go
import (
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

var (
    // HTTP request counter
    httpRequestsTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "http_requests_total",
            Help: "Total number of HTTP requests",
        },
        []string{"method", "path", "status"},
    )

    // HTTP request duration histogram
    httpRequestDuration = promauto.NewHistogramVec(
        prometheus.HistogramOpts{
            Name: "http_request_duration_seconds",
            Help: "HTTP request duration in seconds",
        },
        []string{"method", "path"},
    )
)

func metricsMiddleware() forge.HandlerFunc {
    return func(c *forge.Context) error {
        start := time.Now()
        
        // Process request
        err := c.Next()
        
        // Record metrics
        duration := time.Since(start).Seconds()
        status := strconv.Itoa(c.Response.Status)
        
        httpRequestsTotal.WithLabelValues(
            c.Request.Method,
            c.Request.URL.Path,
            status,
        ).Inc()
        
        httpRequestDuration.WithLabelValues(
            c.Request.Method,
            c.Request.URL.Path,
        ).Observe(duration)
        
        return err
    }
}
```

## Tracing

### OpenTelemetry Integration

```go
package main

import (
    "log"
    "github.com/xraph/forge"
    "github.com/xraph/forge/plugins/observability"
)

func main() {
    app := forge.New(forge.Config{
        Name: "My App",
    })

    // Add observability plugin with tracing
    obsPlugin := observability.New(observability.Config{
        Tracing: true,
    })
    app.Use(obsPlugin)

    // Your routes
    app.GET("/", func(c *forge.Context) error {
        return c.JSON(200, map[string]string{
            "message": "Hello from Forge!",
        })
    })

    log.Fatal(app.Listen(":8080"))
}
```

### Custom Tracing

```go
import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/trace"
)

func tracingMiddleware() forge.HandlerFunc {
    return func(c *forge.Context) error {
        // Start span
        tracer := otel.Tracer("forge-app")
        ctx, span := tracer.Start(c.Request.Context(), "http_request")
        defer span.End()

        // Add span attributes
        span.SetAttributes(
            attribute.String("http.method", c.Request.Method),
            attribute.String("http.url", c.Request.URL.String()),
            attribute.String("http.user_agent", c.Request.UserAgent()),
        )

        // Update context
        c.Request = c.Request.WithContext(ctx)

        // Process request
        err := c.Next()

        // Add response attributes
        span.SetAttributes(
            attribute.Int("http.status_code", c.Response.Status),
        )

        return err
    }
}
```

## Health Checks

### Basic Health Check

```go
func healthCheckHandler(c *forge.Context) error {
    return c.JSON(200, map[string]string{
        "status": "healthy",
        "timestamp": time.Now().Format(time.RFC3339),
    })
}

// Add health check route
app.GET("/health", healthCheckHandler)
```

### Advanced Health Check

```go
type HealthChecker interface {
    Check() error
}

type DatabaseHealthChecker struct {
    db *sql.DB
}

func (h *DatabaseHealthChecker) Check() error {
    return h.db.Ping()
}

type RedisHealthChecker struct {
    client *redis.Client
}

func (h *RedisHealthChecker) Check() error {
    return h.client.Ping().Err()
}

func advancedHealthCheckHandler(c *forge.Context) error {
    checks := map[string]error{
        "database": dbChecker.Check(),
        "redis":    redisChecker.Check(),
    }

    status := "healthy"
    for name, err := range checks {
        if err != nil {
            status = "unhealthy"
            break
        }
    }

    return c.JSON(200, map[string]interface{}{
        "status": status,
        "checks": checks,
        "timestamp": time.Now().Format(time.RFC3339),
    })
}
```

## Request ID

### Generate Request ID

```go
import (
    "crypto/rand"
    "encoding/hex"
)

func requestIDMiddleware() forge.HandlerFunc {
    return func(c *forge.Context) error {
        // Generate request ID
        requestID := generateRequestID()
        
        // Set in context
        c.Set("requestID", requestID)
        
        // Set in response header
        c.Response.Header().Set("X-Request-ID", requestID)
        
        return c.Next()
    }
}

func generateRequestID() string {
    bytes := make([]byte, 16)
    rand.Read(bytes)
    return hex.EncodeToString(bytes)
}
```

## Error Tracking

### Error Logging

```go
func errorTrackingMiddleware() forge.HandlerFunc {
    return func(c *forge.Context) error {
        err := c.Next()
        
        if err != nil {
            // Log error with context
            slog.Error("Request error",
                "error", err.Error(),
                "method", c.Request.Method,
                "path", c.Request.URL.Path,
                "requestID", c.Get("requestID"),
                "userAgent", c.Request.UserAgent(),
            )
        }
        
        return err
    }
}
```

## Performance Monitoring

### Response Time Tracking

```go
func performanceMiddleware() forge.HandlerFunc {
    return func(c *forge.Context) error {
        start := time.Now()
        
        err := c.Next()
        
        duration := time.Since(start)
        
        // Log slow requests
        if duration > 1*time.Second {
            slog.Warn("Slow request",
                "method", c.Request.Method,
                "path", c.Request.URL.Path,
                "duration", duration,
            )
        }
        
        return err
    }
}
```

## Structured Logging

### JSON Logging

```go
import (
    "log/slog"
    "os"
)

func setupStructuredLogging() {
    // Configure JSON logging
    handler := slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
        Level: slog.LevelInfo,
    })
    logger := slog.New(handler)
    slog.SetDefault(logger)
}

func structuredLoggingMiddleware() forge.HandlerFunc {
    return func(c *forge.Context) error {
        start := time.Now()
        
        err := c.Next()
        
        duration := time.Since(start)
        
        slog.Info("Request completed",
            "method", c.Request.Method,
            "path", c.Request.URL.Path,
            "status", c.Response.Status,
            "duration", duration,
            "requestID", c.Get("requestID"),
            "userAgent", c.Request.UserAgent(),
            "remoteAddr", c.Request.RemoteAddr,
        )
        
        return err
    }
}
```

## Best Practices

<Cards>
  <Card
    title="Structured Logging"
    description="Use structured logging with consistent fields for better searchability"
  />
  <Card
    title="Request ID"
    description="Generate unique request IDs to track requests across services"
  />
  <Card
    title="Health Checks"
    description="Implement health checks for all external dependencies"
  />
  <Card
    title="Metrics"
    description="Collect relevant metrics for monitoring and alerting"
  />
  <Card
    title="Error Tracking"
    description="Log errors with sufficient context for debugging"
  />
  <Card
    title="Performance"
    description="Monitor response times and identify slow requests"
  />
</Cards>

<Callout type="tip">
**Pro Tip**: Start with basic logging and gradually add metrics and tracing as your application grows. Use the built-in observability plugin for quick setup.
</Callout>
