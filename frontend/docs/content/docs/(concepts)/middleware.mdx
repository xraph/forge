---
title: Middleware
description: Learn how to use and create middleware in Forge Go
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Tab, Tabs } from 'fumadocs-ui/components/tabs'
import { Card, Cards } from 'fumadocs-ui/components/card'

# Middleware

Middleware in Forge Go are functions that execute during the request-response cycle. They provide a way to add cross-cutting concerns like logging, authentication, CORS, and more to your application.

## Built-in Middleware

Forge comes with several built-in middleware that you can use out of the box:

<Cards>
  <Card
    title="Logger"
    description="Logs HTTP requests and responses with configurable levels and formats"
  />
  <Card
    title="Recovery"
    description="Recovers from panics and provides graceful error handling"
  />
  <Card
    title="CORS"
    description="Handles Cross-Origin Resource Sharing (CORS) requests"
  />
  <Card
    title="RateLimit"
    description="Implements rate limiting to prevent abuse"
  />
</Cards>

## Using Built-in Middleware

```go
package main

import (
    "log"
    "github.com/xraph/forge"
)

func main() {
    app := forge.New(forge.Config{
        Name: "My App",
    })

    // Add middleware in order
    app.Use(forge.Logger())
    app.Use(forge.Recovery())
    app.Use(forge.CORS())
    app.Use(forge.RateLimit())

    // Your routes
    app.GET("/", func(c *forge.Context) error {
        return c.JSON(200, map[string]string{
            "message": "Hello from Forge!",
        })
    })

    log.Fatal(app.Listen(":8080"))
}
```

## Creating Custom Middleware

You can create custom middleware by implementing the `forge.HandlerFunc` interface:

```go
package main

import (
    "log"
    "time"
    "github.com/xraph/forge"
)

// RequestID middleware adds a unique request ID to each request
func RequestID() forge.HandlerFunc {
    return func(c *forge.Context) error {
        requestID := c.Request.Header.Get("X-Request-ID")
        if requestID == "" {
            requestID = generateRequestID()
        }
        
        c.Set("requestId", requestID)
        c.Response.Header().Set("X-Request-ID", requestID)
        
        return c.Next()
    }
}

// Timing middleware measures request duration
func Timing() forge.HandlerFunc {
    return func(c *forge.Context) error {
        start := time.Now()
        
        err := c.Next()
        
        duration := time.Since(start)
        c.Set("duration", duration)
        
        log.Printf("Request completed in %v", duration)
        return err
    }
}

func main() {
    app := forge.New(forge.Config{
        Name: "My App",
    })

    // Add custom middleware
    app.Use(RequestID())
    app.Use(Timing())
    app.Use(forge.Logger())

    app.GET("/", func(c *forge.Context) error {
        return c.JSON(200, map[string]interface{}{
            "message":    "Hello from Forge!",
            "requestId":  c.Get("requestId"),
            "duration":   c.Get("duration"),
        })
    })

    log.Fatal(app.Listen(":8080"))
}
```

## Middleware Order

<Callout type="warn">
**Important**: Middleware order matters! Middleware is executed in the order it's added.
</Callout>

```go
// Correct order
app.Use(forge.Logger())     // 1. Log the request
app.Use(forge.Recovery())   // 2. Handle panics
app.Use(forge.CORS())       // 3. Handle CORS
app.Use(forge.RateLimit())  // 4. Apply rate limiting
app.Use(AuthMiddleware())   // 5. Authenticate user
app.Use(LoggingMiddleware()) // 6. Custom logging
```

## Middleware Groups

You can apply middleware to specific route groups:

```go
// Global middleware
app.Use(forge.Logger())
app.Use(forge.Recovery())

// Public routes
app.GET("/", homeHandler)
app.GET("/health", healthHandler)

// Protected routes with auth middleware
protected := app.Group("/api", AuthMiddleware())
protected.GET("/users", getUsersHandler)
protected.POST("/users", createUserHandler)

// Admin routes with additional middleware
admin := protected.Group("/admin", AdminMiddleware())
admin.GET("/stats", getStatsHandler)
admin.DELETE("/users/:id", deleteUserHandler)
```

## Error Handling in Middleware

```go
func ErrorHandler() forge.HandlerFunc {
    return func(c *forge.Context) error {
        defer func() {
            if r := recover(); r != nil {
                log.Printf("Panic recovered: %v", r)
                c.JSON(500, map[string]string{
                    "error": "Internal server error",
                })
            }
        }()
        
        return c.Next()
    }
}
```

## Conditional Middleware

```go
func ConditionalAuth() forge.HandlerFunc {
    return func(c *forge.Context) error {
        // Skip auth for certain paths
        if c.Request.URL.Path == "/health" || c.Request.URL.Path == "/metrics" {
            return c.Next()
        }
        
        // Apply auth for other paths
        return AuthMiddleware()(c)
    }
}
```

## Best Practices

<Cards>
  <Card
    title="Order Matters"
    description="Place middleware in logical order: logging, recovery, CORS, auth, business logic"
  />
  <Card
    title="Keep It Simple"
    description="Each middleware should have a single responsibility"
  />
  <Card
    title="Handle Errors"
    description="Always handle errors properly and don't let panics crash your app"
  />
  <Card
    title="Use Context"
    description="Use the context to pass data between middleware and handlers"
  />
</Cards>

<Callout type="tip">
**Pro Tip**: Start with built-in middleware and only create custom middleware when you need specific functionality not provided by Forge.
</Callout>
