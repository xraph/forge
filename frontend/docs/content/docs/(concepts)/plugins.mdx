---
title: Plugins
description: Learn how to use and create plugins in Forge Go
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Tab, Tabs } from 'fumadocs-ui/components/tabs'
import { Card, Cards } from 'fumadocs-ui/components/card'

# Plugins

Forge Go provides a powerful plugin system that allows you to extend the framework with additional functionality. Plugins can add middleware, routes, and services to your application.

## Built-in Plugins

Forge comes with several built-in plugins:

<Cards>
  <Card
    title="Database"
    description="Database integration with connection pooling and migrations"
  />
  <Card
    title="Observability"
    description="Metrics, logging, and tracing capabilities"
  />
  <Card
    title="Security"
    description="Authentication, authorization, and security middleware"
  />
  <Card
    title="Caching"
    description="Redis and in-memory caching support"
  />
</Cards>

## Using Plugins

### Database Plugin

```go
package main

import (
    "log"
    "github.com/xraph/forge"
    "github.com/xraph/forge/plugins/database"
)

func main() {
    app := forge.New(forge.Config{
        Name: "My App",
    })

    // Add database plugin
    dbPlugin := database.New(database.Config{
        URL: "postgres://user:pass@localhost/db?sslmode=disable",
    })
    app.Use(dbPlugin)

    // Your routes
    app.GET("/", func(c *forge.Context) error {
        return c.JSON(200, map[string]string{
            "message": "Hello from Forge!",
        })
    })

    log.Fatal(app.Listen(":8080"))
}
```

### Observability Plugin

```go
package main

import (
    "log"
    "github.com/xraph/forge"
    "github.com/xraph/forge/plugins/observability"
)

func main() {
    app := forge.New(forge.Config{
        Name: "My App",
    })

    // Add observability plugin
    obsPlugin := observability.New(observability.Config{
        Metrics: true,
        Tracing: true,
        Logging: true,
    })
    app.Use(obsPlugin)

    // Your routes
    app.GET("/", func(c *forge.Context) error {
        return c.JSON(200, map[string]string{
            "message": "Hello from Forge!",
        })
    })

    log.Fatal(app.Listen(":8080"))
}
```

## Creating Custom Plugins

### Basic Plugin Structure

```go
package main

import (
    "github.com/xraph/forge"
)

// MyPlugin represents a custom plugin
type MyPlugin struct {
    config Config
}

// Config holds the plugin configuration
type Config struct {
    Option1 string
    Option2 int
    Option3 bool
}

// New creates a new instance of the plugin
func New(config Config) *MyPlugin {
    return &MyPlugin{
        config: config,
    }
}

// Install implements the forge.Plugin interface
func (p *MyPlugin) Install(app *forge.App) error {
    // Add middleware
    app.Use(p.middleware())
    
    // Add routes
    app.GET("/plugin/status", p.statusHandler)
    
    return nil
}

// middleware returns the plugin middleware
func (p *MyPlugin) middleware() forge.HandlerFunc {
    return func(c *forge.Context) error {
        // Plugin logic here
        c.Set("plugin", "MyPlugin")
        return c.Next()
    }
}

// statusHandler handles the plugin status endpoint
func (p *MyPlugin) statusHandler(c *forge.Context) error {
    return c.JSON(200, map[string]interface{}{
        "plugin": "MyPlugin",
        "config": p.config,
    })
}
```

### Advanced Plugin with Services

```go
package main

import (
    "context"
    "github.com/xraph/forge"
)

// AdvancedPlugin represents a more complex plugin
type AdvancedPlugin struct {
    config  Config
    service *Service
}

// Service provides plugin functionality
type Service struct {
    data map[string]interface{}
}

// NewService creates a new service instance
func NewService() *Service {
    return &Service{
        data: make(map[string]interface{}),
    }
}

// GetData retrieves data from the service
func (s *Service) GetData(key string) (interface{}, bool) {
    value, exists := s.data[key]
    return value, exists
}

// SetData stores data in the service
func (s *Service) SetData(key string, value interface{}) {
    s.data[key] = value
}

// New creates a new advanced plugin
func New(config Config) *AdvancedPlugin {
    return &AdvancedPlugin{
        config:  config,
        service: NewService(),
    }
}

// Install implements the forge.Plugin interface
func (p *AdvancedPlugin) Install(app *forge.App) error {
    // Add middleware
    app.Use(p.middleware())
    
    // Add routes
    app.GET("/plugin/data/:key", p.getDataHandler)
    app.POST("/plugin/data/:key", p.setDataHandler)
    
    // Register service in context
    app.Use(func(c *forge.Context) error {
        c.Set("pluginService", p.service)
        return c.Next()
    })
    
    return nil
}

// middleware returns the plugin middleware
func (p *AdvancedPlugin) middleware() forge.HandlerFunc {
    return func(c *forge.Context) error {
        // Plugin logic here
        c.Set("plugin", "AdvancedPlugin")
        return c.Next()
    }
}

// getDataHandler retrieves data
func (p *AdvancedPlugin) getDataHandler(c *forge.Context) error {
    key := c.Param("key")
    value, exists := p.service.GetData(key)
    
    if !exists {
        return c.JSON(404, map[string]string{
            "error": "Key not found",
        })
    }
    
    return c.JSON(200, map[string]interface{}{
        "key":   key,
        "value": value,
    })
}

// setDataHandler stores data
func (p *AdvancedPlugin) setDataHandler(c *forge.Context) error {
    key := c.Param("key")
    
    var data interface{}
    if err := c.BindJSON(&data); err != nil {
        return c.JSON(400, map[string]string{
            "error": "Invalid JSON",
        })
    }
    
    p.service.SetData(key, data)
    
    return c.JSON(200, map[string]string{
        "message": "Data stored successfully",
    })
}
```

## Plugin Lifecycle

```go
// Plugin lifecycle methods
type Plugin interface {
    // Install is called when the plugin is installed
    Install(app *forge.App) error
    
    // Uninstall is called when the plugin is removed
    Uninstall(app *forge.App) error
    
    // Name returns the plugin name
    Name() string
    
    // Version returns the plugin version
    Version() string
}
```

## Plugin Configuration

```go
// Plugin configuration from YAML
type PluginConfig struct {
    Name    string                 `yaml:"name"`
    Enabled bool                   `yaml:"enabled"`
    Config  map[string]interface{} `yaml:"config"`
}

// Load plugin configuration
func loadPluginConfig(filename string) ([]PluginConfig, error) {
    // Load from YAML file
    // Return plugin configurations
}
```

## Plugin Dependencies

```go
// Plugin with dependencies
type DependentPlugin struct {
    config     Config
    dbPlugin   *database.Plugin
    cachePlugin *cache.Plugin
}

// New creates a plugin with dependencies
func New(config Config, dbPlugin *database.Plugin, cachePlugin *cache.Plugin) *DependentPlugin {
    return &DependentPlugin{
        config:      config,
        dbPlugin:    dbPlugin,
        cachePlugin: cachePlugin,
    }
}

// Install with dependency checks
func (p *DependentPlugin) Install(app *forge.App) error {
    // Check if dependencies are available
    if p.dbPlugin == nil {
        return fmt.Errorf("database plugin is required")
    }
    
    if p.cachePlugin == nil {
        return fmt.Errorf("cache plugin is required")
    }
    
    // Install plugin
    return p.install(app)
}
```

## Best Practices

<Cards>
  <Card
    title="Single Responsibility"
    description="Each plugin should have a single, well-defined purpose"
  />
  <Card
    title="Configuration"
    description="Make plugins configurable through configuration files"
  />
  <Card
    title="Error Handling"
    description="Handle errors gracefully and provide meaningful error messages"
  />
  <Card
    title="Documentation"
    description="Document plugin usage and configuration options"
  />
</Cards>

<Callout type="tip">
**Pro Tip**: Start with simple plugins and gradually add complexity. Use the built-in plugins as examples for your custom plugins.
</Callout>
