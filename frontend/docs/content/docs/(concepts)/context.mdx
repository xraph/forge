---
title: Context
description: Learn how to use the Forge Context for request handling and data passing
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Tab, Tabs } from 'fumadocs-ui/components/tabs'
import { Card, Cards } from 'fumadocs-ui/components/card'

# Context

The Forge Context (`forge.Context`) is the central object that provides access to the HTTP request, response, and various utilities for handling web requests.

## Basic Usage

```go
func handler(c *forge.Context) error {
    // Access request information
    method := c.Request.Method
    path := c.Request.URL.Path
    
    // Send response
    return c.JSON(200, map[string]string{
        "method": method,
        "path": path,
    })
}
```

## Request Information

### HTTP Method and URL

```go
func requestInfoHandler(c *forge.Context) error {
    return c.JSON(200, map[string]interface{}{
        "method":      c.Request.Method,
        "url":         c.Request.URL.String(),
        "path":        c.Request.URL.Path,
        "query":       c.Request.URL.RawQuery,
        "fragment":    c.Request.URL.Fragment,
        "host":        c.Request.Host,
        "remoteAddr":  c.Request.RemoteAddr,
        "userAgent":   c.Request.UserAgent(),
        "referer":     c.Request.Referer(),
    })
}
```

### Headers

```go
func headersHandler(c *forge.Context) error {
    // Get specific header
    contentType := c.Request.Header.Get("Content-Type")
    authorization := c.Request.Header.Get("Authorization")
    
    // Get all headers
    allHeaders := c.Request.Header
    
    return c.JSON(200, map[string]interface{}{
        "contentType":   contentType,
        "authorization": authorization,
        "allHeaders":    allHeaders,
    })
}
```

### Query Parameters

```go
func queryHandler(c *forge.Context) error {
    // Get query parameters
    page := c.Query("page")
    limit := c.Query("limit")
    
    // Get query with default value
    pageWithDefault := c.QueryDefault("page", "1")
    
    // Get all query parameters
    queryParams := c.Request.URL.Query()
    
    return c.JSON(200, map[string]interface{}{
        "page":           page,
        "limit":          limit,
        "pageWithDefault": pageWithDefault,
        "allParams":      queryParams,
    })
}
```

### Path Parameters

```go
func pathParamsHandler(c *forge.Context) error {
    // Get path parameters
    id := c.Param("id")
    postId := c.Param("postId")
    
    return c.JSON(200, map[string]string{
        "id":     id,
        "postId": postId,
    })
}
```

## Request Body

### JSON Binding

```go
type User struct {
    Name  string `json:"name"`
    Email string `json:"email"`
    Age   int    `json:"age"`
}

func createUserHandler(c *forge.Context) error {
    var user User
    
    // Bind JSON to struct
    if err := c.BindJSON(&user); err != nil {
        return c.JSON(400, map[string]string{
            "error": "Invalid JSON",
        })
    }
    
    return c.JSON(201, map[string]interface{}{
        "message": "User created",
        "user":    user,
    })
}
```

### Form Data

```go
func formHandler(c *forge.Context) error {
    // Get form values
    name := c.FormValue("name")
    email := c.FormValue("email")
    
    // Get all form values
    form := c.Request.Form
    
    return c.JSON(200, map[string]interface{}{
        "name":  name,
        "email": email,
        "form":  form,
    })
}
```

### File Upload

```go
func uploadHandler(c *forge.Context) error {
    // Get uploaded file
    file, header, err := c.Request.FormFile("file")
    if err != nil {
        return c.JSON(400, map[string]string{
            "error": "No file uploaded",
        })
    }
    defer file.Close()
    
    return c.JSON(200, map[string]interface{}{
        "filename":    header.Filename,
        "size":        header.Size,
        "contentType": header.Header.Get("Content-Type"),
    })
}
```

## Response Handling

### JSON Response

```go
func jsonHandler(c *forge.Context) error {
    data := map[string]interface{}{
        "message": "Hello World",
        "timestamp": time.Now().Unix(),
    }
    
    return c.JSON(200, data)
}
```

### HTML Response

```go
func htmlHandler(c *forge.Context) error {
    html := `
    <!DOCTYPE html>
    <html>
    <head>
        <title>Forge Go</title>
    </head>
    <body>
        <h1>Hello from Forge!</h1>
    </body>
    </html>
    `
    
    return c.HTML(200, html)
}
```

### File Response

```go
func fileHandler(c *forge.Context) error {
    // Serve static file
    return c.File("./static/index.html")
}

func downloadHandler(c *forge.Context) error {
    // Force download
    return c.Attachment("./files/document.pdf", "document.pdf")
}
```

### Redirect

```go
func redirectHandler(c *forge.Context) error {
    // Temporary redirect
    return c.Redirect(302, "/new-location")
    
    // Permanent redirect
    return c.Redirect(301, "/permanent-location")
}
```

## Context Values

The context allows you to store and retrieve values during the request lifecycle:

```go
func middleware(c *forge.Context) error {
    // Set values
    c.Set("userID", "123")
    c.Set("requestID", "req-456")
    c.Set("startTime", time.Now())
    
    return c.Next()
}

func handler(c *forge.Context) error {
    // Get values
    userID := c.Get("userID")
    requestID := c.Get("requestID")
    startTime := c.Get("startTime")
    
    return c.JSON(200, map[string]interface{}{
        "userID":    userID,
        "requestID": requestID,
        "startTime": startTime,
    })
}
```

## Response Headers

```go
func headersHandler(c *forge.Context) error {
    // Set response headers
    c.Response.Header().Set("Content-Type", "application/json")
    c.Response.Header().Set("X-Custom-Header", "custom-value")
    c.Response.Header().Set("Cache-Control", "no-cache")
    
    return c.JSON(200, map[string]string{
        "message": "Headers set",
    })
}
```

## Status Codes

```go
func statusCodesHandler(c *forge.Context) error {
    // Success responses
    return c.JSON(200, map[string]string{"status": "OK"})
    return c.JSON(201, map[string]string{"status": "Created"})
    return c.JSON(204, nil) // No content
    
    // Error responses
    return c.JSON(400, map[string]string{"error": "Bad Request"})
    return c.JSON(401, map[string]string{"error": "Unauthorized"})
    return c.JSON(404, map[string]string{"error": "Not Found"})
    return c.JSON(500, map[string]string{"error": "Internal Server Error"})
}
```

## Error Handling

```go
func errorHandler(c *forge.Context) error {
    // Return error with status code
    return c.JSON(400, map[string]string{
        "error": "Invalid request",
    })
    
    // Return error without response
    return c.Error(500, "Internal server error")
}
```

## Middleware Integration

```go
func loggingMiddleware(c *forge.Context) error {
    start := time.Now()
    
    // Process request
    err := c.Next()
    
    // Log after processing
    duration := time.Since(start)
    log.Printf("Request %s %s completed in %v", 
        c.Request.Method, c.Request.URL.Path, duration)
    
    return err
}
```

## Best Practices

<Cards>
  <Card
    title="Use Context Values"
    description="Store request-specific data in context for access across middleware and handlers"
  />
  <Card
    title="Proper Error Handling"
    description="Always return appropriate HTTP status codes and error messages"
  />
  <Card
    title="Validate Input"
    description="Validate and sanitize all input data before processing"
  />
  <Card
    title="Set Headers"
    description="Set appropriate response headers for security and caching"
  />
</Cards>

<Callout type="tip">
**Pro Tip**: Use context values to pass data between middleware and handlers, making your code more maintainable and testable.
</Callout>
