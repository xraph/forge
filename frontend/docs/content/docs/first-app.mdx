---
title: Your First App
description: Build a complete web application with Forge Go from scratch
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Tab, Tabs } from 'fumadocs-ui/components/tabs'
import { Card, Cards } from 'fumadocs-ui/components/card'

# Your First App

In this tutorial, you'll build a complete web application using Forge Go. We'll create a simple blog application with routing, middleware, database integration, and a clean architecture.

## What You'll Build

By the end of this tutorial, you'll have:

- âœ… RESTful API with proper routing
- âœ… Database integration with connection pooling
- âœ… Middleware for logging, CORS, and rate limiting
- âœ… Clean architecture with service layer
- âœ… Error handling and validation
- âœ… Basic CRUD operations for blog posts

<Callout type="info">
**Prerequisites**: Make sure you have Go 1.21+, PostgreSQL, and completed the [Installation](/docs/go/getting-started/installation) guide.
</Callout>

## Project Setup

Let's start by creating a new Go project:

```bash
mkdir blog-app
cd blog-app
go mod init blog-app

# Install dependencies
go get github.com/xraph/forge
go get github.com/lib/pq
go get github.com/jmoiron/sqlx
```

Create the basic project structure:

```bash
mkdir -p {cmd,internal/{handlers,services,models,middleware},web/{templates,static},migrations}
touch cmd/main.go
touch internal/handlers/blog.go
touch internal/services/blog.go
touch internal/models/blog.go
touch internal/middleware/cors.go
```

## Database Setup

First, create a PostgreSQL database:

```sql
CREATE DATABASE blog_app;
CREATE USER blog_user WITH PASSWORD 'blog_password';
GRANT ALL PRIVILEGES ON DATABASE blog_app TO blog_user;
```

Create a `.env` file for configuration:

```bash
# Database
DATABASE_URL=postgres://blog_user:blog_password@localhost:5432/blog_app?sslmode=disable

# Server Configuration
PORT=8080
HOST=localhost

# Logging
LOG_LEVEL=info
LOG_FORMAT=json

# Optional: Redis for caching
REDIS_URL=redis://localhost:6379
```

## Main Application

Create the main application file:

<Tabs items={['cmd/main.go', 'Configuration', 'Error Handling']}>
  <Tab value="cmd/main.go">
    ```go
    package main

    import (
        "context"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/jmoiron/sqlx"
        "github.com/xraph/forge"
        "blog-app/internal/handlers"
        "blog-app/internal/services"
        "blog-app/internal/middleware"
    )

    func main() {
        // Load environment variables
        if err := loadEnv(); err != nil {
            log.Fatalf("Failed to load environment: %v", err)
        }

        // Create Forge application
        app := forge.New(forge.Config{
            Name:    "Blog App",
            Version: "1.0.0",
        })

        // Initialize database
        db, err := initDatabase()
        if err != nil {
            log.Fatalf("Failed to initialize database: %v", err)
        }
        defer db.Close()

        // Run database migrations
        if err := runMigrations(db); err != nil {
            log.Fatalf("Failed to run migrations: %v", err)
        }

        // Initialize services
        blogService := services.NewBlogService(db)

        // Initialize handlers
        blogHandler := handlers.NewBlogHandler(blogService)

        // Setup middleware
        setupMiddleware(app)

        // Setup routes
        setupRoutes(app, blogHandler)

        // Start server
        port := getEnv("PORT", "8080")
        log.Printf("Starting server on port %s", port)
        
        if err := startServer(app, port); err != nil {
            log.Fatalf("Server failed: %v", err)
        }
    }

    // initDatabase initializes database connection
    func initDatabase() (*sqlx.DB, error) {
        dbURL := getEnv("DATABASE_URL", "")
        if dbURL == "" {
            return nil, fmt.Errorf("DATABASE_URL is required")
        }

        db, err := sqlx.Connect("postgres", dbURL)
        if err != nil {
            return nil, fmt.Errorf("failed to connect to database: %w", err)
        }

        // Configure connection pool
        db.SetMaxOpenConns(25)
        db.SetMaxIdleConns(5)
        db.SetConnMaxLifetime(time.Hour)

        return db, nil
    }

    // setupMiddleware configures global middleware
    func setupMiddleware(app *forge.App) {
        app.Use(forge.Logger())
        app.Use(forge.Recovery())
        app.Use(forge.CORS())
        app.Use(middleware.RequestID())
    }

    // setupRoutes configures all application routes
    func setupRoutes(app *forge.App, blogHandler *handlers.BlogHandler) {
        // API routes
        api := app.Group("/api/v1")
        
        // Blog routes
        api.GET("/posts", blogHandler.GetPosts)
        api.GET("/posts/:id", blogHandler.GetPost)
        api.POST("/posts", blogHandler.CreatePost)
        api.PUT("/posts/:id", blogHandler.UpdatePost)
        api.DELETE("/posts/:id", blogHandler.DeletePost)
        
        // Health check
        app.GET("/health", func(c *forge.Context) error {
            return c.JSON(200, map[string]string{"status": "healthy"})
        })
        
        // Static files
        app.Static("/static", "./web/static")
    }

    // startServer starts the HTTP server with graceful shutdown
    func startServer(app *forge.App, port string) error {
        server := &http.Server{
            Addr:    ":" + port,
            Handler: app,
        }

        // Start server in a goroutine
        go func() {
            if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
                log.Fatalf("Server failed to start: %v", err)
            }
        }()

        // Wait for interrupt signal to gracefully shutdown
        quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        <-quit

        log.Println("Shutting down server...")

        // Graceful shutdown with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        return server.Shutdown(ctx)
    }

    // runMigrations runs database migrations
    func runMigrations(db *sqlx.DB) error {
        // Create posts table
        query := `
        CREATE TABLE IF NOT EXISTS posts (
            id SERIAL PRIMARY KEY,
            title VARCHAR(255) NOT NULL,
            content TEXT NOT NULL,
            author VARCHAR(100) NOT NULL,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );`
        
        _, err := db.Exec(query)
        return err
    }

    // Helper functions
    func getEnv(key, defaultValue string) string {
        if value := os.Getenv(key); value != "" {
            return value
        }
        return defaultValue
    }

    func loadEnv() error {
        // Simple .env file loader (you can use a library like godotenv)
        // For simplicity, we'll rely on environment variables being set
        return nil
    }
    ```
  </Tab>
  <Tab value="Configuration">
    The configuration demonstrates several important concepts:

    **Database Connection**: Using PostgreSQL with connection pooling
    ```go
    db, err := sqlx.Connect("postgres", dbURL)
    db.SetMaxOpenConns(25)
    db.SetMaxIdleConns(5)
    db.SetConnMaxLifetime(time.Hour)
    ```

    **Forge Application**: Clean application setup
    ```go
    app := forge.New(forge.Config{
        Name:    "Blog App",
        Version: "1.0.0",
    })
    ```

    **Middleware Stack**: Essential middleware for production
    ```go
    app.Use(forge.Logger())
    app.Use(forge.Recovery())
    app.Use(forge.CORS())
    app.Use(middleware.RequestID())
    ```

    **Service Layer**: Clean separation of concerns
    ```go
    blogService := services.NewBlogService(db)
    blogHandler := handlers.NewBlogHandler(blogService)
    ```
  </Tab>
  <Tab value="Error Handling">
    The application includes proper error handling:

    **Startup Errors**: Fail fast if configuration is invalid
    ```go
    if err := runMigrations(db); err != nil {
        log.Fatalf("Failed to run migrations: %v", err)
    }
    ```

    **Database Errors**: Proper error wrapping and context
    ```go
    db, err := sqlx.Connect("postgres", dbURL)
    if err != nil {
        return nil, fmt.Errorf("failed to connect to database: %w", err)
    }
    ```

    **Graceful Shutdown**: Handle interrupts properly
    ```go
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit

    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()
    return server.Shutdown(ctx)
    ```

    **Environment Validation**: Provide defaults and validate required values
    ```go
    func getEnv(key, defaultValue string) string {
        if value := os.Getenv(key); value != "" {
            return value
        }
        return defaultValue
    }
    ```
  </Tab>
</Tabs>

## Blog Models

Create the blog post model:

    ```go
// internal/models/blog.go
package models

    import (
    "time"
)

// Post represents a blog post
type Post struct {
    ID        int       `json:"id" db:"id"`
    Title     string    `json:"title" db:"title"`
    Content   string    `json:"content" db:"content"`
    Author    string    `json:"author" db:"author"`
    CreatedAt time.Time `json:"created_at" db:"created_at"`
    UpdatedAt time.Time `json:"updated_at" db:"updated_at"`
}

// CreatePostRequest represents the request to create a new post
type CreatePostRequest struct {
    Title   string `json:"title" validate:"required,min=1,max=255"`
    Content string `json:"content" validate:"required,min=1"`
    Author  string `json:"author" validate:"required,min=1,max=100"`
}

// UpdatePostRequest represents the request to update a post
type UpdatePostRequest struct {
    Title   string `json:"title" validate:"omitempty,min=1,max=255"`
    Content string `json:"content" validate:"omitempty,min=1"`
    Author  string `json:"author" validate:"omitempty,min=1,max=100"`
}
```

## Blog Service

Create the service layer for blog operations:

```go
// internal/services/blog.go
package services

import (
    "database/sql"
    "fmt"

    "github.com/jmoiron/sqlx"
    "blog-app/internal/models"
)

// BlogService handles blog-related business logic
type BlogService struct {
    db *sqlx.DB
}

// NewBlogService creates a new blog service
func NewBlogService(db *sqlx.DB) *BlogService {
    return &BlogService{db: db}
}

// GetPosts retrieves all blog posts
func (s *BlogService) GetPosts() ([]models.Post, error) {
    var posts []models.Post
    query := `SELECT id, title, content, author, created_at, updated_at FROM posts ORDER BY created_at DESC`
    err := s.db.Select(&posts, query)
    return posts, err
}

// GetPost retrieves a single blog post by ID
func (s *BlogService) GetPost(id int) (*models.Post, error) {
    var post models.Post
    query := `SELECT id, title, content, author, created_at, updated_at FROM posts WHERE id = $1`
    err := s.db.Get(&post, query, id)
    if err == sql.ErrNoRows {
        return nil, fmt.Errorf("post not found")
    }
    return &post, err
}

// CreatePost creates a new blog post
func (s *BlogService) CreatePost(req models.CreatePostRequest) (*models.Post, error) {
    query := `INSERT INTO posts (title, content, author) VALUES ($1, $2, $3) RETURNING id, created_at, updated_at`
    var post models.Post
    err := s.db.QueryRow(query, req.Title, req.Content, req.Author).Scan(
        &post.ID, &post.CreatedAt, &post.UpdatedAt,
    )
    if err != nil {
        return nil, err
    }
    
    post.Title = req.Title
    post.Content = req.Content
    post.Author = req.Author
    
    return &post, nil
}

// UpdatePost updates an existing blog post
func (s *BlogService) UpdatePost(id int, req models.UpdatePostRequest) (*models.Post, error) {
    // First check if post exists
    existing, err := s.GetPost(id)
        if err != nil {
        return nil, err
    }
    
    // Update only provided fields
    if req.Title != "" {
        existing.Title = req.Title
    }
    if req.Content != "" {
        existing.Content = req.Content
    }
    if req.Author != "" {
        existing.Author = req.Author
    }
    
    query := `UPDATE posts SET title = $1, content = $2, author = $3, updated_at = CURRENT_TIMESTAMP WHERE id = $4`
    _, err = s.db.Exec(query, existing.Title, existing.Content, existing.Author, id)
    if err != nil {
        return nil, err
    }
    
    return existing, nil
}

// DeletePost deletes a blog post
func (s *BlogService) DeletePost(id int) error {
    query := `DELETE FROM posts WHERE id = $1`
    result, err := s.db.Exec(query, id)
    if err != nil {
        return err
    }
    
    rowsAffected, err := result.RowsAffected()
    if err != nil {
        return err
    }
    
    if rowsAffected == 0 {
        return fmt.Errorf("post not found")
    }
    
    return nil
}
```

## Blog Handlers

Create handlers for blog API endpoints:

```go
// internal/handlers/blog.go
package handlers

import (
    "net/http"
    "strconv"
    
    "github.com/xraph/forge"
    "blog-app/internal/models"
    "blog-app/internal/services"
)

// BlogHandler handles blog-related HTTP requests
type BlogHandler struct {
    service *services.BlogService
}

// NewBlogHandler creates a new blog handler
func NewBlogHandler(service *services.BlogService) *BlogHandler {
    return &BlogHandler{service: service}
}

// GetPosts handles GET /api/v1/posts
func (h *BlogHandler) GetPosts(c *forge.Context) error {
    posts, err := h.service.GetPosts()
    if err != nil {
        return c.JSON(http.StatusInternalServerError, map[string]string{
            "error": "Failed to retrieve posts",
        })
    }
    
    return c.JSON(http.StatusOK, map[string]interface{}{
        "posts": posts,
        "count": len(posts),
    })
}

// GetPost handles GET /api/v1/posts/:id
func (h *BlogHandler) GetPost(c *forge.Context) error {
    idStr := c.Param("id")
    id, err := strconv.Atoi(idStr)
    if err != nil {
        return c.JSON(http.StatusBadRequest, map[string]string{
            "error": "Invalid post ID",
        })
    }
    
    post, err := h.service.GetPost(id)
    if err != nil {
        return c.JSON(http.StatusNotFound, map[string]string{
            "error": "Post not found",
        })
    }
    
    return c.JSON(http.StatusOK, post)
}

// CreatePost handles POST /api/v1/posts
func (h *BlogHandler) CreatePost(c *forge.Context) error {
    var req models.CreatePostRequest
    if err := c.BindJSON(&req); err != nil {
        return c.JSON(http.StatusBadRequest, map[string]string{
            "error": "Invalid request body",
        })
    }
    
    post, err := h.service.CreatePost(req)
    if err != nil {
        return c.JSON(http.StatusInternalServerError, map[string]string{
            "error": "Failed to create post",
        })
    }
    
    return c.JSON(http.StatusCreated, post)
}

// UpdatePost handles PUT /api/v1/posts/:id
func (h *BlogHandler) UpdatePost(c *forge.Context) error {
    idStr := c.Param("id")
    id, err := strconv.Atoi(idStr)
    if err != nil {
        return c.JSON(http.StatusBadRequest, map[string]string{
            "error": "Invalid post ID",
        })
    }
    
    var req models.UpdatePostRequest
    if err := c.BindJSON(&req); err != nil {
        return c.JSON(http.StatusBadRequest, map[string]string{
            "error": "Invalid request body",
        })
    }
    
    post, err := h.service.UpdatePost(id, req)
    if err != nil {
        return c.JSON(http.StatusNotFound, map[string]string{
            "error": "Post not found",
        })
    }
    
    return c.JSON(http.StatusOK, post)
}

// DeletePost handles DELETE /api/v1/posts/:id
func (h *BlogHandler) DeletePost(c *forge.Context) error {
    idStr := c.Param("id")
    id, err := strconv.Atoi(idStr)
    if err != nil {
        return c.JSON(http.StatusBadRequest, map[string]string{
            "error": "Invalid post ID",
        })
    }
    
    err = h.service.DeletePost(id)
    if err != nil {
        return c.JSON(http.StatusNotFound, map[string]string{
            "error": "Post not found",
        })
    }
    
    return c.JSON(http.StatusOK, map[string]string{
        "message": "Post deleted successfully",
    })
}
```

## Middleware

Create custom middleware for the application:

```go
// internal/middleware/cors.go
package middleware

import (
    "strconv"
    "time"
    "github.com/xraph/forge"
)

// RequestID adds a unique request ID to each request
func RequestID() forge.HandlerFunc {
    return func(c *forge.Context) error {
        requestID := c.Request.Header.Get("X-Request-ID")
        if requestID == "" {
            requestID = generateRequestID()
        }
        
        c.Set("requestId", requestID)
        c.Response.Header().Set("X-Request-ID", requestID)
    
    return c.Next()
    }
}

func generateRequestID() string {
    // Simple implementation - use a proper UUID library in production
    return "req_" + strconv.FormatInt(time.Now().UnixNano(), 36)
}
```

## Running the Application

Now let's run the application:

<Tabs items={['Start Server', 'Test API', 'Create Post', 'Test CRUD']}>
  <Tab value="Start Server">
    ```bash
    # Set environment variables
    export DATABASE_URL="postgres://blog_user:blog_password@localhost:5432/blog_app?sslmode=disable"
    export PORT="8080"

    # Run the application
    go run cmd/main.go
    ```

    You should see:
    ```
    Starting server on port 8080
    ```

    Visit http://localhost:8080/health to see your application!
  </Tab>
  <Tab value="Test API">
    Test the API endpoints:

    ```bash
    # Test health check
    curl -X GET http://localhost:8080/health

    # Test get all posts (should be empty initially)
    curl -X GET http://localhost:8080/api/v1/posts
    ```

    Expected responses:
    ```json
    // Health check
    {"status": "healthy"}

    // Posts (empty initially)
    {"posts": [], "count": 0}
    ```
  </Tab>
  <Tab value="Create Post">
    Create a new blog post:

```bash
    curl -X POST http://localhost:8080/api/v1/posts \
  -H "Content-Type: application/json" \
  -d '{
        "title": "My First Post",
        "content": "This is the content of my first blog post!",
        "author": "John Doe"
      }'
    ```

    Expected response:
    ```json
    {
      "id": 1,
      "title": "My First Post",
      "content": "This is the content of my first blog post!",
      "author": "John Doe",
      "created_at": "2024-01-15T10:30:00Z",
      "updated_at": "2024-01-15T10:30:00Z"
    }
    ```
  </Tab>
  <Tab value="Test CRUD">
    Test all CRUD operations:

    ```bash
    # Get all posts
    curl -X GET http://localhost:8080/api/v1/posts

    # Get specific post
    curl -X GET http://localhost:8080/api/v1/posts/1

    # Update post
    curl -X PUT http://localhost:8080/api/v1/posts/1 \
  -H "Content-Type: application/json" \
  -d '{
        "title": "Updated Post Title",
        "content": "Updated content here"
      }'

    # Delete post
    curl -X DELETE http://localhost:8080/api/v1/posts/1
    ```
  </Tab>
</Tabs>

## What You've Built

Congratulations! You've successfully built a complete web application with:

<Cards>
  <Card
    title="ðŸ”§ Clean Architecture"
    description="Proper separation of concerns with models, services, and handlers"
  />
  <Card
    title="ðŸ—„ï¸ Database Integration"
    description="PostgreSQL integration with connection pooling and migrations"
  />
  <Card
    title="ðŸ›¡ï¸ Middleware Stack"
    description="Logging, recovery, CORS, and custom request ID middleware"
  />
  <Card
    title="ðŸ“¡ RESTful API"
    description="Complete CRUD operations for blog posts with proper HTTP status codes"
  />
</Cards>

## Next Steps

Now that you have a working Forge application, you can:

<Cards>
  <Card
    title="Add Authentication"
    description="Integrate user authentication and authorization"
    href="/docs/go/concepts/security"
  />
  <Card
    title="Add Validation"
    description="Implement request validation and error handling"
    href="/docs/go/guides/validation"
  />
  <Card
    title="Add Testing"
    description="Write unit and integration tests for your application"
    href="/docs/go/guides/testing"
  />
  <Card
    title="Deploy to Production"
    description="Learn how to deploy your Forge app to production"
    href="/docs/go/guides/deployment"
  />
</Cards>

<Callout type="tip">
**Pro Tip**: This tutorial covers the basics. In a production application, you'd want to add proper input validation, authentication, rate limiting, monitoring, and comprehensive testing.
</Callout>