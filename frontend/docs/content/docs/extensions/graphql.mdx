---
title: GraphQL Extension
description: Full-featured GraphQL server with schema-first development, real-time subscriptions, and advanced tooling
---

import { Card, Cards } from 'fumadocs-ui/components/card'
import { Callout } from 'fumadocs-ui/components/callout'
import { Tab, Tabs } from 'fumadocs-ui/components/tabs'

The GraphQL Extension provides a complete GraphQL server implementation with schema-first development, real-time subscriptions, federation support, and comprehensive tooling for building modern APIs.

## Key Features

<Cards>
  <Card
    title="📋 Schema-First"
    description="Define your API with GraphQL SDL and generate resolvers"
  />
  <Card
    title="🔄 Real-time Subscriptions"
    description="WebSocket-based subscriptions with filtering and authentication"
  />
  <Card
    title="🏗️ Federation"
    description="Apollo Federation support for microservices architecture"
  />
  <Card
    title="🛡️ Security"
    description="Query complexity analysis, depth limiting, and rate limiting"
  />
  <Card
    title="📊 Introspection"
    description="Schema introspection with GraphQL Playground integration"
  />
  <Card
    title="🔍 Tracing"
    description="Distributed tracing and performance monitoring"
  />
</Cards>

## Installation

```bash
go get github.com/xraph/forge/extensions/graphql
```

## Basic Usage

<Tabs items={['Schema Definition', 'Resolvers', 'Subscriptions', 'Federation']}>
  <Tab value="Schema Definition">
    ```go
    package main
    
    import (
        "context"
        "github.com/xraph/forge/v2"
        "github.com/xraph/forge/v2/extensions/graphql"
        "github.com/xraph/forge/v2/extensions/database"
    )
    
    // Define your GraphQL schema
    const schema = `
        type User {
            id: ID!
            email: String!
            name: String!
            posts: [Post!]!
            createdAt: String!
            updatedAt: String!
        }
        
        type Post {
            id: ID!
            title: String!
            content: String!
            author: User!
            published: Boolean!
            tags: [String!]!
            createdAt: String!
            updatedAt: String!
        }
        
        input CreateUserInput {
            email: String!
            name: String!
        }
        
        input CreatePostInput {
            title: String!
            content: String!
            authorId: ID!
            tags: [String!]
        }
        
        input UpdatePostInput {
            title: String
            content: String
            published: Boolean
            tags: [String!]
        }
        
        type Query {
            # User queries
            user(id: ID!): User
            users(limit: Int = 10, offset: Int = 0): [User!]!
            
            # Post queries
            post(id: ID!): Post
            posts(limit: Int = 10, offset: Int = 0, published: Boolean): [Post!]!
            postsByAuthor(authorId: ID!, limit: Int = 10): [Post!]!
            
            # Search
            searchPosts(query: String!, limit: Int = 10): [Post!]!
        }
        
        type Mutation {
            # User mutations
            createUser(input: CreateUserInput!): User!
            updateUser(id: ID!, input: UpdateUserInput!): User!
            deleteUser(id: ID!): Boolean!
            
            # Post mutations
            createPost(input: CreatePostInput!): Post!
            updatePost(id: ID!, input: UpdatePostInput!): Post!
            deletePost(id: ID!): Boolean!
            publishPost(id: ID!): Post!
        }
        
        type Subscription {
            # Real-time updates
            userCreated: User!
            postCreated: Post!
            postUpdated(authorId: ID): Post!
            postPublished: Post!
        }
    `
    
    func main() {
        app := forge.NewApp(forge.AppConfig{
            Name: "graphql-api",
        })
        
        // Register database extension
        app.RegisterExtension(database.NewExtension(
            database.WithPostgreSQL("postgres://localhost/mydb"),
        ))
        
        // Register GraphQL extension
        app.RegisterExtension(graphql.NewExtension(
            graphql.WithSchema(schema),
            graphql.WithPlayground(true),
            graphql.WithIntrospection(true),
            graphql.WithSubscriptions(true),
            graphql.WithComplexityLimit(1000),
            graphql.WithDepthLimit(15),
        ))
        
        // Register resolvers
        gql := forge.GetService[*graphql.Server](app.Container())
        
        // Register query resolvers
        gql.Query("user", resolveUser)
        gql.Query("users", resolveUsers)
        gql.Query("post", resolvePost)
        gql.Query("posts", resolvePosts)
        gql.Query("postsByAuthor", resolvePostsByAuthor)
        gql.Query("searchPosts", resolveSearchPosts)
        
        // Register mutation resolvers
        gql.Mutation("createUser", resolveCreateUser)
        gql.Mutation("updateUser", resolveUpdateUser)
        gql.Mutation("deleteUser", resolveDeleteUser)
        gql.Mutation("createPost", resolveCreatePost)
        gql.Mutation("updatePost", resolveUpdatePost)
        gql.Mutation("deletePost", resolveDeletePost)
        gql.Mutation("publishPost", resolvePublishPost)
        
        // Register subscription resolvers
        gql.Subscription("userCreated", subscribeUserCreated)
        gql.Subscription("postCreated", subscribePostCreated)
        gql.Subscription("postUpdated", subscribePostUpdated)
        gql.Subscription("postPublished", subscribePostPublished)
        
        // Register field resolvers
        gql.FieldResolver("User", "posts", resolveUserPosts)
        gql.FieldResolver("Post", "author", resolvePostAuthor)
        
        app.Run()
    }
    ```
  </Tab>
  <Tab value="Resolvers">
    ```go
    // Define your data models
    type User struct {
        ID        string    `json:"id" db:"id"`
        Email     string    `json:"email" db:"email"`
        Name      string    `json:"name" db:"name"`
        CreatedAt time.Time `json:"createdAt" db:"created_at"`
        UpdatedAt time.Time `json:"updatedAt" db:"updated_at"`
    }
    
    type Post struct {
        ID        string    `json:"id" db:"id"`
        Title     string    `json:"title" db:"title"`
        Content   string    `json:"content" db:"content"`
        AuthorID  string    `json:"authorId" db:"author_id"`
        Published bool      `json:"published" db:"published"`
        Tags      []string  `json:"tags" db:"tags"`
        CreatedAt time.Time `json:"createdAt" db:"created_at"`
        UpdatedAt time.Time `json:"updatedAt" db:"updated_at"`
    }
    
    // Query resolvers
    func resolveUser(ctx context.Context, args struct{ ID string }) (*User, error) {
        db := forge.GetService[database.Manager](forge.GetContainer(ctx))
        
        var user User
        err := db.QueryRow(ctx, 
            "SELECT id, email, name, created_at, updated_at FROM users WHERE id = $1",
            args.ID,
        ).Scan(&user.ID, &user.Email, &user.Name, &user.CreatedAt, &user.UpdatedAt)
        
        if err != nil {
            if err == sql.ErrNoRows {
                return nil, nil // GraphQL null
            }
            return nil, err
        }
        
        return &user, nil
    }
    
    func resolveUsers(ctx context.Context, args struct {
        Limit  *int32
        Offset *int32
    }) ([]*User, error) {
        db := forge.GetService[database.Manager](forge.GetContainer(ctx))
        
        limit := int32(10)
        if args.Limit != nil {
            limit = *args.Limit
        }
        
        offset := int32(0)
        if args.Offset != nil {
            offset = *args.Offset
        }
        
        rows, err := db.Query(ctx,
            "SELECT id, email, name, created_at, updated_at FROM users ORDER BY created_at DESC LIMIT $1 OFFSET $2",
            limit, offset,
        )
        if err != nil {
            return nil, err
        }
        defer rows.Close()
        
        var users []*User
        for rows.Next() {
            var user User
            err := rows.Scan(&user.ID, &user.Email, &user.Name, &user.CreatedAt, &user.UpdatedAt)
            if err != nil {
                return nil, err
            }
            users = append(users, &user)
        }
        
        return users, nil
    }
    
    func resolvePost(ctx context.Context, args struct{ ID string }) (*Post, error) {
        db := forge.GetService[database.Manager](forge.GetContainer(ctx))
        
        var post Post
        err := db.QueryRow(ctx,
            "SELECT id, title, content, author_id, published, tags, created_at, updated_at FROM posts WHERE id = $1",
            args.ID,
        ).Scan(&post.ID, &post.Title, &post.Content, &post.AuthorID, &post.Published, 
                pq.Array(&post.Tags), &post.CreatedAt, &post.UpdatedAt)
        
        if err != nil {
            if err == sql.ErrNoRows {
                return nil, nil
            }
            return nil, err
        }
        
        return &post, nil
    }
    
    // Mutation resolvers
    func resolveCreateUser(ctx context.Context, args struct {
        Input struct {
            Email string
            Name  string
        }
    }) (*User, error) {
        db := forge.GetService[database.Manager](forge.GetContainer(ctx))
        
        user := &User{
            ID:        uuid.New().String(),
            Email:     args.Input.Email,
            Name:      args.Input.Name,
            CreatedAt: time.Now(),
            UpdatedAt: time.Now(),
        }
        
        _, err := db.Exec(ctx,
            "INSERT INTO users (id, email, name, created_at, updated_at) VALUES ($1, $2, $3, $4, $5)",
            user.ID, user.Email, user.Name, user.CreatedAt, user.UpdatedAt,
        )
        if err != nil {
            return nil, err
        }
        
        // Publish subscription event
        gql := forge.GetService[*graphql.Server](forge.GetContainer(ctx))
        gql.PublishSubscription("userCreated", user)
        
        return user, nil
    }
    
    func resolveCreatePost(ctx context.Context, args struct {
        Input struct {
            Title    string
            Content  string
            AuthorID string
            Tags     *[]string
        }
    }) (*Post, error) {
        db := forge.GetService[database.Manager](forge.GetContainer(ctx))
        
        tags := []string{}
        if args.Input.Tags != nil {
            tags = *args.Input.Tags
        }
        
        post := &Post{
            ID:        uuid.New().String(),
            Title:     args.Input.Title,
            Content:   args.Input.Content,
            AuthorID:  args.Input.AuthorID,
            Published: false,
            Tags:      tags,
            CreatedAt: time.Now(),
            UpdatedAt: time.Now(),
        }
        
        _, err := db.Exec(ctx,
            "INSERT INTO posts (id, title, content, author_id, published, tags, created_at, updated_at) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)",
            post.ID, post.Title, post.Content, post.AuthorID, post.Published, 
            pq.Array(post.Tags), post.CreatedAt, post.UpdatedAt,
        )
        if err != nil {
            return nil, err
        }
        
        // Publish subscription event
        gql := forge.GetService[*graphql.Server](forge.GetContainer(ctx))
        gql.PublishSubscription("postCreated", post)
        
        return post, nil
    }
    
    // Field resolvers
    func resolveUserPosts(ctx context.Context, user *User) ([]*Post, error) {
        db := forge.GetService[database.Manager](forge.GetContainer(ctx))
        
        rows, err := db.Query(ctx,
            "SELECT id, title, content, author_id, published, tags, created_at, updated_at FROM posts WHERE author_id = $1 ORDER BY created_at DESC",
            user.ID,
        )
        if err != nil {
            return nil, err
        }
        defer rows.Close()
        
        var posts []*Post
        for rows.Next() {
            var post Post
            err := rows.Scan(&post.ID, &post.Title, &post.Content, &post.AuthorID, 
                           &post.Published, pq.Array(&post.Tags), &post.CreatedAt, &post.UpdatedAt)
            if err != nil {
                return nil, err
            }
            posts = append(posts, &post)
        }
        
        return posts, nil
    }
    
    func resolvePostAuthor(ctx context.Context, post *Post) (*User, error) {
        // Use DataLoader to prevent N+1 queries
        loader := forge.GetService[*UserLoader](forge.GetContainer(ctx))
        return loader.Load(ctx, post.AuthorID)
    }
    ```
  </Tab>
  <Tab value="Subscriptions">
    ```go
    // Subscription resolvers
    func subscribeUserCreated(ctx context.Context) (<-chan *User, error) {
        gql := forge.GetService[*graphql.Server](forge.GetContainer(ctx))
        
        // Create subscription channel
        ch := make(chan *User, 10)
        
        // Subscribe to events
        subscription := gql.Subscribe("userCreated", func(data interface{}) {
            if user, ok := data.(*User); ok {
                select {
                case ch <- user:
                case <-ctx.Done():
                    return
                }
            }
        })
        
        // Clean up subscription when context is cancelled
        go func() {
            <-ctx.Done()
            subscription.Unsubscribe()
            close(ch)
        }()
        
        return ch, nil
    }
    
    func subscribePostCreated(ctx context.Context) (<-chan *Post, error) {
        gql := forge.GetService[*graphql.Server](forge.GetContainer(ctx))
        
        ch := make(chan *Post, 10)
        
        subscription := gql.Subscribe("postCreated", func(data interface{}) {
            if post, ok := data.(*Post); ok {
                select {
                case ch <- post:
                case <-ctx.Done():
                    return
                }
            }
        })
        
        go func() {
            <-ctx.Done()
            subscription.Unsubscribe()
            close(ch)
        }()
        
        return ch, nil
    }
    
    func subscribePostUpdated(ctx context.Context, args struct {
        AuthorID *string
    }) (<-chan *Post, error) {
        gql := forge.GetService[*graphql.Server](forge.GetContainer(ctx))
        
        ch := make(chan *Post, 10)
        
        subscription := gql.Subscribe("postUpdated", func(data interface{}) {
            if post, ok := data.(*Post); ok {
                // Filter by author if specified
                if args.AuthorID != nil && post.AuthorID != *args.AuthorID {
                    return
                }
                
                select {
                case ch <- post:
                case <-ctx.Done():
                    return
                }
            }
        })
        
        go func() {
            <-ctx.Done()
            subscription.Unsubscribe()
            close(ch)
        }()
        
        return ch, nil
    }
    
    // Publishing subscription events
    func resolvePublishPost(ctx context.Context, args struct{ ID string }) (*Post, error) {
        db := forge.GetService[database.Manager](forge.GetContainer(ctx))
        gql := forge.GetService[*graphql.Server](forge.GetContainer(ctx))
        
        // Update post
        _, err := db.Exec(ctx,
            "UPDATE posts SET published = true, updated_at = $1 WHERE id = $2",
            time.Now(), args.ID,
        )
        if err != nil {
            return nil, err
        }
        
        // Get updated post
        post, err := resolvePost(ctx, struct{ ID string }{ID: args.ID})
        if err != nil {
            return nil, err
        }
        
        if post == nil {
            return nil, fmt.Errorf("post not found")
        }
        
        // Publish subscription events
        gql.PublishSubscription("postUpdated", post)
        gql.PublishSubscription("postPublished", post)
        
        return post, nil
    }
    ```
  </Tab>
  <Tab value="Federation">
    ```go
    // Apollo Federation support
    func setupFederation() {
        app := forge.NewApp(forge.AppConfig{
            Name: "user-service",
        })
        
        // Federation schema with entity definitions
        const federatedSchema = `
            extend type Query {
                user(id: ID!): User
                users: [User!]!
            }
            
            type User @key(fields: "id") {
                id: ID!
                email: String!
                name: String!
                # External fields from other services
                posts: [Post!]! @external
                profile: UserProfile @external
            }
            
            # External types from other services
            type Post @key(fields: "id") @external {
                id: ID!
                authorId: ID!
            }
            
            type UserProfile @key(fields: "userId") @external {
                userId: ID!
            }
        `
        
        app.RegisterExtension(graphql.NewExtension(
            graphql.WithSchema(federatedSchema),
            graphql.WithFederation(true),
            graphql.WithServiceName("user-service"),
            graphql.WithServiceURL("http://localhost:4001/graphql"),
        ))
        
        gql := forge.GetService[*graphql.Server](app.Container())
        
        // Entity resolver for User
        gql.EntityResolver("User", func(ctx context.Context, representations []map[string]interface{}) ([]interface{}, error) {
            var users []interface{}
            
            for _, rep := range representations {
                if id, ok := rep["id"].(string); ok {
                    user, err := resolveUser(ctx, struct{ ID string }{ID: id})
                    if err != nil {
                        return nil, err
                    }
                    users = append(users, user)
                }
            }
            
            return users, nil
        })
        
        // Reference resolver for external Post type
        gql.ReferenceResolver("Post", func(ctx context.Context, representation map[string]interface{}) (interface{}, error) {
            if id, ok := representation["id"].(string); ok {
                return &Post{ID: id}, nil
            }
            return nil, fmt.Errorf("invalid Post representation")
        })
        
        app.Run()
    }
    
    // Gateway configuration
    func setupGateway() {
        app := forge.NewApp(forge.AppConfig{
            Name: "api-gateway",
        })
        
        app.RegisterExtension(graphql.NewExtension(
            graphql.WithFederationGateway(true),
            graphql.WithServices([]graphql.FederatedService{
                {
                    Name: "user-service",
                    URL:  "http://localhost:4001/graphql",
                },
                {
                    Name: "post-service", 
                    URL:  "http://localhost:4002/graphql",
                },
                {
                    Name: "profile-service",
                    URL:  "http://localhost:4003/graphql",
                },
            }),
            graphql.WithPlayground(true),
        ))
        
        app.Run()
    }
    ```
  </Tab>
</Tabs>

## Configuration

### YAML Configuration

```yaml
graphql:
  # Server configuration
  path: /graphql
  playground:
    enabled: true
    path: /playground
  introspection: true
  
  # Schema configuration
  schema:
    file: schema.graphql # Load schema from file
    # Or inline schema
    sdl: |
      type Query {
        hello: String
      }
  
  # Security configuration
  security:
    complexity_limit: 1000
    depth_limit: 15
    query_timeout: 30s
    disable_introspection_in_production: true
    
    # Rate limiting
    rate_limit:
      enabled: true
      requests_per_minute: 100
      burst: 10
    
    # Query whitelist (production)
    query_whitelist:
      enabled: false
      queries: []
  
  # Subscriptions
  subscriptions:
    enabled: true
    path: /subscriptions
    websocket:
      keep_alive_interval: 30s
      connection_init_timeout: 10s
      read_limit: 4096
      write_limit: 4096
    
    # Authentication for subscriptions
    auth:
      required: true
      token_header: Authorization
  
  # Federation
  federation:
    enabled: false
    gateway: false
    service_name: my-service
    service_url: http://localhost:4000/graphql
    
    # Gateway configuration
    services:
      - name: user-service
        url: http://localhost:4001/graphql
      - name: post-service
        url: http://localhost:4002/graphql
  
  # Performance
  performance:
    # DataLoader configuration
    dataloader:
      enabled: true
      batch_timeout: 1ms
      max_batch_size: 100
    
    # Query caching
    query_cache:
      enabled: true
      max_size: 1000
      ttl: 5m
    
    # Response caching
    response_cache:
      enabled: true
      max_size: 10000
      ttl: 1m
  
  # Tracing and monitoring
  tracing:
    enabled: true
    include_variables: false
    include_raw_query: false
    
  # Extensions
  extensions:
    - name: apollo-tracing
      enabled: true
    - name: query-complexity
      enabled: true
    - name: query-depth
      enabled: true
```

## GraphQL Server Interface

The GraphQL extension provides a comprehensive server interface:

```go
type Server interface {
    // Schema management
    SetSchema(schema string) error
    GetSchema() *ast.Schema
    
    // Resolver registration
    Query(field string, resolver interface{}) error
    Mutation(field string, resolver interface{}) error
    Subscription(field string, resolver interface{}) error
    FieldResolver(typeName, fieldName string, resolver interface{}) error
    
    // Federation
    EntityResolver(typeName string, resolver EntityResolverFunc) error
    ReferenceResolver(typeName string, resolver ReferenceResolverFunc) error
    
    // Subscriptions
    Subscribe(event string, handler SubscriptionHandler) Subscription
    PublishSubscription(event string, data interface{}) error
    
    // Middleware
    Use(middleware ...MiddlewareFunc)
    
    // Execution
    Execute(ctx context.Context, query string, variables map[string]interface{}) *graphql.Result
    
    // Health and metrics
    Health(ctx context.Context) error
    Metrics() ServerMetrics
}

type MiddlewareFunc func(next ResolverFunc) ResolverFunc
type ResolverFunc func(ctx context.Context, args interface{}) (interface{}, error)

type EntityResolverFunc func(ctx context.Context, representations []map[string]interface{}) ([]interface{}, error)
type ReferenceResolverFunc func(ctx context.Context, representation map[string]interface{}) (interface{}, error)

type SubscriptionHandler func(data interface{})

type Subscription interface {
    Unsubscribe()
}
```

## Advanced Features

### DataLoader for N+1 Prevention

```go
type UserLoader struct {
    db database.Manager
}

func NewUserLoader(db database.Manager) *UserLoader {
    return &UserLoader{db: db}
}

func (l *UserLoader) Load(ctx context.Context, userID string) (*User, error) {
    // Get or create batch loader for this request
    loader := dataloader.GetLoader(ctx, "users", func(keys []string) ([]interface{}, []error) {
        return l.batchLoad(ctx, keys)
    })
    
    result, err := loader.Load(userID)
    if err != nil {
        return nil, err
    }
    
    if user, ok := result.(*User); ok {
        return user, nil
    }
    
    return nil, fmt.Errorf("invalid user type")
}

func (l *UserLoader) batchLoad(ctx context.Context, userIDs []string) ([]interface{}, []error) {
    // Build query with IN clause
    query := "SELECT id, email, name, created_at, updated_at FROM users WHERE id = ANY($1)"
    
    rows, err := l.db.Query(ctx, query, pq.Array(userIDs))
    if err != nil {
        errors := make([]error, len(userIDs))
        for i := range errors {
            errors[i] = err
        }
        return nil, errors
    }
    defer rows.Close()
    
    // Create map for O(1) lookup
    userMap := make(map[string]*User)
    for rows.Next() {
        var user User
        err := rows.Scan(&user.ID, &user.Email, &user.Name, &user.CreatedAt, &user.UpdatedAt)
        if err != nil {
            continue
        }
        userMap[user.ID] = &user
    }
    
    // Return results in the same order as requested
    results := make([]interface{}, len(userIDs))
    errors := make([]error, len(userIDs))
    
    for i, userID := range userIDs {
        if user, exists := userMap[userID]; exists {
            results[i] = user
        } else {
            errors[i] = fmt.Errorf("user not found: %s", userID)
        }
    }
    
    return results, errors
}
```

### Custom Directives

```go
// Define custom directive
const schemaWithDirectives = `
    directive @auth(requires: Role = USER) on FIELD_DEFINITION
    directive @rateLimit(max: Int!, window: String!) on FIELD_DEFINITION
    directive @deprecated(reason: String) on FIELD_DEFINITION
    
    enum Role {
        USER
        ADMIN
        MODERATOR
    }
    
    type Query {
        publicData: String
        userData: String @auth(requires: USER)
        adminData: String @auth(requires: ADMIN)
        expensiveQuery: String @rateLimit(max: 10, window: "1m")
        oldField: String @deprecated(reason: "Use newField instead")
    }
`

// Implement directive middleware
func authDirective(next graphql.Resolver) graphql.Resolver {
    return func(ctx context.Context, obj interface{}, args map[string]interface{}) (interface{}, error) {
        // Get directive arguments
        directive := graphql.GetDirective(ctx, "auth")
        if directive == nil {
            return next(ctx, obj, args)
        }
        
        requiredRole := directive.Args["requires"].(string)
        
        // Get user from context
        user := auth.GetUser(ctx)
        if user == nil {
            return nil, fmt.Errorf("authentication required")
        }
        
        // Check role
        if !user.HasRole(requiredRole) {
            return nil, fmt.Errorf("insufficient permissions")
        }
        
        return next(ctx, obj, args)
    }
}

func rateLimitDirective(next graphql.Resolver) graphql.Resolver {
    return func(ctx context.Context, obj interface{}, args map[string]interface{}) (interface{}, error) {
        directive := graphql.GetDirective(ctx, "rateLimit")
        if directive == nil {
            return next(ctx, obj, args)
        }
        
        max := directive.Args["max"].(int)
        window := directive.Args["window"].(string)
        
        // Implement rate limiting logic
        limiter := ratelimit.GetLimiter(ctx)
        if !limiter.Allow(ctx, max, window) {
            return nil, fmt.Errorf("rate limit exceeded")
        }
        
        return next(ctx, obj, args)
    }
}

// Register directives
func setupDirectives(gql *graphql.Server) {
    gql.Use(authDirective)
    gql.Use(rateLimitDirective)
}
```

### Query Complexity Analysis

```go
type ComplexityAnalyzer struct {
    maxComplexity int
    scalarCost    int
    objectCost    int
    listCost      int
}

func NewComplexityAnalyzer(maxComplexity int) *ComplexityAnalyzer {
    return &ComplexityAnalyzer{
        maxComplexity: maxComplexity,
        scalarCost:    1,
        objectCost:    2,
        listCost:      10,
    }
}

func (a *ComplexityAnalyzer) AnalyzeQuery(ctx context.Context, query *ast.Document) error {
    complexity := a.calculateComplexity(query)
    
    if complexity > a.maxComplexity {
        return fmt.Errorf("query complexity %d exceeds maximum %d", complexity, a.maxComplexity)
    }
    
    // Add complexity to context for monitoring
    ctx = context.WithValue(ctx, "query_complexity", complexity)
    
    return nil
}

func (a *ComplexityAnalyzer) calculateComplexity(doc *ast.Document) int {
    complexity := 0
    
    for _, def := range doc.Definitions {
        if opDef, ok := def.(*ast.OperationDefinition); ok {
            complexity += a.calculateSelectionComplexity(opDef.SelectionSet)
        }
    }
    
    return complexity
}

func (a *ComplexityAnalyzer) calculateSelectionComplexity(selectionSet ast.SelectionSet) int {
    complexity := 0
    
    for _, selection := range selectionSet {
        switch sel := selection.(type) {
        case *ast.Field:
            complexity += a.scalarCost
            
            // Add cost for nested selections
            if sel.SelectionSet != nil {
                complexity += a.objectCost + a.calculateSelectionComplexity(sel.SelectionSet)
            }
            
            // Add cost for list fields with arguments
            if a.isListField(sel) {
                multiplier := a.getListMultiplier(sel)
                complexity += a.listCost * multiplier
            }
            
        case *ast.InlineFragment:
            complexity += a.calculateSelectionComplexity(sel.SelectionSet)
            
        case *ast.FragmentSpread:
            // Handle fragment spreads
            complexity += a.objectCost
        }
    }
    
    return complexity
}

func (a *ComplexityAnalyzer) isListField(field *ast.Field) bool {
    // Check if field returns a list type
    // This would require schema introspection
    return false
}

func (a *ComplexityAnalyzer) getListMultiplier(field *ast.Field) int {
    // Extract limit/first arguments to calculate multiplier
    for _, arg := range field.Arguments {
        if arg.Name == "limit" || arg.Name == "first" {
            if value, ok := arg.Value.(*ast.IntValue); ok {
                if limit, err := strconv.Atoi(value.Value); err == nil {
                    return limit
                }
            }
        }
    }
    
    return 100 // Default multiplier for unbounded lists
}
```

## Testing

The GraphQL extension provides comprehensive testing utilities:

```go
func TestGraphQLQueries(t *testing.T) {
    app := forge.NewTestApp(t, forge.TestConfig{
        Extensions: []forge.Extension{
            database.NewExtension(database.WithInMemory()),
            graphql.NewExtension(
                graphql.WithSchema(schema),
                graphql.WithIntrospection(true),
            ),
        },
    })
    
    gql := forge.GetService[*graphql.Server](app.Container())
    
    // Register test resolvers
    gql.Query("user", resolveUser)
    gql.Mutation("createUser", resolveCreateUser)
    
    ctx := context.Background()
    
    t.Run("create user mutation", func(t *testing.T) {
        query := `
            mutation CreateUser($input: CreateUserInput!) {
                createUser(input: $input) {
                    id
                    email
                    name
                    createdAt
                }
            }
        `
        
        variables := map[string]interface{}{
            "input": map[string]interface{}{
                "email": "test@example.com",
                "name":  "Test User",
            },
        }
        
        result := gql.Execute(ctx, query, variables)
        require.Empty(t, result.Errors)
        require.NotNil(t, result.Data)
        
        data := result.Data.(map[string]interface{})
        user := data["createUser"].(map[string]interface{})
        
        assert.Equal(t, "test@example.com", user["email"])
        assert.Equal(t, "Test User", user["name"])
        assert.NotEmpty(t, user["id"])
    })
    
    t.Run("user query", func(t *testing.T) {
        // First create a user
        createQuery := `
            mutation {
                createUser(input: {email: "query@example.com", name: "Query User"}) {
                    id
                }
            }
        `
        
        createResult := gql.Execute(ctx, createQuery, nil)
        require.Empty(t, createResult.Errors)
        
        createData := createResult.Data.(map[string]interface{})
        createdUser := createData["createUser"].(map[string]interface{})
        userID := createdUser["id"].(string)
        
        // Now query the user
        query := `
            query GetUser($id: ID!) {
                user(id: $id) {
                    id
                    email
                    name
                    posts {
                        id
                        title
                    }
                }
            }
        `
        
        variables := map[string]interface{}{
            "id": userID,
        }
        
        result := gql.Execute(ctx, query, variables)
        require.Empty(t, result.Errors)
        
        data := result.Data.(map[string]interface{})
        user := data["user"].(map[string]interface{})
        
        assert.Equal(t, userID, user["id"])
        assert.Equal(t, "query@example.com", user["email"])
        assert.Equal(t, "Query User", user["name"])
    })
}

func TestGraphQLSubscriptions(t *testing.T) {
    app := forge.NewTestApp(t, forge.TestConfig{
        Extensions: []forge.Extension{
            graphql.NewExtension(
                graphql.WithSchema(schema),
                graphql.WithSubscriptions(true),
            ),
        },
    })
    
    gql := forge.GetService[*graphql.Server](app.Container())
    gql.Subscription("userCreated", subscribeUserCreated)
    
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    t.Run("user created subscription", func(t *testing.T) {
        // Subscribe to user created events
        query := `
            subscription {
                userCreated {
                    id
                    email
                    name
                }
            }
        `
        
        // This would require WebSocket testing setup
        // For unit tests, you can test the subscription resolver directly
        ch, err := subscribeUserCreated(ctx)
        require.NoError(t, err)
        
        // Publish an event
        user := &User{
            ID:    "test-id",
            Email: "test@example.com",
            Name:  "Test User",
        }
        
        gql.PublishSubscription("userCreated", user)
        
        // Verify event was received
        select {
        case receivedUser := <-ch:
            assert.Equal(t, user.ID, receivedUser.ID)
            assert.Equal(t, user.Email, receivedUser.Email)
            assert.Equal(t, user.Name, receivedUser.Name)
        case <-time.After(time.Second):
            t.Fatal("subscription event not received")
        }
    })
}
```

## Best Practices

<Callout type="info">
Follow these best practices when building GraphQL APIs.
</Callout>

### Schema Design

- **Nullable vs Non-null**: Use non-null types judiciously
- **Pagination**: Implement cursor-based pagination for lists
- **Naming**: Use consistent naming conventions (camelCase)
- **Versioning**: Use schema evolution instead of versioning
- **Documentation**: Add descriptions to all types and fields

### Performance

- **DataLoader**: Always use DataLoader to prevent N+1 queries
- **Query Complexity**: Implement complexity analysis
- **Depth Limiting**: Limit query depth to prevent abuse
- **Caching**: Cache expensive operations and queries
- **Batching**: Batch database operations when possible

### Security

- **Authentication**: Secure subscription connections
- **Authorization**: Implement field-level authorization
- **Rate Limiting**: Protect against query abuse
- **Query Whitelisting**: Use in production environments
- **Input Validation**: Validate all input arguments

## Next Steps

<Cards>
  <Card
    title="🗄️ Database Extension"
    description="Store and query your GraphQL data"
    href="/docs/extensions/database"
  />
  <Card
    title="🔐 Auth Extension"
    description="Secure your GraphQL endpoints"
    href="/docs/extensions/auth"
  />
  <Card
    title="📡 Real-time Guide"
    description="Build real-time applications"
    href="/docs/guides/realtime"
  />
  <Card
    title="🏗️ Federation Guide"
    description="Microservices with GraphQL Federation"
    href="/docs/guides/federation"
  />
</Cards>