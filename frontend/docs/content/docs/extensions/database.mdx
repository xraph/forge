---
title: Database Extension
description: Comprehensive database support with SQL and NoSQL databases, connection pooling, and migrations
---

import { Card, Cards } from 'fumadocs-ui/components/card'
import { Callout } from 'fumadocs-ui/components/callout'
import { Tab, Tabs } from 'fumadocs-ui/components/tabs'

The Database Extension provides comprehensive database support for both SQL and NoSQL databases with connection pooling, migrations, and transaction management.

## Supported Databases

<Cards>
  <Card
    title="ðŸ˜ PostgreSQL"
    description="Full-featured PostgreSQL support with advanced features"
  />
  <Card
    title="ðŸ¬ MySQL"
    description="MySQL and MariaDB support with connection pooling"
  />
  <Card
    title="ðŸª¶ SQLite"
    description="Embedded SQLite database for development and testing"
  />
  <Card
    title="ðŸƒ MongoDB"
    description="NoSQL MongoDB support with aggregation pipelines"
  />
  <Card
    title="âš¡ BadgerDB"
    description="High-performance embedded key-value store"
  />
</Cards>

## Installation

```bash
go get github.com/xraph/forge/extensions/database
```

## Basic Usage

<Tabs items={['PostgreSQL', 'MySQL', 'SQLite', 'MongoDB']}>
  <Tab value="PostgreSQL">
    ```go
    package main
    
    import (
        "github.com/xraph/forge/v2"
        "github.com/xraph/forge/v2/extensions/database"
    )
    
    func main() {
        app := forge.NewApp(forge.AppConfig{
            Name: "my-app",
        })
        
        // Register database extension
        app.RegisterExtension(
            database.NewExtension(
                database.WithPostgreSQL("postgres://user:pass@localhost/mydb?sslmode=disable"),
                database.WithConnectionPool(10, 100),
                database.WithMigrations("./migrations"),
            ),
        )
        
        // Register service that uses database
        app.RegisterService(func(c forge.Container) (*UserService, error) {
            db := forge.GetService[database.Manager](c)
            return &UserService{db: db}, nil
        })
        
        app.Run()
    }
    ```
  </Tab>
  <Tab value="MySQL">
    ```go
    app.RegisterExtension(
        database.NewExtension(
            database.WithMySQL("user:pass@tcp(localhost:3306)/mydb"),
            database.WithConnectionPool(10, 100),
            database.WithTimeout(30*time.Second),
        ),
    )
    ```
  </Tab>
  <Tab value="SQLite">
    ```go
    app.RegisterExtension(
        database.NewExtension(
            database.WithSQLite("./data/app.db"),
            database.WithMigrations("./migrations"),
        ),
    )
    ```
  </Tab>
  <Tab value="MongoDB">
    ```go
    app.RegisterExtension(
        database.NewExtension(
            database.WithMongoDB("mongodb://localhost:27017/mydb"),
            database.WithConnectionPool(10, 100),
        ),
    )
    ```
  </Tab>
</Tabs>

## Configuration

### YAML Configuration

```yaml
database:
  default:
    driver: postgres
    dsn: postgres://user:pass@localhost/mydb?sslmode=disable
    pool:
      min_connections: 5
      max_connections: 50
      max_idle_time: 30m
      max_lifetime: 1h
    migrations:
      enabled: true
      path: ./migrations
      table: schema_migrations
  
  # Multiple database connections
  analytics:
    driver: postgres
    dsn: postgres://user:pass@analytics-db/analytics
    pool:
      min_connections: 2
      max_connections: 20
  
  cache:
    driver: redis
    dsn: redis://localhost:6379/0
```

### Environment Variables

```bash
# Default database
DATABASE_DEFAULT_DRIVER=postgres
DATABASE_DEFAULT_DSN=postgres://user:pass@localhost/mydb
DATABASE_DEFAULT_POOL_MIN_CONNECTIONS=5
DATABASE_DEFAULT_POOL_MAX_CONNECTIONS=50

# Named connections
DATABASE_ANALYTICS_DRIVER=postgres
DATABASE_ANALYTICS_DSN=postgres://user:pass@analytics-db/analytics
```

## Database Manager

The Database Manager provides a unified interface for all database operations:

```go
type Manager interface {
    // Connection management
    Connection(name string) Connection
    DefaultConnection() Connection
    
    // Transaction management
    Transaction(ctx context.Context, fn func(tx Transaction) error) error
    TransactionWithConnection(ctx context.Context, name string, fn func(tx Transaction) error) error
    
    // Migration management
    Migrate(ctx context.Context) error
    MigrateConnection(ctx context.Context, name string) error
    
    // Health and metrics
    Health(ctx context.Context) error
    Stats() map[string]ConnectionStats
}
```

### Using the Database Manager

```go
type UserService struct {
    db database.Manager
}

func (s *UserService) GetUser(ctx context.Context, id string) (*User, error) {
    conn := s.db.DefaultConnection()
    
    var user User
    err := conn.QueryRow(ctx, "SELECT id, name, email FROM users WHERE id = $1", id).
        Scan(&user.ID, &user.Name, &user.Email)
    
    if err != nil {
        return nil, fmt.Errorf("failed to get user: %w", err)
    }
    
    return &user, nil
}

func (s *UserService) CreateUser(ctx context.Context, user *User) error {
    return s.db.Transaction(ctx, func(tx database.Transaction) error {
        // Insert user
        err := tx.Exec(ctx, 
            "INSERT INTO users (id, name, email) VALUES ($1, $2, $3)",
            user.ID, user.Name, user.Email,
        )
        if err != nil {
            return fmt.Errorf("failed to insert user: %w", err)
        }
        
        // Insert user profile
        err = tx.Exec(ctx,
            "INSERT INTO user_profiles (user_id, created_at) VALUES ($1, $2)",
            user.ID, time.Now(),
        )
        if err != nil {
            return fmt.Errorf("failed to insert user profile: %w", err)
        }
        
        return nil
    })
}
```

## SQL Database Features

### Query Builder

The extension includes a powerful query builder for complex queries:

```go
type UserRepository struct {
    db database.Manager
}

func (r *UserRepository) FindUsers(ctx context.Context, filter UserFilter) ([]*User, error) {
    qb := database.NewQueryBuilder().
        Select("id", "name", "email", "created_at").
        From("users")
    
    if filter.Name != "" {
        qb = qb.Where("name ILIKE ?", "%"+filter.Name+"%")
    }
    
    if filter.Email != "" {
        qb = qb.Where("email = ?", filter.Email)
    }
    
    if !filter.CreatedAfter.IsZero() {
        qb = qb.Where("created_at > ?", filter.CreatedAfter)
    }
    
    qb = qb.OrderBy("created_at DESC").
        Limit(filter.Limit).
        Offset(filter.Offset)
    
    query, args := qb.Build()
    
    rows, err := r.db.DefaultConnection().Query(ctx, query, args...)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var users []*User
    for rows.Next() {
        var user User
        err := rows.Scan(&user.ID, &user.Name, &user.Email, &user.CreatedAt)
        if err != nil {
            return nil, err
        }
        users = append(users, &user)
    }
    
    return users, nil
}
```

### Migrations

Database migrations are handled automatically:

```sql
-- migrations/001_create_users.up.sql
CREATE TABLE users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE INDEX idx_users_email ON users(email);
```

```sql
-- migrations/001_create_users.down.sql
DROP TABLE IF EXISTS users;
```

```go
// Run migrations
func (app *App) runMigrations() error {
    db := forge.GetService[database.Manager](app.Container())
    return db.Migrate(context.Background())
}
```

### Connection Pooling

Advanced connection pool configuration:

```go
app.RegisterExtension(
    database.NewExtension(
        database.WithPostgreSQL(dsn),
        database.WithConnectionPool(
            database.PoolConfig{
                MinConnections:  5,
                MaxConnections:  50,
                MaxIdleTime:     30 * time.Minute,
                MaxLifetime:     1 * time.Hour,
                HealthCheckPeriod: 1 * time.Minute,
            },
        ),
    ),
)
```

## NoSQL Database Features

### MongoDB Operations

```go
type ProductService struct {
    db database.Manager
}

func (s *ProductService) GetProduct(ctx context.Context, id string) (*Product, error) {
    conn := s.db.Connection("mongodb")
    
    var product Product
    err := conn.FindOne(ctx, "products", bson.M{"_id": id}).Decode(&product)
    if err != nil {
        return nil, fmt.Errorf("failed to get product: %w", err)
    }
    
    return &product, nil
}

func (s *ProductService) SearchProducts(ctx context.Context, query string) ([]*Product, error) {
    conn := s.db.Connection("mongodb")
    
    // Text search with aggregation pipeline
    pipeline := []bson.M{
        {"$match": bson.M{"$text": bson.M{"$search": query}}},
        {"$sort": bson.M{"score": bson.M{"$meta": "textScore"}}},
        {"$limit": 20},
    }
    
    cursor, err := conn.Aggregate(ctx, "products", pipeline)
    if err != nil {
        return nil, err
    }
    defer cursor.Close(ctx)
    
    var products []*Product
    for cursor.Next(ctx) {
        var product Product
        if err := cursor.Decode(&product); err != nil {
            return nil, err
        }
        products = append(products, &product)
    }
    
    return products, nil
}
```

## Advanced Features

### Database Sharding

Support for database sharding across multiple connections:

```go
type ShardedUserService struct {
    db database.Manager
}

func (s *ShardedUserService) getShardName(userID string) string {
    // Simple hash-based sharding
    hash := fnv.New32a()
    hash.Write([]byte(userID))
    shard := hash.Sum32() % 4
    return fmt.Sprintf("shard_%d", shard)
}

func (s *ShardedUserService) GetUser(ctx context.Context, userID string) (*User, error) {
    shardName := s.getShardName(userID)
    conn := s.db.Connection(shardName)
    
    var user User
    err := conn.QueryRow(ctx, "SELECT * FROM users WHERE id = $1", userID).
        Scan(&user.ID, &user.Name, &user.Email)
    
    return &user, err
}
```

### Read Replicas

Configure read replicas for improved performance:

```yaml
database:
  primary:
    driver: postgres
    dsn: postgres://user:pass@primary-db/mydb
    role: primary
  
  replica1:
    driver: postgres
    dsn: postgres://user:pass@replica1-db/mydb
    role: replica
  
  replica2:
    driver: postgres
    dsn: postgres://user:pass@replica2-db/mydb
    role: replica
```

```go
func (s *UserService) GetUser(ctx context.Context, id string) (*User, error) {
    // Use read replica for queries
    conn := s.db.Connection("replica1")
    return s.queryUser(ctx, conn, id)
}

func (s *UserService) CreateUser(ctx context.Context, user *User) error {
    // Use primary for writes
    conn := s.db.Connection("primary")
    return s.insertUser(ctx, conn, user)
}
```

### Database Monitoring

Built-in monitoring and metrics:

```go
// Get connection statistics
stats := db.Stats()
for name, stat := range stats {
    fmt.Printf("Connection %s:\n", name)
    fmt.Printf("  Active: %d\n", stat.ActiveConnections)
    fmt.Printf("  Idle: %d\n", stat.IdleConnections)
    fmt.Printf("  Total: %d\n", stat.TotalConnections)
    fmt.Printf("  Queries: %d\n", stat.QueriesExecuted)
    fmt.Printf("  Errors: %d\n", stat.QueryErrors)
}

// Health check
if err := db.Health(ctx); err != nil {
    log.Printf("Database health check failed: %v", err)
}
```

## Testing

The database extension provides testing utilities:

```go
func TestUserService(t *testing.T) {
    // Create test app with in-memory SQLite
    app := forge.NewTestApp(t, forge.TestConfig{
        Extensions: []forge.Extension{
            database.NewExtension(
                database.WithSQLite(":memory:"),
                database.WithMigrations("./testdata/migrations"),
            ),
        },
    })
    
    // Get service
    userService := forge.GetService[*UserService](app.Container())
    
    // Test user creation
    user := &User{
        ID:    "test-user",
        Name:  "Test User",
        Email: "test@example.com",
    }
    
    err := userService.CreateUser(context.Background(), user)
    require.NoError(t, err)
    
    // Test user retrieval
    retrieved, err := userService.GetUser(context.Background(), "test-user")
    require.NoError(t, err)
    assert.Equal(t, user.Name, retrieved.Name)
    assert.Equal(t, user.Email, retrieved.Email)
}
```

## Best Practices

<Callout type="info">
Follow these best practices for optimal database performance and maintainability.
</Callout>

### Performance Optimization

- **Connection Pooling**: Configure appropriate pool sizes based on your workload
- **Query Optimization**: Use EXPLAIN to analyze query performance
- **Indexing**: Create indexes for frequently queried columns
- **Prepared Statements**: Use parameterized queries to prevent SQL injection
- **Batch Operations**: Use batch inserts/updates for bulk operations

### Security Guidelines

- **Parameter Binding**: Always use parameterized queries
- **Least Privilege**: Use database users with minimal required permissions
- **Connection Security**: Use TLS/SSL for database connections
- **Secrets Management**: Store database credentials securely
- **Audit Logging**: Log database operations for security auditing

### Error Handling

```go
func (s *UserService) GetUser(ctx context.Context, id string) (*User, error) {
    conn := s.db.DefaultConnection()
    
    var user User
    err := conn.QueryRow(ctx, "SELECT id, name, email FROM users WHERE id = $1", id).
        Scan(&user.ID, &user.Name, &user.Email)
    
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return nil, ErrUserNotFound
        }
        return nil, fmt.Errorf("database query failed: %w", err)
    }
    
    return &user, nil
}
```

## Configuration Reference

### Complete Configuration Example

```yaml
database:
  default:
    driver: postgres
    dsn: postgres://user:pass@localhost/mydb?sslmode=disable
    pool:
      min_connections: 5
      max_connections: 50
      max_idle_time: 30m
      max_lifetime: 1h
      health_check_period: 1m
    migrations:
      enabled: true
      path: ./migrations
      table: schema_migrations
      timeout: 5m
    query:
      timeout: 30s
      log_slow_queries: true
      slow_query_threshold: 1s
    retry:
      max_attempts: 3
      initial_interval: 100ms
      max_interval: 1s
      multiplier: 2.0
```

## Next Steps

<Cards>
  <Card
    title="ðŸ’¾ Cache Extension"
    description="Add high-performance caching to your application"
    href="/docs/extensions/cache"
  />
  <Card
    title="ðŸ“¡ Events Extension"
    description="Build event-driven architectures"
    href="/docs/extensions/events"
  />
  <Card
    title="ðŸ” Auth Extension"
    description="Implement authentication and authorization"
    href="/docs/extensions/auth"
  />
  <Card
    title="ðŸš€ Quick Start"
    description="Build your first application with database support"
    href="/docs/quick-start"
  />
</Cards>