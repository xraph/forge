---
title: Events Extension
description: Event-driven architecture with event sourcing, CQRS, and distributed messaging patterns
---

import { Card, Cards } from 'fumadocs-ui/components/card'
import { Callout } from 'fumadocs-ui/components/callout'
import { Tab, Tabs } from 'fumadocs-ui/components/tabs'

The Events Extension provides comprehensive event-driven architecture capabilities with support for event sourcing, CQRS patterns, distributed messaging, and real-time event streaming.

## Key Features

<Cards>
  <Card
    title="📡 Event Bus"
    description="In-memory and distributed event publishing and subscription"
  />
  <Card
    title="🗄️ Event Store"
    description="Persistent event storage with replay and projection capabilities"
  />
  <Card
    title="🔄 Event Sourcing"
    description="Complete event sourcing implementation with aggregates"
  />
  <Card
    title="📊 CQRS"
    description="Command Query Responsibility Segregation patterns"
  />
  <Card
    title="🌊 Event Streaming"
    description="Real-time event streaming with WebSockets and SSE"
  />
  <Card
    title="🔗 Sagas"
    description="Distributed transaction coordination with sagas"
  />
</Cards>

## Installation

```bash
go get github.com/xraph/forge/extensions/events
```

## Basic Usage

<Tabs items={['Event Bus', 'Event Store', 'Event Sourcing', 'CQRS']}>
  <Tab value="Event Bus">
    ```go
    package main
    
    import (
        "context"
        "time"
        "github.com/xraph/forge/v2"
        "github.com/xraph/forge/v2/extensions/events"
    )
    
    func main() {
        app := forge.NewApp(forge.AppConfig{
            Name: "my-app",
        })
        
        // Register events extension
        app.RegisterExtension(
            events.NewExtension(
                events.WithInMemoryBus(),
                events.WithEventStore(events.EventStoreConfig{
                    Driver: "postgres",
                    ConnectionString: "postgres://localhost/events",
                }),
            ),
        )
        
        // Get event services
        eventBus := forge.GetService[events.Bus](app.Container())
        eventStore := forge.GetService[events.Store](app.Container())
        
        // Define event types
        type UserCreatedEvent struct {
            UserID    string    `json:"user_id"`
            Email     string    `json:"email"`
            Name      string    `json:"name"`
            CreatedAt time.Time `json:"created_at"`
        }
        
        // Subscribe to events
        err := eventBus.Subscribe(context.Background(), "user.created", 
            func(ctx context.Context, event events.Event) error {
                var userEvent UserCreatedEvent
                if err := event.Unmarshal(&userEvent); err != nil {
                    return err
                }
                
                // Handle the event
                fmt.Printf("User created: %s (%s)\n", userEvent.Name, userEvent.Email)
                
                // Send welcome email
                return sendWelcomeEmail(ctx, userEvent.Email)
            },
        )
        if err != nil {
            panic(err)
        }
        
        // Publish events
        app.Router().POST("/users", func(ctx forge.Context) error {
            var req CreateUserRequest
            if err := ctx.Bind(&req); err != nil {
                return err
            }
            
            // Create user
            user, err := createUser(ctx, req)
            if err != nil {
                return err
            }
            
            // Publish event
            event := events.NewEvent("user.created", UserCreatedEvent{
                UserID:    user.ID,
                Email:     user.Email,
                Name:      user.Name,
                CreatedAt: time.Now(),
            })
            
            if err := eventBus.Publish(ctx, event); err != nil {
                // Log error but don't fail the request
                ctx.Logger().Error("failed to publish event", forge.F("error", err))
            }
            
            return ctx.JSON(201, user)
        })
        
        app.Run()
    }
    ```
  </Tab>
  <Tab value="Event Store">
    ```go
    // Event store operations
    func useEventStore(ctx context.Context) error {
        eventStore := forge.GetService[events.Store](app.Container())
        
        // Store events
        events := []events.Event{
            events.NewEvent("user.created", UserCreatedEvent{
                UserID: "123",
                Email:  "user@example.com",
                Name:   "John Doe",
            }),
            events.NewEvent("user.email_verified", UserEmailVerifiedEvent{
                UserID:     "123",
                VerifiedAt: time.Now(),
            }),
        }
        
        err := eventStore.AppendEvents(ctx, "user-123", events, events.ExpectedVersion(0))
        if err != nil {
            return err
        }
        
        // Read events
        streamEvents, err := eventStore.ReadEvents(ctx, "user-123", 0, 100)
        if err != nil {
            return err
        }
        
        // Read all events of a type
        userCreatedEvents, err := eventStore.ReadEventsByType(ctx, "user.created", 0, 100)
        if err != nil {
            return err
        }
        
        // Subscribe to new events
        subscription, err := eventStore.Subscribe(ctx, "user.*", 
            func(ctx context.Context, event events.StoredEvent) error {
                fmt.Printf("New event: %s\n", event.Type)
                return nil
            },
        )
        if err != nil {
            return err
        }
        defer subscription.Close()
        
        return nil
    }
    ```
  </Tab>
  <Tab value="Event Sourcing">
    ```go
    // Define aggregate
    type UserAggregate struct {
        events.BaseAggregate
        
        ID            string
        Email         string
        Name          string
        EmailVerified bool
        IsActive      bool
    }
    
    func (u *UserAggregate) CreateUser(email, name string) error {
        if u.ID != "" {
            return errors.New("user already exists")
        }
        
        event := UserCreatedEvent{
            UserID:    uuid.New().String(),
            Email:     email,
            Name:      name,
            CreatedAt: time.Now(),
        }
        
        u.ApplyEvent(events.NewEvent("user.created", event))
        return nil
    }
    
    func (u *UserAggregate) VerifyEmail() error {
        if u.EmailVerified {
            return errors.New("email already verified")
        }
        
        event := UserEmailVerifiedEvent{
            UserID:     u.ID,
            VerifiedAt: time.Now(),
        }
        
        u.ApplyEvent(events.NewEvent("user.email_verified", event))
        return nil
    }
    
    // Event handlers (projections)
    func (u *UserAggregate) On(event events.Event) error {
        switch event.Type {
        case "user.created":
            var e UserCreatedEvent
            if err := event.Unmarshal(&e); err != nil {
                return err
            }
            u.ID = e.UserID
            u.Email = e.Email
            u.Name = e.Name
            u.IsActive = true
            
        case "user.email_verified":
            var e UserEmailVerifiedEvent
            if err := event.Unmarshal(&e); err != nil {
                return err
            }
            u.EmailVerified = true
            
        case "user.deactivated":
            u.IsActive = false
        }
        
        return nil
    }
    
    // Repository for aggregates
    type UserRepository struct {
        eventStore events.Store
    }
    
    func (r *UserRepository) GetByID(ctx context.Context, userID string) (*UserAggregate, error) {
        streamID := "user-" + userID
        
        events, err := r.eventStore.ReadEvents(ctx, streamID, 0, -1)
        if err != nil {
            return nil, err
        }
        
        aggregate := &UserAggregate{}
        for _, event := range events {
            if err := aggregate.On(event.Event); err != nil {
                return nil, err
            }
        }
        
        aggregate.SetVersion(len(events))
        return aggregate, nil
    }
    
    func (r *UserRepository) Save(ctx context.Context, aggregate *UserAggregate) error {
        streamID := "user-" + aggregate.ID
        uncommittedEvents := aggregate.GetUncommittedEvents()
        
        if len(uncommittedEvents) == 0 {
            return nil
        }
        
        expectedVersion := aggregate.GetVersion() - len(uncommittedEvents)
        
        err := r.eventStore.AppendEvents(ctx, streamID, uncommittedEvents, 
            events.ExpectedVersion(expectedVersion))
        if err != nil {
            return err
        }
        
        aggregate.MarkEventsAsCommitted()
        return nil
    }
    ```
  </Tab>
  <Tab value="CQRS">
    ```go
    // Command side
    type CreateUserCommand struct {
        Email string `json:"email" validate:"required,email"`
        Name  string `json:"name" validate:"required"`
    }
    
    type UserCommandHandler struct {
        repository *UserRepository
        eventBus   events.Bus
    }
    
    func (h *UserCommandHandler) Handle(ctx context.Context, cmd CreateUserCommand) error {
        // Create aggregate
        aggregate := &UserAggregate{}
        if err := aggregate.CreateUser(cmd.Email, cmd.Name); err != nil {
            return err
        }
        
        // Save aggregate (this publishes events)
        if err := h.repository.Save(ctx, aggregate); err != nil {
            return err
        }
        
        // Publish events to bus
        for _, event := range aggregate.GetUncommittedEvents() {
            if err := h.eventBus.Publish(ctx, event); err != nil {
                // Log error but don't fail the command
                log.Error("failed to publish event", "error", err)
            }
        }
        
        return nil
    }
    
    // Query side
    type UserProjection struct {
        ID            string    `json:"id"`
        Email         string    `json:"email"`
        Name          string    `json:"name"`
        EmailVerified bool      `json:"email_verified"`
        IsActive      bool      `json:"is_active"`
        CreatedAt     time.Time `json:"created_at"`
        UpdatedAt     time.Time `json:"updated_at"`
    }
    
    type UserQueryHandler struct {
        db database.Manager
    }
    
    func (h *UserQueryHandler) GetUser(ctx context.Context, userID string) (*UserProjection, error) {
        var user UserProjection
        err := h.db.QueryRow(ctx, 
            "SELECT id, email, name, email_verified, is_active, created_at, updated_at FROM user_projections WHERE id = $1",
            userID,
        ).Scan(&user.ID, &user.Email, &user.Name, &user.EmailVerified, &user.IsActive, &user.CreatedAt, &user.UpdatedAt)
        
        if err != nil {
            return nil, err
        }
        
        return &user, nil
    }
    
    func (h *UserQueryHandler) ListUsers(ctx context.Context, limit, offset int) ([]UserProjection, error) {
        rows, err := h.db.Query(ctx,
            "SELECT id, email, name, email_verified, is_active, created_at, updated_at FROM user_projections ORDER BY created_at DESC LIMIT $1 OFFSET $2",
            limit, offset,
        )
        if err != nil {
            return nil, err
        }
        defer rows.Close()
        
        var users []UserProjection
        for rows.Next() {
            var user UserProjection
            err := rows.Scan(&user.ID, &user.Email, &user.Name, &user.EmailVerified, &user.IsActive, &user.CreatedAt, &user.UpdatedAt)
            if err != nil {
                return nil, err
            }
            users = append(users, user)
        }
        
        return users, nil
    }
    
    // Projection updater
    type UserProjectionUpdater struct {
        db database.Manager
    }
    
    func (u *UserProjectionUpdater) HandleUserCreated(ctx context.Context, event events.Event) error {
        var e UserCreatedEvent
        if err := event.Unmarshal(&e); err != nil {
            return err
        }
        
        _, err := u.db.Exec(ctx,
            `INSERT INTO user_projections (id, email, name, email_verified, is_active, created_at, updated_at)
             VALUES ($1, $2, $3, $4, $5, $6, $7)`,
            e.UserID, e.Email, e.Name, false, true, e.CreatedAt, e.CreatedAt,
        )
        
        return err
    }
    
    func (u *UserProjectionUpdater) HandleEmailVerified(ctx context.Context, event events.Event) error {
        var e UserEmailVerifiedEvent
        if err := event.Unmarshal(&e); err != nil {
            return err
        }
        
        _, err := u.db.Exec(ctx,
            "UPDATE user_projections SET email_verified = true, updated_at = $1 WHERE id = $2",
            e.VerifiedAt, e.UserID,
        )
        
        return err
    }
    ```
  </Tab>
</Tabs>

## Configuration

### YAML Configuration

```yaml
events:
  # Event bus configuration
  bus:
    driver: memory # memory, nats, kafka, redis
    
    # NATS configuration
    nats:
      urls: [nats://localhost:4222]
      cluster_id: forge-cluster
      client_id: forge-app
      durable_name: forge-durable
      
    # Kafka configuration  
    kafka:
      brokers: [localhost:9092]
      group_id: forge-group
      auto_offset_reset: earliest
      
    # Redis configuration
    redis:
      addresses: [localhost:6379]
      stream_name: forge-events
      consumer_group: forge-consumers
  
  # Event store configuration
  store:
    driver: postgres # postgres, mysql, mongodb, badger
    connection_string: ${DATABASE_URL}
    table_name: events
    
    # Snapshot configuration
    snapshots:
      enabled: true
      frequency: 100 # Take snapshot every 100 events
      table_name: snapshots
    
    # Projection configuration
    projections:
      enabled: true
      checkpoint_frequency: 10 # Save checkpoint every 10 events
      checkpoint_table: projection_checkpoints
  
  # Event streaming configuration
  streaming:
    enabled: true
    websocket:
      path: /events/ws
      origins: ["*"]
    sse:
      path: /events/sse
      heartbeat_interval: 30s
  
  # Saga configuration
  sagas:
    enabled: true
    timeout: 30m
    retry_attempts: 3
    retry_delay: 5s
  
  # Serialization
  serializer: json # json, msgpack, protobuf
  
  # Metrics and monitoring
  metrics:
    enabled: true
    latency_buckets: [0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1.0]
```

## Event Bus Interface

The events extension provides a unified interface for event publishing and subscription:

```go
type Bus interface {
    // Publishing
    Publish(ctx context.Context, event Event) error
    PublishBatch(ctx context.Context, events []Event) error
    
    // Subscription
    Subscribe(ctx context.Context, pattern string, handler EventHandler) error
    SubscribeWithOptions(ctx context.Context, pattern string, handler EventHandler, opts SubscribeOptions) error
    Unsubscribe(ctx context.Context, pattern string, handler EventHandler) error
    
    // Management
    Close() error
    Health(ctx context.Context) error
}

type Event interface {
    ID() string
    Type() string
    Data() []byte
    Metadata() map[string]string
    Timestamp() time.Time
    Version() int
    Unmarshal(dest interface{}) error
}

type EventHandler func(ctx context.Context, event Event) error

type SubscribeOptions struct {
    QueueGroup    string
    Durable       bool
    AutoAck       bool
    MaxInFlight   int
    AckWait       time.Duration
    RetryAttempts int
    RetryDelay    time.Duration
}
```

## Event Store Interface

```go
type Store interface {
    // Stream operations
    AppendEvents(ctx context.Context, streamID string, events []Event, expectedVersion ExpectedVersion) error
    ReadEvents(ctx context.Context, streamID string, fromVersion int, maxCount int) ([]StoredEvent, error)
    ReadEventsBackward(ctx context.Context, streamID string, fromVersion int, maxCount int) ([]StoredEvent, error)
    
    // Global operations
    ReadAllEvents(ctx context.Context, fromPosition int64, maxCount int) ([]StoredEvent, error)
    ReadEventsByType(ctx context.Context, eventType string, fromPosition int64, maxCount int) ([]StoredEvent, error)
    
    // Subscriptions
    Subscribe(ctx context.Context, pattern string, handler StoredEventHandler) (Subscription, error)
    SubscribeFromPosition(ctx context.Context, pattern string, position int64, handler StoredEventHandler) (Subscription, error)
    
    // Snapshots
    SaveSnapshot(ctx context.Context, streamID string, snapshot Snapshot) error
    LoadSnapshot(ctx context.Context, streamID string) (Snapshot, error)
    
    // Management
    DeleteStream(ctx context.Context, streamID string) error
    StreamExists(ctx context.Context, streamID string) (bool, error)
    GetStreamMetadata(ctx context.Context, streamID string) (StreamMetadata, error)
}

type StoredEvent struct {
    Event
    StreamID     string
    Version      int
    Position     int64
    CreatedAt    time.Time
}

type ExpectedVersion int

const (
    ExpectedVersionAny       ExpectedVersion = -2
    ExpectedVersionNoStream  ExpectedVersion = -1
    ExpectedVersionEmptyStream ExpectedVersion = 0
)
```

## Advanced Patterns

### Saga Pattern

```go
type OrderSaga struct {
    events.BaseSaga
    
    OrderID     string
    CustomerID  string
    ProductID   string
    Amount      decimal.Decimal
    Status      string
}

func (s *OrderSaga) Handle(ctx context.Context, event events.Event) error {
    switch event.Type {
    case "order.created":
        return s.handleOrderCreated(ctx, event)
    case "payment.processed":
        return s.handlePaymentProcessed(ctx, event)
    case "payment.failed":
        return s.handlePaymentFailed(ctx, event)
    case "inventory.reserved":
        return s.handleInventoryReserved(ctx, event)
    case "inventory.unavailable":
        return s.handleInventoryUnavailable(ctx, event)
    }
    return nil
}

func (s *OrderSaga) handleOrderCreated(ctx context.Context, event events.Event) error {
    var e OrderCreatedEvent
    if err := event.Unmarshal(&e); err != nil {
        return err
    }
    
    s.OrderID = e.OrderID
    s.CustomerID = e.CustomerID
    s.ProductID = e.ProductID
    s.Amount = e.Amount
    s.Status = "processing"
    
    // Start the saga by processing payment
    return s.SendCommand(ctx, ProcessPaymentCommand{
        OrderID:    e.OrderID,
        CustomerID: e.CustomerID,
        Amount:     e.Amount,
    })
}

func (s *OrderSaga) handlePaymentProcessed(ctx context.Context, event events.Event) error {
    // Payment successful, reserve inventory
    return s.SendCommand(ctx, ReserveInventoryCommand{
        OrderID:   s.OrderID,
        ProductID: s.ProductID,
        Quantity:  1,
    })
}

func (s *OrderSaga) handlePaymentFailed(ctx context.Context, event events.Event) error {
    // Payment failed, cancel order
    s.Status = "cancelled"
    
    return s.SendCommand(ctx, CancelOrderCommand{
        OrderID: s.OrderID,
        Reason:  "payment_failed",
    })
}

func (s *OrderSaga) handleInventoryReserved(ctx context.Context, event events.Event) error {
    // Inventory reserved, complete order
    s.Status = "completed"
    
    return s.SendCommand(ctx, CompleteOrderCommand{
        OrderID: s.OrderID,
    })
}

func (s *OrderSaga) handleInventoryUnavailable(ctx context.Context, event events.Event) error {
    // Inventory unavailable, refund payment and cancel order
    s.Status = "cancelled"
    
    // Compensating actions
    if err := s.SendCommand(ctx, RefundPaymentCommand{
        OrderID: s.OrderID,
        Amount:  s.Amount,
    }); err != nil {
        return err
    }
    
    return s.SendCommand(ctx, CancelOrderCommand{
        OrderID: s.OrderID,
        Reason:  "inventory_unavailable",
    })
}
```

### Event Streaming

```go
type EventStreamer struct {
    eventStore events.Store
    hub        *websocket.Hub
}

func (s *EventStreamer) StreamEvents(ctx context.Context, pattern string, clientID string) error {
    // Subscribe to new events
    subscription, err := s.eventStore.Subscribe(ctx, pattern, 
        func(ctx context.Context, event events.StoredEvent) error {
            // Send event to WebSocket client
            return s.hub.SendToClient(clientID, map[string]interface{}{
                "type": "event",
                "data": event,
            })
        },
    )
    if err != nil {
        return err
    }
    
    // Clean up subscription when client disconnects
    go func() {
        <-ctx.Done()
        subscription.Close()
    }()
    
    return nil
}

// WebSocket handler
func (s *EventStreamer) HandleWebSocket(ctx forge.Context) error {
    conn, err := websocket.Upgrade(ctx.Response(), ctx.Request(), nil)
    if err != nil {
        return err
    }
    defer conn.Close()
    
    clientID := uuid.New().String()
    
    // Register client
    s.hub.RegisterClient(clientID, conn)
    defer s.hub.UnregisterClient(clientID)
    
    // Handle subscription requests
    for {
        var msg struct {
            Type    string `json:"type"`
            Pattern string `json:"pattern"`
        }
        
        if err := conn.ReadJSON(&msg); err != nil {
            break
        }
        
        if msg.Type == "subscribe" {
            go s.StreamEvents(ctx, msg.Pattern, clientID)
        }
    }
    
    return nil
}
```

### Event Replay and Projections

```go
type ProjectionManager struct {
    eventStore events.Store
    db         database.Manager
}

func (p *ProjectionManager) RebuildProjection(ctx context.Context, projectionName string) error {
    // Get projection handler
    handler, exists := p.getProjectionHandler(projectionName)
    if !exists {
        return fmt.Errorf("projection handler not found: %s", projectionName)
    }
    
    // Clear existing projection data
    if err := p.clearProjection(ctx, projectionName); err != nil {
        return err
    }
    
    // Replay all events
    position := int64(0)
    batchSize := 1000
    
    for {
        events, err := p.eventStore.ReadAllEvents(ctx, position, batchSize)
        if err != nil {
            return err
        }
        
        if len(events) == 0 {
            break
        }
        
        // Process events in batch
        for _, event := range events {
            if err := handler(ctx, event); err != nil {
                return fmt.Errorf("failed to process event %s: %w", event.ID(), err)
            }
            position = event.Position + 1
        }
        
        // Save checkpoint
        if err := p.saveCheckpoint(ctx, projectionName, position); err != nil {
            return err
        }
        
        // Check if we've processed all events
        if len(events) < batchSize {
            break
        }
    }
    
    return nil
}

func (p *ProjectionManager) StartProjection(ctx context.Context, projectionName string) error {
    handler, exists := p.getProjectionHandler(projectionName)
    if !exists {
        return fmt.Errorf("projection handler not found: %s", projectionName)
    }
    
    // Get last checkpoint
    position, err := p.getCheckpoint(ctx, projectionName)
    if err != nil {
        return err
    }
    
    // Subscribe from checkpoint position
    subscription, err := p.eventStore.SubscribeFromPosition(ctx, "*", position,
        func(ctx context.Context, event events.StoredEvent) error {
            if err := handler(ctx, event); err != nil {
                return err
            }
            
            // Save checkpoint periodically
            return p.saveCheckpoint(ctx, projectionName, event.Position+1)
        },
    )
    if err != nil {
        return err
    }
    
    // Keep subscription alive
    go func() {
        <-ctx.Done()
        subscription.Close()
    }()
    
    return nil
}
```

## Testing

The events extension provides comprehensive testing utilities:

```go
func TestEventSourcing(t *testing.T) {
    app := forge.NewTestApp(t, forge.TestConfig{
        Extensions: []forge.Extension{
            events.NewExtension(
                events.WithInMemoryBus(),
                events.WithInMemoryStore(),
            ),
        },
    })
    
    eventStore := forge.GetService[events.Store](app.Container())
    repository := &UserRepository{eventStore: eventStore}
    
    ctx := context.Background()
    
    // Test aggregate creation
    t.Run("create user aggregate", func(t *testing.T) {
        aggregate := &UserAggregate{}
        err := aggregate.CreateUser("test@example.com", "Test User")
        require.NoError(t, err)
        
        err = repository.Save(ctx, aggregate)
        require.NoError(t, err)
        
        // Verify events were stored
        events, err := eventStore.ReadEvents(ctx, "user-"+aggregate.ID, 0, -1)
        require.NoError(t, err)
        require.Len(t, events, 1)
        require.Equal(t, "user.created", events[0].Type)
    })
    
    // Test aggregate loading
    t.Run("load user aggregate", func(t *testing.T) {
        // Create and save aggregate
        aggregate := &UserAggregate{}
        aggregate.CreateUser("test@example.com", "Test User")
        repository.Save(ctx, aggregate)
        
        userID := aggregate.ID
        
        // Load aggregate
        loadedAggregate, err := repository.GetByID(ctx, userID)
        require.NoError(t, err)
        require.Equal(t, userID, loadedAggregate.ID)
        require.Equal(t, "test@example.com", loadedAggregate.Email)
        require.Equal(t, "Test User", loadedAggregate.Name)
    })
}

// Event bus testing
func TestEventBus(t *testing.T) {
    app := forge.NewTestApp(t, forge.TestConfig{
        Extensions: []forge.Extension{
            events.NewExtension(events.WithInMemoryBus()),
        },
    })
    
    eventBus := forge.GetService[events.Bus](app.Container())
    ctx := context.Background()
    
    // Test event publishing and subscription
    t.Run("publish and subscribe", func(t *testing.T) {
        received := make(chan events.Event, 1)
        
        // Subscribe to events
        err := eventBus.Subscribe(ctx, "test.*", 
            func(ctx context.Context, event events.Event) error {
                received <- event
                return nil
            },
        )
        require.NoError(t, err)
        
        // Publish event
        event := events.NewEvent("test.event", map[string]string{
            "message": "hello world",
        })
        
        err = eventBus.Publish(ctx, event)
        require.NoError(t, err)
        
        // Verify event was received
        select {
        case receivedEvent := <-received:
            require.Equal(t, "test.event", receivedEvent.Type())
        case <-time.After(time.Second):
            t.Fatal("event not received")
        }
    })
}
```

## Best Practices

<Callout type="info">
Follow these best practices when implementing event-driven architecture.
</Callout>

### Event Design

- **Immutable Events**: Events should be immutable once created
- **Rich Events**: Include all necessary data to avoid additional lookups
- **Versioning**: Version your events for backward compatibility
- **Naming**: Use clear, descriptive event names (verb.noun format)
- **Size**: Keep events reasonably small for performance

### Error Handling

- **Idempotency**: Ensure event handlers are idempotent
- **Retry Logic**: Implement exponential backoff for retries
- **Dead Letter Queue**: Handle failed events with DLQ
- **Circuit Breaker**: Prevent cascade failures
- **Monitoring**: Monitor event processing metrics

### Performance

- **Batching**: Process events in batches when possible
- **Async Processing**: Use async handlers for non-critical operations
- **Partitioning**: Partition events for parallel processing
- **Caching**: Cache frequently accessed projections
- **Compression**: Compress large events

## Next Steps

<Cards>
  <Card
    title="🗄️ Database Extension"
    description="Store events and projections"
    href="/docs/extensions/database"
  />
  <Card
    title="💾 Cache Extension"
    description="Cache projections and event data"
    href="/docs/extensions/cache"
  />
  <Card
    title="📡 Message Queues"
    description="Integrate with external message systems"
    href="/docs/extensions/queue"
  />
  <Card
    title="🚀 CQRS Guide"
    description="Implement CQRS patterns"
    href="/docs/guides/cqrs"
  />
</Cards>