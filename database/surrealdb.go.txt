package database

import (
	"context"
	"encoding/json"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/surrealdb/surrealdb.go"
)

// surrealDatabase implements NoSQLDatabase interface for SurrealDB
type surrealDatabase struct {
	*baseNoSQLDatabase
	client    *surrealdb.DB
	namespace string
	database  string
	endpoint  string
	username  string
	password  string
	timeout   time.Duration
}

// surrealCollection implements Collection interface for SurrealDB
type surrealCollection struct {
	*baseCollection
	client *surrealdb.DB
	table  string
}

// surrealCursor implements Cursor interface for SurrealDB
type surrealCursor struct {
	*baseCursor
	documents []SurrealDocument
	current   int
	mu        sync.RWMutex
}

// SurrealDocument represents a SurrealDB document
type SurrealDocument struct {
	ID        string                 `json:"id"`
	Data      map[string]interface{} `json:"data"`
	CreatedAt time.Time              `json:"created_at"`
	UpdatedAt time.Time              `json:"updated_at"`
	Metadata  map[string]interface{} `json:"metadata,omitempty"`
}

// SurrealQuery represents a SurrealDB query
type SurrealQuery struct {
	Query     string                 `json:"query"`
	Variables map[string]interface{} `json:"variables,omitempty"`
	Timeout   time.Duration          `json:"timeout,omitempty"`
	ReadOnly  bool                   `json:"read_only,omitempty"`
}

// SurrealResponse represents a SurrealDB response
type SurrealResponse struct {
	Time   string        `json:"time"`
	Status string        `json:"status"`
	Result []interface{} `json:"result"`
	Detail string        `json:"detail,omitempty"`
}

// NewSurrealDatabase creates a new SurrealDB database connection
func newSurrealDatabase(config NoSQLConfig) (NoSQLDatabase, error) {
	db := &surrealDatabase{
		baseNoSQLDatabase: &baseNoSQLDatabase{
			config:    config,
			driver:    "surrealdb",
			connected: false,
			stats:     make(map[string]interface{}),
		},
		namespace: "forge",
		database:  "main",
		username:  config.Username,
		password:  config.Password,
		timeout:   30 * time.Second,
	}

	// Set timeout from config
	if config.ConnectTimeout > 0 {
		db.timeout = config.ConnectTimeout
	}

	// Parse configuration
	if config.URL != "" {
		db.endpoint = config.URL
	} else {
		host := config.Host
		if host == "" {
			host = "localhost"
		}
		port := config.Port
		if port == 0 {
			port = 8000 // Default SurrealDB port
		}
		db.endpoint = fmt.Sprintf("ws://%s:%d/rpc", host, port)
	}

	// Set namespace and database
	if config.Database != "" {
		db.database = config.Database
	}

	// Parse additional config fields
	if config.AuthDB != "" {
		db.namespace = config.AuthDB
	}

	if err := db.Connect(context.Background()); err != nil {
		return nil, err
	}

	return db, nil
}

// Connect establishes SurrealDB connection
func (db *surrealDatabase) Connect(ctx context.Context) error {
	db.mu.Lock()
	defer db.mu.Unlock()

	// Create SurrealDB client
	client, err := surrealdb.New(db.endpoint)
	if err != nil {
		return fmt.Errorf("failed to create SurrealDB client: %w", err)
	}

	db.client = client

	// Sign in if credentials provided
	if db.username != "" && db.password != "" {
		_, err := db.client.SignIn(&surrealdb.Auth{
			Username: db.username,
			Password: db.password,
		})
		if err != nil {
			return fmt.Errorf("failed to sign in: %w", err)
		}
	}

	// Use namespace and database
	if err := db.client.Use(db.namespace, db.database); err != nil {
		return fmt.Errorf("failed to use namespace/database: %w", err)
	}

	// Test connection
	if err := db.Ping(ctx); err != nil {
		return fmt.Errorf("failed to ping SurrealDB: %w", err)
	}

	db.connected = true
	return nil
}

// Close closes SurrealDB connection
func (db *surrealDatabase) Close() error {
	db.mu.Lock()
	defer db.mu.Unlock()

	if db.client != nil {
		db.client.Close()
	}

	db.connected = false
	return nil
}

// Ping tests SurrealDB connection
func (db *surrealDatabase) Ping(ctx context.Context) error {
	if db.client == nil {
		return fmt.Errorf("SurrealDB not connected")
	}

	// Simple query to test connection
	result, err := db.client.Query("SELECT VALUE 1", nil)
	if err != nil {
		return fmt.Errorf("ping failed: %w", err)
	}

	if len(result) == 0 {
		return fmt.Errorf("ping failed: no response")
	}

	return nil
}

// Collection returns a SurrealDB collection (table)
func (db *surrealDatabase) Collection(name string) Collection {
	return &surrealCollection{
		baseCollection: &baseCollection{
			name: name,
			db:   db,
		},
		client: db.client,
		table:  name,
	}
}

// CreateCollection creates a new collection (table)
func (db *surrealDatabase) CreateCollection(ctx context.Context, name string) error {
	if db.client == nil {
		return fmt.Errorf("SurrealDB not connected")
	}

	// SurrealDB creates tables automatically when first document is inserted
	// But we can define the table structure explicitly
	query := fmt.Sprintf(`
		DEFINE TABLE %s SCHEMAFULL
		DEFINE FIELD id ON TABLE %s TYPE record;
		DEFINE FIELD data ON TABLE %s TYPE object;
		DEFINE FIELD created_at ON TABLE %s TYPE datetime;
		DEFINE FIELD updated_at ON TABLE %s TYPE datetime;
	`, name, name, name, name, name)

	_, err := db.client.Query(query, nil)
	if err != nil {
		return fmt.Errorf("failed to create table: %w", err)
	}

	return nil
}

// DropCollection drops a collection (table)
func (db *surrealDatabase) DropCollection(ctx context.Context, name string) error {
	if db.client == nil {
		return fmt.Errorf("SurrealDB not connected")
	}

	query := fmt.Sprintf("REMOVE TABLE %s", name)
	_, err := db.client.Query(query, nil)
	if err != nil {
		return fmt.Errorf("failed to drop table: %w", err)
	}

	return nil
}

// ListCollections lists all collections (tables)
func (db *surrealDatabase) ListCollections(ctx context.Context) ([]string, error) {
	if db.client == nil {
		return nil, fmt.Errorf("SurrealDB not connected")
	}

	query := "INFO FOR DB"
	result, err := db.client.Query(query, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to list tables: %w", err)
	}

	if len(result) == 0 {
		return []string{}, nil
	}

	// Parse result to extract table names
	var tables []string
	if resultMap, ok := result[0].Result.(map[string]interface{}); ok {
		if tablesMap, ok := resultMap["tb"].(map[string]interface{}); ok {
			for tableName := range tablesMap {
				tables = append(tables, tableName)
			}
		}
	}

	return tables, nil
}

// Drop drops the entire database
func (db *surrealDatabase) Drop(ctx context.Context) error {
	if db.client == nil {
		return fmt.Errorf("SurrealDB not connected")
	}

	query := "REMOVE DATABASE"
	_, err := db.client.Query(query, nil)
	if err != nil {
		return fmt.Errorf("failed to drop database: %w", err)
	}

	return nil
}

// SurrealDB Collection implementation

// FindOne finds a single document
func (c *surrealCollection) FindOne(ctx context.Context, filter interface{}) (interface{}, error) {
	if c.client == nil {
		return nil, fmt.Errorf("client not initialized")
	}

	// Build query
	query := c.buildSelectQuery(filter, 1)

	// Execute query
	result, err := c.client.Query(query.Query, query.Variables)
	if err != nil {
		return nil, fmt.Errorf("query failed: %w", err)
	}

	if len(result) == 0 || len(result[0].Result.([]interface{})) == 0 {
		return nil, fmt.Errorf("no documents found")
	}

	// Convert result to SurrealDocument
	doc, err := c.convertToSurrealDocument(result[0].Result.([]interface{})[0])
	if err != nil {
		return nil, err
	}

	return doc, nil
}

// Find finds multiple documents
func (c *surrealCollection) Find(ctx context.Context, filter interface{}) (Cursor, error) {
	if c.client == nil {
		return nil, fmt.Errorf("client not initialized")
	}

	// Build query
	query := c.buildSelectQuery(filter, 0)

	// Execute query
	result, err := c.client.Query(query.Query, query.Variables)
	if err != nil {
		return nil, fmt.Errorf("query failed: %w", err)
	}

	var documents []SurrealDocument
	if len(result) > 0 {
		if resultSlice, ok := result[0].Result.([]interface{}); ok {
			for _, item := range resultSlice {
				doc, err := c.convertToSurrealDocument(item)
				if err != nil {
					continue
				}
				documents = append(documents, doc)
			}
		}
	}

	return &surrealCursor{
		baseCursor: &baseCursor{
			data:   make([]interface{}, len(documents)),
			index:  -1,
			err:    nil,
			closed: false,
		},
		documents: documents,
		current:   -1,
	}, nil
}

// Insert inserts a single document
func (c *surrealCollection) Insert(ctx context.Context, document interface{}) (interface{}, error) {
	if c.client == nil {
		return nil, fmt.Errorf("client not initialized")
	}

	// Convert document to SurrealDocument
	doc, err := c.convertToSurrealDocument(document)
	if err != nil {
		return nil, err
	}

	// Generate ID if not provided
	if doc.ID == "" {
		doc.ID = c.generateID()
	}

	// Set timestamps
	now := time.Now()
	doc.CreatedAt = now
	doc.UpdatedAt = now

	// Create insert query
	query := fmt.Sprintf("CREATE %s:%s CONTENT $data", c.table, doc.ID)
	variables := map[string]interface{}{
		"data": map[string]interface{}{
			"data":       doc.Data,
			"created_at": doc.CreatedAt,
			"updated_at": doc.UpdatedAt,
		},
	}

	// Execute query
	result, err := c.client.Query(query, variables)
	if err != nil {
		return nil, fmt.Errorf("insert failed: %w", err)
	}

	if len(result) == 0 {
		return nil, fmt.Errorf("insert failed: no result")
	}

	return fmt.Sprintf("%s:%s", c.table, doc.ID), nil
}

// InsertMany inserts multiple documents
func (c *surrealCollection) InsertMany(ctx context.Context, documents []interface{}) ([]interface{}, error) {
	if c.client == nil {
		return nil, fmt.Errorf("client not initialized")
	}

	var ids []interface{}
	var createStatements []string
	variables := make(map[string]interface{})

	for i, document := range documents {
		// Convert document to SurrealDocument
		doc, err := c.convertToSurrealDocument(document)
		if err != nil {
			return nil, err
		}

		// Generate ID if not provided
		if doc.ID == "" {
			doc.ID = c.generateID()
		}

		// Set timestamps
		now := time.Now()
		doc.CreatedAt = now
		doc.UpdatedAt = now

		// Create variable name
		varName := fmt.Sprintf("data%d", i)
		variables[varName] = map[string]interface{}{
			"data":       doc.Data,
			"created_at": doc.CreatedAt,
			"updated_at": doc.UpdatedAt,
		}

		// Create statement
		createStatements = append(createStatements, fmt.Sprintf("CREATE %s:%s CONTENT $%s", c.table, doc.ID, varName))
		ids = append(ids, fmt.Sprintf("%s:%s", c.table, doc.ID))
	}

	// Execute batch query
	query := strings.Join(createStatements, "; ")
	_, err := c.client.Query(query, variables)
	if err != nil {
		return nil, fmt.Errorf("batch insert failed: %w", err)
	}

	return ids, nil
}

// Update updates multiple documents
func (c *surrealCollection) Update(ctx context.Context, filter interface{}, update interface{}) (int64, error) {
	if c.client == nil {
		return 0, fmt.Errorf("client not initialized")
	}

	// Build update query
	query := c.buildUpdateQuery(filter, update)

	// Execute query
	result, err := c.client.Query(query.Query, query.Variables)
	if err != nil {
		return 0, fmt.Errorf("update failed: %w", err)
	}

	// Count updated documents
	var count int64
	if len(result) > 0 {
		if resultSlice, ok := result[0].Result.([]interface{}); ok {
			count = int64(len(resultSlice))
		}
	}

	return count, nil
}

// UpdateOne updates a single document
func (c *surrealCollection) UpdateOne(ctx context.Context, filter interface{}, update interface{}) error {
	if c.client == nil {
		return fmt.Errorf("client not initialized")
	}

	// Build update query with LIMIT 1
	query := c.buildUpdateQuery(filter, update)
	if !strings.Contains(query.Query, "LIMIT") {
		query.Query += " LIMIT 1"
	}

	// Execute query
	_, err := c.client.Query(query.Query, query.Variables)
	if err != nil {
		return fmt.Errorf("update failed: %w", err)
	}

	return nil
}

// Delete deletes multiple documents
func (c *surrealCollection) Delete(ctx context.Context, filter interface{}) (int64, error) {
	if c.client == nil {
		return 0, fmt.Errorf("client not initialized")
	}

	// Build delete query
	query := c.buildDeleteQuery(filter)

	// Execute query
	result, err := c.client.Query(query.Query, query.Variables)
	if err != nil {
		return 0, fmt.Errorf("delete failed: %w", err)
	}

	// Count deleted documents
	var count int64
	if len(result) > 0 {
		if resultSlice, ok := result[0].Result.([]interface{}); ok {
			count = int64(len(resultSlice))
		}
	}

	return count, nil
}

// DeleteOne deletes a single document
func (c *surrealCollection) DeleteOne(ctx context.Context, filter interface{}) error {
	if c.client == nil {
		return fmt.Errorf("client not initialized")
	}

	// Build delete query with LIMIT 1
	query := c.buildDeleteQuery(filter)
	if !strings.Contains(query.Query, "LIMIT") {
		query.Query += " LIMIT 1"
	}

	// Execute query
	_, err := c.client.Query(query.Query, query.Variables)
	if err != nil {
		return fmt.Errorf("delete failed: %w", err)
	}

	return nil
}

// Aggregate performs aggregation operations
func (c *surrealCollection) Aggregate(ctx context.Context, pipeline interface{}) (Cursor, error) {
	if c.client == nil {
		return nil, fmt.Errorf("client not initialized")
	}

	// Build aggregation query
	query := c.buildAggregationQuery(pipeline)

	// Execute query
	result, err := c.client.Query(query.Query, query.Variables)
	if err != nil {
		return nil, fmt.Errorf("aggregation failed: %w", err)
	}

	var documents []SurrealDocument
	if len(result) > 0 {
		if resultSlice, ok := result[0].Result.([]interface{}); ok {
			for _, item := range resultSlice {
				doc, err := c.convertToSurrealDocument(item)
				if err != nil {
					continue
				}
				documents = append(documents, doc)
			}
		}
	}

	return &surrealCursor{
		baseCursor: &baseCursor{
			data:   make([]interface{}, len(documents)),
			index:  -1,
			err:    nil,
			closed: false,
		},
		documents: documents,
		current:   -1,
	}, nil
}

// Count counts documents
func (c *surrealCollection) Count(ctx context.Context, filter interface{}) (int64, error) {
	if c.client == nil {
		return 0, fmt.Errorf("client not initialized")
	}

	// Build count query
	query := c.buildCountQuery(filter)

	// Execute query
	result, err := c.client.Query(query.Query, query.Variables)
	if err != nil {
		return 0, fmt.Errorf("count failed: %w", err)
	}

	if len(result) == 0 {
		return 0, nil
	}

	// Extract count from result
	if resultSlice, ok := result[0].Result.([]interface{}); ok {
		if len(resultSlice) > 0 {
			if countMap, ok := resultSlice[0].(map[string]interface{}); ok {
				if count, ok := countMap["count"].(float64); ok {
					return int64(count), nil
				}
			}
		}
	}

	return 0, nil
}

// CreateIndex creates an index
func (c *surrealCollection) CreateIndex(ctx context.Context, keys interface{}, opts *IndexOptions) error {
	if c.client == nil {
		return fmt.Errorf("client not initialized")
	}

	indexName := "idx_" + c.table
	if opts != nil && opts.Name != nil {
		indexName = *opts.Name
	}

	// Build index query
	if keyMap, ok := keys.(map[string]interface{}); ok {
		var fields []string
		for key := range keyMap {
			fields = append(fields, key)
		}

		unique := ""
		if opts != nil && opts.Unique != nil && *opts.Unique {
			unique = "UNIQUE"
		}

		query := fmt.Sprintf("DEFINE INDEX %s ON TABLE %s FIELDS %s %s", indexName, c.table, strings.Join(fields, ", "), unique)
		_, err := c.client.Query(query, nil)
		if err != nil {
			return fmt.Errorf("failed to create index: %w", err)
		}
	}

	return nil
}

// DropIndex drops an index
func (c *surrealCollection) DropIndex(ctx context.Context, name string) error {
	if c.client == nil {
		return fmt.Errorf("client not initialized")
	}

	query := fmt.Sprintf("REMOVE INDEX %s ON TABLE %s", name, c.table)
	_, err := c.client.Query(query, nil)
	if err != nil {
		return fmt.Errorf("failed to drop index: %w", err)
	}

	return nil
}

// ListIndexes lists all indexes
func (c *surrealCollection) ListIndexes(ctx context.Context) ([]IndexInfo, error) {
	if c.client == nil {
		return nil, fmt.Errorf("client not initialized")
	}

	query := fmt.Sprintf("INFO FOR TABLE %s", c.table)
	result, err := c.client.Query(query, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to list indexes: %w", err)
	}

	var indexes []IndexInfo
	if len(result) > 0 {
		if resultMap, ok := result[0].Result.(map[string]interface{}); ok {
			if indexesMap, ok := resultMap["ix"].(map[string]interface{}); ok {
				for indexName, indexInfo := range indexesMap {
					index := IndexInfo{
						Name:   indexName,
						Keys:   make(map[string]interface{}),
						Unique: false,
					}

					// Parse index info
					if infoMap, ok := indexInfo.(map[string]interface{}); ok {
						if fields, ok := infoMap["cols"].([]interface{}); ok {
							for _, field := range fields {
								if fieldStr, ok := field.(string); ok {
									index.Keys[fieldStr] = 1
								}
							}
						}
						if unique, ok := infoMap["uniq"].(bool); ok {
							index.Unique = unique
						}
					}

					indexes = append(indexes, index)
				}
			}
		}
	}

	return indexes, nil
}

// BulkWrite performs bulk operations
func (c *surrealCollection) BulkWrite(ctx context.Context, operations []interface{}) error {
	if c.client == nil {
		return fmt.Errorf("client not initialized")
	}

	var statements []string
	variables := make(map[string]interface{})

	for i, operation := range operations {
		// Convert operation to document
		doc, err := c.convertToSurrealDocument(operation)
		if err != nil {
			return err
		}

		// Generate ID if not provided
		if doc.ID == "" {
			doc.ID = c.generateID()
		}

		// Set timestamps
		now := time.Now()
		doc.CreatedAt = now
		doc.UpdatedAt = now

		// Create variable name
		varName := fmt.Sprintf("data%d", i)
		variables[varName] = map[string]interface{}{
			"data":       doc.Data,
			"created_at": doc.CreatedAt,
			"updated_at": doc.UpdatedAt,
		}

		// Create statement
		statements = append(statements, fmt.Sprintf("CREATE %s:%s CONTENT $%s", c.table, doc.ID, varName))
	}

	// Execute batch query
	query := strings.Join(statements, "; ")
	_, err := c.client.Query(query, variables)
	if err != nil {
		return fmt.Errorf("bulk write failed: %w", err)
	}

	return nil
}

// Helper methods

// buildSelectQuery builds SELECT query from filter
func (c *surrealCollection) buildSelectQuery(filter interface{}, limit int) SurrealQuery {
	query := SurrealQuery{
		Query:     fmt.Sprintf("SELECT * FROM %s", c.table),
		Variables: make(map[string]interface{}),
	}

	// Add WHERE clause
	if filter != nil {
		whereClause, variables := c.buildWhereClause(filter)
		if whereClause != "" {
			query.Query += " WHERE " + whereClause
			for k, v := range variables {
				query.Variables[k] = v
			}
		}
	}

	// Add LIMIT clause
	if limit > 0 {
		query.Query += " LIMIT " + strconv.Itoa(limit)
	}

	return query
}

// buildUpdateQuery builds UPDATE query from filter and update
func (c *surrealCollection) buildUpdateQuery(filter interface{}, update interface{}) SurrealQuery {
	query := SurrealQuery{
		Query:     fmt.Sprintf("UPDATE %s", c.table),
		Variables: make(map[string]interface{}),
	}

	// Add SET clause
	if update != nil {
		setClause, variables := c.buildSetClause(update)
		if setClause != "" {
			query.Query += " SET " + setClause
			for k, v := range variables {
				query.Variables[k] = v
			}
		}
	}

	// Add WHERE clause
	if filter != nil {
		whereClause, variables := c.buildWhereClause(filter)
		if whereClause != "" {
			query.Query += " WHERE " + whereClause
			for k, v := range variables {
				query.Variables[k] = v
			}
		}
	}

	return query
}

// buildDeleteQuery builds DELETE query from filter
func (c *surrealCollection) buildDeleteQuery(filter interface{}) SurrealQuery {
	query := SurrealQuery{
		Query:     fmt.Sprintf("DELETE FROM %s", c.table),
		Variables: make(map[string]interface{}),
	}

	// Add WHERE clause
	if filter != nil {
		whereClause, variables := c.buildWhereClause(filter)
		if whereClause != "" {
			query.Query += " WHERE " + whereClause
			for k, v := range variables {
				query.Variables[k] = v
			}
		}
	}

	return query
}

// buildCountQuery builds COUNT query from filter
func (c *surrealCollection) buildCountQuery(filter interface{}) SurrealQuery {
	query := SurrealQuery{
		Query:     fmt.Sprintf("SELECT COUNT() AS count FROM %s", c.table),
		Variables: make(map[string]interface{}),
	}

	// Add WHERE clause
	if filter != nil {
		whereClause, variables := c.buildWhereClause(filter)
		if whereClause != "" {
			query.Query += " WHERE " + whereClause
			for k, v := range variables {
				query.Variables[k] = v
			}
		}
	}

	return query
}

// buildAggregationQuery builds aggregation query from pipeline
func (c *surrealCollection) buildAggregationQuery(pipeline interface{}) SurrealQuery {
	query := SurrealQuery{
		Query:     fmt.Sprintf("SELECT * FROM %s", c.table),
		Variables: make(map[string]interface{}),
	}

	// Parse pipeline for aggregation operations
	if pipelineSlice, ok := pipeline.([]interface{}); ok {
		for _, stage := range pipelineSlice {
			if stageMap, ok := stage.(map[string]interface{}); ok {
				for op, params := range stageMap {
					switch op {
					case "$match":
						if filter := params; filter != nil {
							whereClause, variables := c.buildWhereClause(filter)
							if whereClause != "" {
								query.Query += " WHERE " + whereClause
								for k, v := range variables {
									query.Variables[k] = v
								}
							}
						}
					case "$group":
						if paramMap, ok := params.(map[string]interface{}); ok {
							if id, ok := paramMap["_id"].(string); ok {
								query.Query = fmt.Sprintf("SELECT %s, COUNT() AS count FROM %s GROUP BY %s", id, c.table, id)
							}
						}
					case "$sort":
						if paramMap, ok := params.(map[string]interface{}); ok {
							var sortFields []string
							for field, order := range paramMap {
								direction := "ASC"
								if orderInt, ok := order.(int); ok && orderInt < 0 {
									direction = "DESC"
								}
								sortFields = append(sortFields, fmt.Sprintf("%s %s", field, direction))
							}
							if len(sortFields) > 0 {
								query.Query += " ORDER BY " + strings.Join(sortFields, ", ")
							}
						}
					case "$limit":
						if limit, ok := params.(int); ok {
							query.Query += " LIMIT " + strconv.Itoa(limit)
						}
					case "$skip":
						if skip, ok := params.(int); ok {
							query.Query += " START " + strconv.Itoa(skip)
						}
					}
				}
			}
		}
	}

	return query
}

// buildWhereClause builds WHERE clause from filter
func (c *surrealCollection) buildWhereClause(filter interface{}) (string, map[string]interface{}) {
	var clauses []string
	variables := make(map[string]interface{})

	if filterMap, ok := filter.(map[string]interface{}); ok {
		for key, value := range filterMap {
			varName := fmt.Sprintf("filter_%s", key)

			switch key {
			case "id", "_id":
				clauses = append(clauses, fmt.Sprintf("id = $%s", varName))
				variables[varName] = value
			default:
				switch v := value.(type) {
				case map[string]interface{}:
					// Handle operators like $eq, $ne, $gt, etc.
					for op, opValue := range v {
						switch op {
						case "$eq":
							clauses = append(clauses, fmt.Sprintf("%s = $%s", key, varName))
							variables[varName] = opValue
						case "$ne":
							clauses = append(clauses, fmt.Sprintf("%s != $%s", key, varName))
							variables[varName] = opValue
						case "$gt":
							clauses = append(clauses, fmt.Sprintf("%s > $%s", key, varName))
							variables[varName] = opValue
						case "$gte":
							clauses = append(clauses, fmt.Sprintf("%s >= $%s", key, varName))
							variables[varName] = opValue
						case "$lt":
							clauses = append(clauses, fmt.Sprintf("%s < $%s", key, varName))
							variables[varName] = opValue
						case "$lte":
							clauses = append(clauses, fmt.Sprintf("%s <= $%s", key, varName))
							variables[varName] = opValue
						case "$in":
							clauses = append(clauses, fmt.Sprintf("%s IN $%s", key, varName))
							variables[varName] = opValue
						case "$nin":
							clauses = append(clauses, fmt.Sprintf("%s NOT IN $%s", key, varName))
							variables[varName] = opValue
						}
					}
				default:
					clauses = append(clauses, fmt.Sprintf("%s = $%s", key, varName))
					variables[varName] = value
				}
			}
		}
	}

	return strings.Join(clauses, " AND "), variables
}

// buildSetClause builds SET clause from update
func (c *surrealCollection) buildSetClause(update interface{}) (string, map[string]interface{}) {
	var clauses []string
	variables := make(map[string]interface{})

	if updateMap, ok := update.(map[string]interface{}); ok {
		for op, value := range updateMap {
			switch op {
			case "$set":
				if setValue, ok := value.(map[string]interface{}); ok {
					for key, val := range setValue {
						varName := fmt.Sprintf("set_%s", key)
						clauses = append(clauses, fmt.Sprintf("%s = $%s", key, varName))
						variables[varName] = val
					}
				}
			case "$inc":
				if incValue, ok := value.(map[string]interface{}); ok {
					for key, val := range incValue {
						varName := fmt.Sprintf("inc_%s", key)
						clauses = append(clauses, fmt.Sprintf("%s += $%s", key, varName))
						variables[varName] = val
					}
				}
			case "$unset":
				if unsetValue, ok := value.(map[string]interface{}); ok {
					for key := range unsetValue {
						clauses = append(clauses, fmt.Sprintf("%s = NONE", key))
					}
				}
			}
		}
	}

	// Always update updated_at
	clauses = append(clauses, "updated_at = time::now()")

	return strings.Join(clauses, ", "), variables
}

// convertToSurrealDocument converts interface{} to SurrealDocument
func (c *surrealCollection) convertToSurrealDocument(document interface{}) (SurrealDocument, error) {
	var doc SurrealDocument

	switch d := document.(type) {
	case SurrealDocument:
		doc = d
	case map[string]interface{}:
		doc.Data = d
		if id, ok := d["id"].(string); ok {
			doc.ID = id
		}
		if id, ok := d["_id"].(string); ok {
			doc.ID = id
		}
		if createdAt, ok := d["created_at"].(time.Time); ok {
			doc.CreatedAt = createdAt
		}
		if updatedAt, ok := d["updated_at"].(time.Time); ok {
			doc.UpdatedAt = updatedAt
		}
	default:
		// Convert to JSON and back
		jsonData, err := json.Marshal(document)
		if err != nil {
			return doc, err
		}

		var data map[string]interface{}
		if err := json.Unmarshal(jsonData, &data); err != nil {
			return doc, err
		}

		doc.Data = data
	}

	return doc, nil
}

// generateID generates a unique ID
func (c *surrealCollection) generateID() string {
	return fmt.Sprintf("doc_%d", time.Now().UnixNano())
}

// SurrealDB Cursor implementation

// Next moves to the next document
func (c *surrealCursor) Next(ctx context.Context) bool {
	c.mu.Lock()
	defer c.mu.Unlock()

	if c.closed {
		return false
	}

	c.current++
	return c.current < len(c.documents)
}

// Decode decodes the current document
func (c *surrealCursor) Decode(dest interface{}) error {
	c.mu.RLock()
	defer c.mu.RUnlock()

	if c.closed {
		return fmt.Errorf("cursor is closed")
	}

	if c.current < 0 || c.current >= len(c.documents) {
		return fmt.Errorf("no current document")
	}

	// Convert to JSON and back to handle type conversion
	data, err := json.Marshal(c.documents[c.current])
	if err != nil {
		return err
	}

	return json.Unmarshal(data, dest)
}

// All decodes all documents
func (c *surrealCursor) All(ctx context.Context, dest interface{}) error {
	c.mu.RLock()
	defer c.mu.RUnlock()

	if c.closed {
		return fmt.Errorf("cursor is closed")
	}

	// Convert to JSON and back to handle type conversion
	data, err := json.Marshal(c.documents)
	if err != nil {
		return err
	}

	return json.Unmarshal(data, dest)
}

// Close closes the cursor
func (c *surrealCursor) Close(ctx context.Context) error {
	c.mu.Lock()
	defer c.mu.Unlock()

	c.closed = true
	return nil
}

// Current returns the current document
func (c *surrealCursor) Current() interface{} {
	c.mu.RLock()
	defer c.mu.RUnlock()

	if c.closed || c.current < 0 || c.current >= len(c.documents) {
		return nil
	}

	return c.documents[c.current]
}

// Err returns the last error
func (c *surrealCursor) Err() error {
	c.mu.RLock()
	defer c.mu.RUnlock()

	return c.err
}

// SurrealDB-specific utility functions

// GetClient returns the underlying SurrealDB client
func (db *surrealDatabase) GetClient() *surrealdb.DB {
	return db.client
}

// GetNamespace returns the namespace
func (db *surrealDatabase) GetNamespace() string {
	return db.namespace
}

// GetDatabase returns the database name
func (db *surrealDatabase) GetDatabase() string {
	return db.database
}

// ExecuteQuery executes a custom SurrealDB query
func (db *surrealDatabase) ExecuteQuery(ctx context.Context, query string, variables map[string]interface{}) ([]surrealdb.Result, error) {
	if db.client == nil {
		return nil, fmt.Errorf("SurrealDB not connected")
	}

	result, err := db.client.Query(query, variables)
	if err != nil {
		return nil, err
	}

	return result, nil
}

// ExecuteTransaction executes a transaction
func (db *surrealDatabase) ExecuteTransaction(ctx context.Context, queries []string, variables map[string]interface{}) error {
	if db.client == nil {
		return fmt.Errorf("SurrealDB not connected")
	}

	// Begin transaction
	if _, err := db.client.Query("BEGIN TRANSACTION", nil); err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}

	// Execute queries
	for _, query := range queries {
		if _, err := db.client.Query(query, variables); err != nil {
			// Rollback on error
			db.client.Query("CANCEL TRANSACTION", nil)
			return fmt.Errorf("transaction failed: %w", err)
		}
	}

	// Commit transaction
	if _, err := db.client.Query("COMMIT TRANSACTION", nil); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	return nil
}

// GetInfo returns database information
func (db *surrealDatabase) GetInfo(ctx context.Context) (map[string]interface{}, error) {
	if db.client == nil {
		return nil, fmt.Errorf("SurrealDB not connected")
	}

	result, err := db.client.Query("INFO FOR DB", nil)
	if err != nil {
		return nil, err
	}

	if len(result) == 0 {
		return nil, fmt.Errorf("no info returned")
	}

	if infoMap, ok := result[0].Result.(map[string]interface{}); ok {
		return infoMap, nil
	}

	return nil, fmt.Errorf("invalid info format")
}

// Stats returns database statistics
func (db *surrealDatabase) Stats() map[string]interface{} {
	db.mu.RLock()
	defer db.mu.RUnlock()

	stats := make(map[string]interface{})
	for k, v := range db.stats {
		stats[k] = v
	}

	stats["driver"] = db.driver
	stats["connected"] = db.connected
	stats["namespace"] = db.namespace
	stats["database"] = db.database
	stats["endpoint"] = db.endpoint
	stats["timeout"] = db.timeout

	return stats
}

// init function to register the SurrealDB constructor
func init() {
	NewSurrealDatabase = func(config NoSQLConfig) (NoSQLDatabase, error) {
		return newSurrealDatabase(config)
	}
}
