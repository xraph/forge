// v2/cmd/forge/plugins/dev_docker_test.go
package plugins

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/fsnotify/fsnotify"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/xraph/forge/cmd/forge/config"
)

func TestGenerateDevDockerfile(t *testing.T) {
	tmpDir := t.TempDir()

	// Create a fake main file.
	mainDir := filepath.Join(tmpDir, "cmd", "myapp")
	require.NoError(t, os.MkdirAll(mainDir, 0o755))

	mainFile := filepath.Join(mainDir, "main.go")
	require.NoError(t, os.WriteFile(mainFile, []byte("package main\nfunc main() {}"), 0o644))

	// Create go.mod so Dockerfile COPY works.
	require.NoError(t, os.WriteFile(filepath.Join(tmpDir, "go.mod"), []byte("module example.com/test\n"), 0o644))

	tests := []struct {
		name          string
		dockerConfig  *config.DockerDevConfig
		mainFilePath  string
		wantImage     string
		wantCmdSuffix string
	}{
		{
			name:          "default image",
			dockerConfig:  &config.DockerDevConfig{},
			mainFilePath:  mainFile,
			wantImage:     "golang:1.25-alpine",
			wantCmdSuffix: "./cmd/myapp",
		},
		{
			name: "custom image",
			dockerConfig: &config.DockerDevConfig{
				Image: "golang:1.25",
			},
			mainFilePath:  mainFile,
			wantImage:     "golang:1.25",
			wantCmdSuffix: "./cmd/myapp",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			dw := &dockerAppWatcher{
				config: &config.ForgeConfig{
					RootDir: tmpDir,
				},
				dockerConfig: tt.dockerConfig,
				mainFile:     tt.mainFilePath,
			}

			dockerfilePath, err := dw.generateDevDockerfile()
			require.NoError(t, err)

			t.Cleanup(func() {
				os.Remove(dockerfilePath)
			})

			// Read generated content.
			content, err := os.ReadFile(dockerfilePath)
			require.NoError(t, err)

			contentStr := string(content)

			// Verify FROM line.
			assert.Contains(t, contentStr, "FROM "+tt.wantImage)

			// Verify CMD includes the correct main directory.
			assert.Contains(t, contentStr, tt.wantCmdSuffix)

			// Verify essential Dockerfile directives.
			assert.Contains(t, contentStr, "WORKDIR /app")
			assert.Contains(t, contentStr, "COPY go.mod")
			assert.Contains(t, contentStr, "RUN go mod download")
			assert.Contains(t, contentStr, "COPY . .")

			// Verify file is in the project root.
			assert.Equal(t, tmpDir, filepath.Dir(dockerfilePath))

			// Verify file starts with the forge header.
			assert.True(t, strings.HasPrefix(contentStr, "# Auto-generated by forge dev --docker"))
		})
	}
}

func TestGenerateDevDockerfileWithConfigFiles(t *testing.T) {
	tmpDir := t.TempDir()

	// Create a fake main file.
	mainDir := filepath.Join(tmpDir, "cmd", "myapp")
	require.NoError(t, os.MkdirAll(mainDir, 0o755))

	mainFile := filepath.Join(mainDir, "main.go")
	require.NoError(t, os.WriteFile(mainFile, []byte("package main\nfunc main() {}"), 0o644))

	// Create go.mod.
	require.NoError(t, os.WriteFile(filepath.Join(tmpDir, "go.mod"), []byte("module example.com/test\n"), 0o644))

	// Create Forge config files.
	require.NoError(t, os.WriteFile(filepath.Join(tmpDir, ".forge.yaml"), []byte("project:\n  name: test\n"), 0o644))

	// Create config/ directory with files.
	require.NoError(t, os.MkdirAll(filepath.Join(tmpDir, "config"), 0o755))
	require.NoError(t, os.WriteFile(filepath.Join(tmpDir, "config", "config.yaml"), []byte("key: val\n"), 0o644))

	// Create config.yaml at root.
	require.NoError(t, os.WriteFile(filepath.Join(tmpDir, "config.yaml"), []byte("root: config\n"), 0o644))

	// Create .env files.
	require.NoError(t, os.WriteFile(filepath.Join(tmpDir, ".env"), []byte("DB_URL=postgres://localhost\n"), 0o644))
	require.NoError(t, os.WriteFile(filepath.Join(tmpDir, ".env.local"), []byte("DEBUG=true\n"), 0o644))
	require.NoError(t, os.WriteFile(filepath.Join(tmpDir, ".env.development"), []byte("ENV=dev\n"), 0o644))

	// Create per-app config.
	appsConfigDir := filepath.Join(tmpDir, "apps", "myapp")
	require.NoError(t, os.MkdirAll(appsConfigDir, 0o755))
	require.NoError(t, os.WriteFile(filepath.Join(appsConfigDir, ".forge.yaml"), []byte("app:\n  name: myapp\n"), 0o644))

	// Create database/ directory.
	require.NoError(t, os.MkdirAll(filepath.Join(tmpDir, "database", "migrations"), 0o755))
	require.NoError(t, os.WriteFile(
		filepath.Join(tmpDir, "database", "migrations", "001_init.sql"),
		[]byte("CREATE TABLE test;"),
		0o644,
	))

	dw := &dockerAppWatcher{
		config: &config.ForgeConfig{
			RootDir: tmpDir,
		},
		dockerConfig: &config.DockerDevConfig{},
		mainFile:     mainFile,
	}

	dockerfilePath, err := dw.generateDevDockerfile()
	require.NoError(t, err)

	t.Cleanup(func() {
		os.Remove(dockerfilePath)
	})

	content, err := os.ReadFile(dockerfilePath)
	require.NoError(t, err)

	contentStr := string(content)

	// Should have the config files comment.
	assert.Contains(t, contentStr, "# Forge config files")

	// Should COPY .forge.yaml.
	assert.Contains(t, contentStr, "COPY .forge.yaml ./")

	// Should COPY config/ directory.
	assert.Contains(t, contentStr, "COPY config/ ./config/")

	// Should COPY config.yaml at root.
	assert.Contains(t, contentStr, "COPY config.yaml ./")

	// Should COPY .env files.
	assert.Contains(t, contentStr, "COPY .env ./")
	assert.Contains(t, contentStr, "COPY .env.local ./")
	assert.Contains(t, contentStr, "COPY .env.development ./")

	// Should COPY per-app .forge.yaml.
	assert.Contains(t, contentStr, "COPY apps/myapp/.forge.yaml ./apps/myapp/.forge.yaml")

	// Should COPY database/ directory.
	assert.Contains(t, contentStr, "COPY database/ ./database/")

	// Standard Dockerfile directives should still be present.
	assert.Contains(t, contentStr, "FROM golang:1.25-alpine")
	assert.Contains(t, contentStr, "COPY go.mod")
	assert.Contains(t, contentStr, "RUN go mod download")
	assert.Contains(t, contentStr, "COPY . .")
	assert.Contains(t, contentStr, "./cmd/myapp")
}

func TestGenerateDevDockerfileNoConfigFiles(t *testing.T) {
	tmpDir := t.TempDir()

	// Create only the minimal required files (main.go and go.mod).
	mainDir := filepath.Join(tmpDir, "cmd", "myapp")
	require.NoError(t, os.MkdirAll(mainDir, 0o755))

	mainFile := filepath.Join(mainDir, "main.go")
	require.NoError(t, os.WriteFile(mainFile, []byte("package main\nfunc main() {}"), 0o644))

	require.NoError(t, os.WriteFile(filepath.Join(tmpDir, "go.mod"), []byte("module example.com/test\n"), 0o644))

	dw := &dockerAppWatcher{
		config: &config.ForgeConfig{
			RootDir: tmpDir,
		},
		dockerConfig: &config.DockerDevConfig{},
		mainFile:     mainFile,
	}

	dockerfilePath, err := dw.generateDevDockerfile()
	require.NoError(t, err)

	t.Cleanup(func() {
		os.Remove(dockerfilePath)
	})

	content, err := os.ReadFile(dockerfilePath)
	require.NoError(t, err)

	contentStr := string(content)

	// Should NOT have config files comment when none exist.
	assert.NotContains(t, contentStr, "# Forge config files")

	// Should still have the essential directives.
	assert.Contains(t, contentStr, "FROM golang:1.25-alpine")
	assert.Contains(t, contentStr, "RUN go mod download")
	assert.Contains(t, contentStr, "COPY . .")
}

func TestResolveDockerConfig(t *testing.T) {
	tests := []struct {
		name        string
		projectCfg  config.DockerDevConfig
		appConfig   *config.AppConfig
		networkFlag string
		wantImage   string
		wantNetwork string
		wantEnvKey  string
		wantEnvVal  string
	}{
		{
			name:        "defaults only",
			projectCfg:  config.DockerDevConfig{},
			appConfig:   nil,
			networkFlag: "",
			wantImage:   "",
			wantNetwork: "",
		},
		{
			name: "project-level config",
			projectCfg: config.DockerDevConfig{
				Image:   "golang:1.25-alpine",
				Network: "my-net",
			},
			appConfig:   nil,
			networkFlag: "",
			wantImage:   "golang:1.25-alpine",
			wantNetwork: "my-net",
		},
		{
			name: "app-level overrides project",
			projectCfg: config.DockerDevConfig{
				Image:   "golang:1.25-alpine",
				Network: "project-net",
			},
			appConfig: &config.AppConfig{
				Dev: config.AppDevConfig{
					Docker: &config.DockerDevConfig{
						Image:   "golang:1.25",
						Network: "app-net",
					},
				},
			},
			networkFlag: "",
			wantImage:   "golang:1.25",
			wantNetwork: "app-net",
		},
		{
			name: "CLI flag overrides everything",
			projectCfg: config.DockerDevConfig{
				Network: "project-net",
			},
			appConfig: &config.AppConfig{
				Dev: config.AppDevConfig{
					Docker: &config.DockerDevConfig{
						Network: "app-net",
					},
				},
			},
			networkFlag: "cli-net",
			wantImage:   "",
			wantNetwork: "cli-net",
		},
		{
			name: "env merge app over project",
			projectCfg: config.DockerDevConfig{
				Env: map[string]string{
					"SHARED":  "project-val",
					"PROJECT": "only-project",
				},
			},
			appConfig: &config.AppConfig{
				Dev: config.AppDevConfig{
					Docker: &config.DockerDevConfig{
						Env: map[string]string{
							"SHARED": "app-val",
							"APP":    "only-app",
						},
					},
				},
			},
			networkFlag: "",
			wantEnvKey:  "SHARED",
			wantEnvVal:  "app-val",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			plugin := &DevPlugin{
				config: &config.ForgeConfig{
					Dev: config.DevConfig{
						Docker: tt.projectCfg,
					},
				},
			}

			app := &AppInfo{
				Name:      "test-app",
				AppConfig: tt.appConfig,
			}

			result := plugin.resolveDockerConfig(app, tt.networkFlag)

			if tt.wantImage != "" {
				assert.Equal(t, tt.wantImage, result.Image)
			}

			if tt.wantNetwork != "" {
				assert.Equal(t, tt.wantNetwork, result.Network)
			}

			if tt.wantEnvKey != "" {
				assert.Equal(t, tt.wantEnvVal, result.Env[tt.wantEnvKey])
			}
		})
	}
}

func TestDockerContainerNaming(t *testing.T) {
	tests := []struct {
		name              string
		appName           string
		wantContainerName string
		wantImageName     string
	}{
		{
			name:              "simple name",
			appName:           "api",
			wantContainerName: "forge-dev-api",
			wantImageName:     "forge-dev-api:latest",
		},
		{
			name:              "hyphenated name",
			appName:           "api-gateway",
			wantContainerName: "forge-dev-api-gateway",
			wantImageName:     "forge-dev-api-gateway:latest",
		},
		{
			name:              "worker app",
			appName:           "worker",
			wantContainerName: "forge-dev-worker",
			wantImageName:     "forge-dev-worker:latest",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			containerName := "forge-dev-" + tt.appName
			imageName := "forge-dev-" + tt.appName + ":latest"

			assert.Equal(t, tt.wantContainerName, containerName)
			assert.Equal(t, tt.wantImageName, imageName)
		})
	}
}

func TestDockerDevConfigGetters(t *testing.T) {
	t.Run("GetImage default", func(t *testing.T) {
		cfg := &config.DockerDevConfig{}
		assert.Equal(t, "golang:1.25-alpine", cfg.GetImage())
	})

	t.Run("GetImage custom", func(t *testing.T) {
		cfg := &config.DockerDevConfig{Image: "golang:1.25"}
		assert.Equal(t, "golang:1.25", cfg.GetImage())
	})

	t.Run("GetNetwork default", func(t *testing.T) {
		cfg := &config.DockerDevConfig{}
		assert.Equal(t, "bridge", cfg.GetNetwork())
	})

	t.Run("GetNetwork custom", func(t *testing.T) {
		cfg := &config.DockerDevConfig{Network: "my-net"}
		assert.Equal(t, "my-net", cfg.GetNetwork())
	})
}

func TestShouldReloadShared(t *testing.T) {
	// Test the shared shouldReloadEvent with exclude patterns.
	cfg := &config.ForgeConfig{
		RootDir: "/project",
		Dev: config.DevConfig{
			Watch: config.WatchConfig{
				Enabled: true,
				Exclude: []string{
					"**/*_test.go",
					"**/vendor/**",
				},
			},
		},
	}

	tests := []struct {
		name     string
		fileName string
		expected bool
	}{
		{
			name:     "regular go file",
			fileName: "/project/internal/service.go",
			expected: true,
		},
		{
			name:     "test file with exclude pattern",
			fileName: "/project/internal/service_test.go",
			expected: false,
		},
		{
			name:     "file in nested testdata",
			fileName: "/project/internal/testdata/fixture.go",
			expected: true, // testdata is not in exclude patterns above.
		},
		{
			name:     "non-go file",
			fileName: "/project/README.md",
			expected: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			event := createWriteEvent(tt.fileName)
			result := shouldReloadEvent(event, cfg, cfg.RootDir)
			assert.Equal(t, tt.expected, result)
		})
	}
}

func TestMatchGlobPattern(t *testing.T) {
	tests := []struct {
		name    string
		pattern string
		relPath string
		base    string
		want    bool
	}{
		{
			name:    "simple test file match",
			pattern: "*_test.go",
			relPath: "internal/service_test.go",
			base:    "service_test.go",
			want:    true,
		},
		{
			name:    "double star test file",
			pattern: "**/*_test.go",
			relPath: "internal/service_test.go",
			base:    "service_test.go",
			want:    true,
		},
		{
			name:    "deep nested test file",
			pattern: "**/*_test.go",
			relPath: "pkg/util/helpers_test.go",
			base:    "helpers_test.go",
			want:    true,
		},
		{
			name:    "non-matching pattern",
			pattern: "*.txt",
			relPath: "internal/service.go",
			base:    "service.go",
			want:    false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := matchGlobPattern(tt.pattern, tt.relPath, tt.base)
			assert.Equal(t, tt.want, result)
		})
	}
}

// createWriteEvent creates a fsnotify write event for testing.
func createWriteEvent(name string) fsnotify.Event {
	return fsnotify.Event{
		Name: name,
		Op:   fsnotify.Write,
	}
}
