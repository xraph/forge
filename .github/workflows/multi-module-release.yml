name: Multi-Module Release

on:
  push:
    tags:
      - 'v*.*.*'                          # Main module: v1.2.3
      - 'v*.*.*-*'                        # Main pre-release: v1.2.3-beta.1
      - 'extensions/*/v*.*.*'             # Extension: extensions/grpc/v1.2.3
      - 'extensions/*/v*.*.*-*'           # Extension pre-release

permissions:
  contents: write
  packages: write

jobs:
  parse-tag:
    runs-on: ubuntu-latest
    outputs:
      module_type: ${{ steps.parse.outputs.module_type }}
      module_name: ${{ steps.parse.outputs.module_name }}
      module_path: ${{ steps.parse.outputs.module_path }}
      module_import: ${{ steps.parse.outputs.module_import }}
      version: ${{ steps.parse.outputs.version }}
      is_prerelease: ${{ steps.parse.outputs.is_prerelease }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Parse tag and determine module
        id: parse
        run: |
          TAG="${{ github.ref_name }}"
          echo "Processing tag: $TAG"
          
          # Extension module pattern: extensions/<module>/v<version>
          if [[ "$TAG" =~ ^extensions/([^/]+)/v(.+)$ ]]; then
            MODULE_NAME="${BASH_REMATCH[1]}"
            VERSION="${BASH_REMATCH[2]}"
            MODULE_PATH="extensions/$MODULE_NAME"
            MODULE_IMPORT="github.com/xraph/forge/extensions/$MODULE_NAME"
            MODULE_TYPE="extension"
            
            echo "üì¶ Extension module: $MODULE_NAME"
            
          # Main module pattern: v<version>
          elif [[ "$TAG" =~ ^v(.+)$ ]]; then
            VERSION="${BASH_REMATCH[1]}"
            MODULE_PATH="."
            MODULE_NAME="forge"
            MODULE_IMPORT="github.com/xraph/forge"
            MODULE_TYPE="main"
            
            echo "üì¶ Main module: forge"
          else
            echo "‚ùå Invalid tag format: $TAG"
            echo "Expected: v1.2.3 or extensions/<module>/v1.2.3"
            exit 1
          fi
          
          # Check if pre-release
          if [[ "$VERSION" == *"-"* ]]; then
            IS_PRERELEASE="true"
            echo "üöß Pre-release version"
          else
            IS_PRERELEASE="false"
            echo "üöÄ Stable release"
          fi
          
          # Validate semantic version
          if [[ ! "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+(-[a-zA-Z0-9.]+)?$ ]]; then
            echo "‚ùå Invalid semantic version: $VERSION"
            exit 1
          fi
          
          # Output values
          echo "module_type=$MODULE_TYPE" >> $GITHUB_OUTPUT
          echo "module_name=$MODULE_NAME" >> $GITHUB_OUTPUT
          echo "module_path=$MODULE_PATH" >> $GITHUB_OUTPUT
          echo "module_import=$MODULE_IMPORT" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "is_prerelease=$IS_PRERELEASE" >> $GITHUB_OUTPUT
          
          # Display summary
          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## üì¶ Release Information
          
          - **Module Type**: $MODULE_TYPE
          - **Module Name**: $MODULE_NAME
          - **Module Path**: \`$MODULE_PATH\`
          - **Import Path**: \`$MODULE_IMPORT\`
          - **Version**: $VERSION
          - **Pre-release**: $IS_PRERELEASE
          - **Tag**: $TAG
          EOF

      - name: Verify module exists
        run: |
          MODULE_PATH="${{ steps.parse.outputs.module_path }}"
          
          if [ ! -f "$MODULE_PATH/go.mod" ]; then
            echo "‚ùå go.mod not found at $MODULE_PATH"
            exit 1
          fi
          
          echo "‚úÖ Module found at $MODULE_PATH"

  test-module:
    needs: parse-tag
    runs-on: ${{ matrix.os }}
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: ${{ needs.parse-tag.outputs.module_path }}/go.mod
          check-latest: true

      - name: Cache Go modules
        uses: actions/cache@v4
        with:
          path: |
            ~/go/pkg/mod
            ~/.cache/go-build
          key: ${{ runner.os }}-go-${{ needs.parse-tag.outputs.module_name }}-${{ hashFiles(format('{0}/go.sum', needs.parse-tag.outputs.module_path)) }}

      - name: Download dependencies
        run: |
          cd ${{ needs.parse-tag.outputs.module_path }}
          go mod download
          go mod verify

      - name: Run tests
        run: |
          cd ${{ needs.parse-tag.outputs.module_path }}
          go test -v -race -timeout=15m ./...

      - name: Build (if applicable)
        if: needs.parse-tag.outputs.module_type == 'main'
        run: |
          cd cmd/forge
          go build -v -ldflags="-s -w -X main.version=${{ needs.parse-tag.outputs.version }}" -o forge${{ matrix.os == 'windows-latest' && '.exe' || '' }} .

  generate-changelog:
    needs: parse-tag
    runs-on: ubuntu-latest
    outputs:
      changelog: ${{ steps.changelog.outputs.content }}
      previous_tag: ${{ steps.changelog.outputs.previous_tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate changelog
        id: changelog
        run: |
          MODULE_PATH="${{ needs.parse-tag.outputs.module_path }}"
          MODULE_NAME="${{ needs.parse-tag.outputs.module_name }}"
          MODULE_TYPE="${{ needs.parse-tag.outputs.module_type }}"
          CURRENT_TAG="${{ github.ref_name }}"
          
          # Find previous tag for this module
          if [ "$MODULE_TYPE" = "main" ]; then
            PREV_TAG=$(git tag -l "v*" --sort=-version:refname | grep -v "extensions" | grep -v "$CURRENT_TAG" | head -1)
          else
            PREV_TAG=$(git tag -l "extensions/$MODULE_NAME/v*" --sort=-version:refname | grep -v "$CURRENT_TAG" | head -1)
          fi
          
          echo "previous_tag=$PREV_TAG" >> $GITHUB_OUTPUT
          
          CHANGELOG_FILE=/tmp/changelog.txt
          
          if [ -z "$PREV_TAG" ]; then
            echo "üéâ First release for $MODULE_NAME"
            echo "## First Release" > "$CHANGELOG_FILE"
            echo "" >> "$CHANGELOG_FILE"
            echo "This is the first release of the $MODULE_NAME module." >> "$CHANGELOG_FILE"
            echo "" >> "$CHANGELOG_FILE"
            echo "### Installation" >> "$CHANGELOG_FILE"
            echo "" >> "$CHANGELOG_FILE"
            echo '```bash' >> "$CHANGELOG_FILE"
            echo "go get ${{ needs.parse-tag.outputs.module_import }}@$CURRENT_TAG" >> "$CHANGELOG_FILE"
            echo '```' >> "$CHANGELOG_FILE"
          else
            echo "üìù Generating changelog from $PREV_TAG to $CURRENT_TAG"
            
            if [ "$MODULE_PATH" = "." ]; then
              COMMITS=$(git log $PREV_TAG..$CURRENT_TAG --oneline --no-merges -- . ':!extensions/' ':!examples/' ':!_v0/' ':!bk/' 2>/dev/null || echo "")
            else
              COMMITS=$(git log $PREV_TAG..$CURRENT_TAG --oneline --no-merges -- "$MODULE_PATH/" 2>/dev/null || echo "")
            fi
            
            if [ -z "$COMMITS" ]; then
              echo "## No Changes" > "$CHANGELOG_FILE"
              echo "" >> "$CHANGELOG_FILE"
              echo "No code changes in this module since $PREV_TAG." >> "$CHANGELOG_FILE"
              echo "" >> "$CHANGELOG_FILE"
              echo "This release updates dependencies or metadata only." >> "$CHANGELOG_FILE"
            else
              FEATURES=$(echo "$COMMITS" | grep -i "feat" || true)
              FIXES=$(echo "$COMMITS" | grep -i "fix" || true)
              BREAKING=$(echo "$COMMITS" | grep -i "BREAKING\|!" || true)
              PERF=$(echo "$COMMITS" | grep -i "perf" || true)
              REFACTOR=$(echo "$COMMITS" | grep -i "refactor" || true)
              
              echo "## What's Changed" > "$CHANGELOG_FILE"
              
              if [ -n "$BREAKING" ]; then
                echo "" >> "$CHANGELOG_FILE"
                echo "### ‚ö†Ô∏è BREAKING CHANGES" >> "$CHANGELOG_FILE"
                echo "" >> "$CHANGELOG_FILE"
                echo "$BREAKING" >> "$CHANGELOG_FILE"
              fi
              
              if [ -n "$FEATURES" ]; then
                echo "" >> "$CHANGELOG_FILE"
                echo "### ‚ú® New Features" >> "$CHANGELOG_FILE"
                echo "" >> "$CHANGELOG_FILE"
                echo "$FEATURES" >> "$CHANGELOG_FILE"
              fi
              
              if [ -n "$FIXES" ]; then
                echo "" >> "$CHANGELOG_FILE"
                echo "### üêõ Bug Fixes" >> "$CHANGELOG_FILE"
                echo "" >> "$CHANGELOG_FILE"
                echo "$FIXES" >> "$CHANGELOG_FILE"
              fi
              
              if [ -n "$PERF" ]; then
                echo "" >> "$CHANGELOG_FILE"
                echo "### ‚ö° Performance Improvements" >> "$CHANGELOG_FILE"
                echo "" >> "$CHANGELOG_FILE"
                echo "$PERF" >> "$CHANGELOG_FILE"
              fi
              
              if [ -n "$REFACTOR" ]; then
                echo "" >> "$CHANGELOG_FILE"
                echo "### üî® Refactoring" >> "$CHANGELOG_FILE"
                echo "" >> "$CHANGELOG_FILE"
                echo "$REFACTOR" >> "$CHANGELOG_FILE"
              fi
              
              echo "" >> "$CHANGELOG_FILE"
              echo "### Installation" >> "$CHANGELOG_FILE"
              echo "" >> "$CHANGELOG_FILE"
              echo '```bash' >> "$CHANGELOG_FILE"
              echo "go get ${{ needs.parse-tag.outputs.module_import }}@$CURRENT_TAG" >> "$CHANGELOG_FILE"
              echo '```' >> "$CHANGELOG_FILE"
              echo "" >> "$CHANGELOG_FILE"
              echo "**Full Changelog**: [\`$PREV_TAG...$CURRENT_TAG\`](https://github.com/${{ github.repository }}/compare/$PREV_TAG...$CURRENT_TAG)" >> "$CHANGELOG_FILE"
            fi
          fi
          
          # Save changelog to output
          echo "content<<EOF" >> $GITHUB_OUTPUT
          cat "$CHANGELOG_FILE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

  create-release:
    needs: [parse-tag, test-module, generate-changelog]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref_name }}
          name: ${{ needs.parse-tag.outputs.module_name }} ${{ needs.parse-tag.outputs.version }}
          body: |
            # ${{ needs.parse-tag.outputs.module_name }} Release ${{ needs.parse-tag.outputs.version }}
            
            **Module**: `${{ needs.parse-tag.outputs.module_import }}`  
            **Version**: `${{ needs.parse-tag.outputs.version }}`  
            **Type**: ${{ needs.parse-tag.outputs.module_type }}
            
            ${{ needs.generate-changelog.outputs.changelog }}
            
            ---
            
            ### üì¶ Go Module Installation
            
            ```bash
            go get ${{ needs.parse-tag.outputs.module_import }}@${{ github.ref_name }}
            ```
            
            ### üìö Documentation
            
            - [pkg.go.dev](${{ format('https://pkg.go.dev/{0}@{1}', needs.parse-tag.outputs.module_import, github.ref_name) }})
            - [GitHub Repository](https://github.com/${{ github.repository }})
          draft: false
          prerelease: ${{ needs.parse-tag.outputs.is_prerelease == 'true' }}
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Notify Go proxy
        run: |
          # Trigger Go proxy to fetch the new version
          MODULE_IMPORT="${{ needs.parse-tag.outputs.module_import }}"
          TAG="${{ github.ref_name }}"
          
          echo "Notifying Go proxy about $MODULE_IMPORT@$TAG"
          
          # Give GitHub a moment to make the tag available
          sleep 5
          
          # Request the module info to warm the proxy cache
          curl -f "https://proxy.golang.org/$MODULE_IMPORT/@v/$TAG.info" || \
            echo "‚ö†Ô∏è Go proxy notification failed (this is normal for private repos)"

  release-summary:
    needs: [parse-tag, create-release]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Generate release summary
        run: |
          if [ "${{ needs.create-release.result }}" = "success" ]; then
            cat >> $GITHUB_STEP_SUMMARY << EOF
          # üéâ Release Successful!
          
          ## Module Information
          - **Name**: ${{ needs.parse-tag.outputs.module_name }}
          - **Type**: ${{ needs.parse-tag.outputs.module_type }}
          - **Version**: ${{ needs.parse-tag.outputs.version }}
          - **Import Path**: \`${{ needs.parse-tag.outputs.module_import }}\`
          
          ## Installation
          
          \`\`\`bash
          go get ${{ needs.parse-tag.outputs.module_import }}@${{ github.ref_name }}
          \`\`\`
          
          ## Links
          - [GitHub Release](https://github.com/${{ github.repository }}/releases/tag/${{ github.ref_name }})
          - [Go Package Documentation](https://pkg.go.dev/${{ needs.parse-tag.outputs.module_import }}@${{ github.ref_name }})
          
          ---
          Released at: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          EOF
          else
            cat >> $GITHUB_STEP_SUMMARY << EOF
          # ‚ùå Release Failed
          
          The release workflow encountered errors. Please check the logs above.
          
          Module: ${{ needs.parse-tag.outputs.module_name }}  
          Tag: ${{ github.ref_name }}
          EOF
            exit 1
          fi

